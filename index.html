<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="My Web">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Web">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zijun Wei">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>My Web</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Web</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%E9%A6%96%E9%A1%B5" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/%E5%BD%92%E6%A1%A3" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/%E5%88%86%E7%B1%BB" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/%E6%A0%87%E7%AD%BE" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/%E5%85%B3%E4%BA%8E" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/%E6%90%9C%E7%B4%A2" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Search
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zijun Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Web">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/23/note/" itemprop="url">introduction to python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-23T19:20:33+08:00">
                2020-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer/" itemprop="url" rel="index">
                    <span itemprop="name">computer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h1><h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><ul>
<li>整型：(int)</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本</li>
<li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写）</li>
<li>复数型：虚部的<code>i</code>换成了<code>j</code>。<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><strong>输入：</strong>\<br>使用input()函数获取键盘输入，使用int()进行类型转换<pre><code class="hljs Python">a = int(input(<span class="hljs-string">'a = '</span>))</code></pre>
若为<code>a = input(&#39;a = &#39;)</code>则此时a为字符串</li>
</ul>
<p><strong>输出：</strong><br><pre><code class="hljs Python">a=<span class="hljs-number">1</span>
print(<span class="hljs-string">"a = "</span>, a)</code></pre><br>输出为a=1<br><pre><code class="hljs Python">a = int(input(<span class="hljs-string">'a = '</span>))
b = int(input(<span class="hljs-string">'b = '</span>))
print(<span class="hljs-string">'%d + %d = %d'</span> % (a, b, a + b))</code></pre><br>对<code>print</code>的理解——使用占位符格式化输出的字符串<code>%d</code>中<code>d</code>可以是任意的字符，代表占位。\<br>但占位字符需保持一致.下述代码不能通过编译<br><pre><code class="hljs Python"><span class="hljs-string">'''</span>
<span class="hljs-string">错误示范</span>
<span class="hljs-string">'''</span>
print(<span class="hljs-string">'%a + %b = %b'</span> % (a, b, a + b))</code></pre><br><strong>检查变量的类型：</strong><br><pre><code class="hljs Python"><span class="hljs-string">'''</span>
<span class="hljs-string">显示变量的数据类型</span>
<span class="hljs-string">'''</span>
print(type(a))</code></pre><br><strong>变量转换的内置函数</strong></p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>按照优先级从高到低的顺序列出了所有的运算符</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]</code> ,<code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> ,<code>+</code> ,<code>-</code></td>
<td>按位取反, 正负号</td>
</tr>
<tr>
<td><code>*</code>, <code>/</code>, <code>%</code> ,<code>//</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>+</code> ,<code>-</code></td>
<td>加，减</td>
</tr>
<tr>
<td><code>&gt;&gt;</code>, <code>&lt;&lt;</code></td>
<td>右移，左移</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> ,`\</td>
<td>`</td>
<td>按位异或，按位或</td>
</tr>
<tr>
<td><code>&lt;=</code>, <code>&lt;</code> ,<code>&gt;</code>, <code>&gt;=</code></td>
<td>小于等于，小于，大于，大于等于</td>
</tr>
<tr>
<td><code>==</code> ,<code>!=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td><code>is</code> , <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> ,<code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code>, <code>or</code> <code>and</code></td>
<td>逻辑运算符</td>
</tr>
<tr>
<td><code>=</code> ,<code>+=</code> ,<code>-=</code> ,<code>*=</code> ,<code>/=</code>, <code>%=</code>, <code>//=</code> ,<code>**=</code> ,<code>&amp;=</code>, `</td>
<td>=<code>,</code>^=<code>,</code>&gt;&gt;=<code>,</code>&lt;&lt;=`</td>
<td>（复合）赋值运算符</td>
</tr>
</tbody>
</table>
</div>
<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><h2 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h2><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span>
<span class="hljs-string">分段函数求值</span>
<span class="hljs-string"></span>
<span class="hljs-string">        3x - 5  (x &gt; 1)</span>
<span class="hljs-string">f(x) =  x + 2   (-1 &lt;= x &lt;= 1)</span>
<span class="hljs-string">        5x + 3  (x &lt; -1)</span>
<span class="hljs-string"></span>
<span class="hljs-string">"""</span>

x = float(input(<span class="hljs-string">'x = '</span>))
<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:
    y = <span class="hljs-number">3</span> * x - <span class="hljs-number">5</span>
<span class="hljs-keyword">elif</span> x &gt;= <span class="hljs-number">-1</span>:
    y = x + <span class="hljs-number">2</span>
<span class="hljs-keyword">else</span>:
    y = <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span>
print(<span class="hljs-string">'f(%.2f) = %.2f'</span> % (x, y))</code></pre><br>Python中使用了缩进的方式来设置代码的层次结构，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。<br><pre><code class="hljs Python">x = float(input(<span class="hljs-string">'x = '</span>))
<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:
    y = <span class="hljs-number">3</span> * x - <span class="hljs-number">5</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">-1</span>:
        y = x + <span class="hljs-number">2</span>
    <span class="hljs-keyword">else</span>:
        y = <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span>
print(<span class="hljs-string">'f(%.2f) = %.2f'</span> % (x, y))</code></pre><br><strong>补充</strong>\<br>1.使用random模块的randint函数生成指定范围的随机数来模拟<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint</code></pre><br>2.使用了<code>math</code>模块的<code>sqrt</code>函数来计算平方根。<br><pre><code class="hljs Python"><span class="hljs-keyword">import</span> math
a = float(input(<span class="hljs-string">'a = '</span>))
b = float(input(<span class="hljs-string">'b = '</span>))
c = float(input(<span class="hljs-string">'c = '</span>))
<span class="hljs-keyword">if</span> a + b &gt; c <span class="hljs-keyword">and</span> a + c &gt; b <span class="hljs-keyword">and</span> b + c &gt; a:
    print(<span class="hljs-string">'周长: %f'</span> % (a + b + c))
    p = (a + b + c) / <span class="hljs-number">2</span>
    area = math.sqrt(p * (p - a) * (p - b) * (p - c))
    print(<span class="hljs-string">'面积: %f'</span> % (area))
<span class="hljs-keyword">else</span>:
    print(<span class="hljs-string">'不能构成三角形'</span>)</code></pre><br>3.Python内置的<code>abs()</code>函数取绝对值</p>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h2><p>明确的知道循环执行的次数或者要对一个容器进行迭代，推荐使用<code>for-in</code>循环。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span>
<span class="hljs-string">用for循环实现1~100求和</span>
<span class="hljs-string"></span>
<span class="hljs-string">"""</span>

sum = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>):
    sum += x
print(sum)</code></pre><br><strong>说明：</strong><code>range</code>类型\<br><code>range</code>可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的</p>
<ul>
<li><code>range(101)</code>可以产生一个0到100的整数序列。</li>
<li><code>range(1, 100)</code>可以产生一个1到99的整数序列。</li>
<li><code>range(1, 100, 2)</code>可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。</li>
</ul>
<p>注意：最后一位数不取。</p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>要构造不知道具体循环次数的循环结构，推荐使用<code>while</code>循环。\<br><code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>循环继续，表达式的值为<code>False</code>循环结束。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span>
<span class="hljs-string">猜数字游戏</span>
<span class="hljs-string">计算机出一个1~100之间的随机数由人来猜</span>
<span class="hljs-string">计算机根据人猜的数字分别给出提示大一点/小一点/猜对了</span>
<span class="hljs-string">"""</span>

<span class="hljs-keyword">import</span> random

answer = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)
counter = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    counter += <span class="hljs-number">1</span>
    number = int(input(<span class="hljs-string">'请输入: '</span>))
    <span class="hljs-keyword">if</span> number &lt; answer:
        print(<span class="hljs-string">'大一点'</span>)
    <span class="hljs-keyword">elif</span> number &gt; answer:
        print(<span class="hljs-string">'小一点'</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">'恭喜你猜对了!'</span>)
        <span class="hljs-keyword">break</span>
print(<span class="hljs-string">'你总共猜了%d次'</span> % counter)
<span class="hljs-keyword">if</span> counter &gt; <span class="hljs-number">7</span>:
    print(<span class="hljs-string">'你的智商余额明显不足'</span>)</code></pre><br><strong>说明</strong>\<br>1.<code>answer = random.randint(1, 100)</code>的理解：调用<code>random</code>包的<code>randint</code>函数。不可以只写<code>answer =randint(1, 100)</code>。要想直接使用<code>randint</code>，开头需改为<code>from randint import random</code>\<br>2.<code>while True:</code>的理解：循环条件一直为true，循环一致进行。\<br>3.使用<code>break</code>关键字来提前终止循环，当条件成立时（esle）运行<code>break</code>循环中断。注意<code>break</code>只能终止它所在的那个循环（跳出循环）。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮（不终止循环）</p>
<p>补充 ：<code>#%%</code>开启交互模式</p>
<h2 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h2><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在Python中使用<code>def</code>关键字来定义函数，在函数名后面的圆括号中可以放置传递给函数的参数，函数执行完成后我们可以通过<code>return</code>关键字来返回一个值。</p>
<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span><span class="hljs-params">(num)</span>:</span>
    <span class="hljs-string">"""</span>
<span class="hljs-string">    求阶乘</span>
<span class="hljs-string">    </span>
<span class="hljs-string">    :param num: 非负整数</span>
<span class="hljs-string">    :return: num的阶乘</span>
<span class="hljs-string">    """</span>
    result = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>):
        result *= n
    <span class="hljs-keyword">return</span> result


m = int(input(<span class="hljs-string">'m = '</span>))
n = int(input(<span class="hljs-string">'n = '</span>))
<span class="hljs-comment"># 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span>
print(factorial(m) // factorial(n) // factorial(m - n))</code></pre>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>在Python中，函数的参数可以有默认值，也支持使用可变参数。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>, c=<span class="hljs-number">0</span>)</span>:</span>
    <span class="hljs-keyword">return</span> a + b + c
<span class="hljs-comment"># 传递参数时可以不按照设定的顺序进行传递，变量的设定与位置无关</span>
print(add(c=<span class="hljs-number">50</span>, a=<span class="hljs-number">100</span>, b=<span class="hljs-number">200</span>))</code></pre><br>对0个或多个参数进行加法运算<br><pre><code class="hljs Python"><span class="hljs-comment"># 在参数名前面的*表示args是一个可变参数</span>
<span class="hljs-comment"># 即在调用add函数时可以传入0个或多个参数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(*args)</span>:</span>
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> args:
        total += val
    <span class="hljs-keyword">return</span> total


print(add())
print(add(<span class="hljs-number">1</span>))
print(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
print(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
print(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>))</code></pre><br>可以把<code>args</code>理解为一个数组，<code>val</code>从数组中按顺序取值</p>
<h2 id="用模块管理函数、"><a href="#用模块管理函数、" class="headerlink" title="用模块管理函数、"></a>用模块管理函数、</h2><p>在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义。\<br>解决方法：\<br>Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块就可以区分到底要使用的是哪个模块中的函数，代码如下所示。</p>
<p>module1.py</p>
<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">'hello, world!'</span>)</code></pre>
<p>module2.py</p>
<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
    print(<span class="hljs-string">'goodbye, world!'</span>)</code></pre>
<p>test.py</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> module1 <span class="hljs-keyword">import</span> foo

<span class="hljs-comment"># 输出hello, world!</span>
foo()

<span class="hljs-keyword">from</span> module2 <span class="hljs-keyword">import</span> foo

<span class="hljs-comment"># 输出goodbye, world!</span>
foo()</code></pre>
<p>也可以按照如下所示的方式来区分到底要使用哪一个<code>foo</code>函数。</p>
<p>test.py</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> module1 <span class="hljs-keyword">as</span> m1
<span class="hljs-keyword">import</span> module2 <span class="hljs-keyword">as</span> m2

m1.foo()
m2.foo()</code></pre>
<p>但如果同时调用两个两次函数，后导入的函数还是会覆盖之前的函数，如：</p>
<p>test.py</p>
<pre><code class="hljs Python"><span class="hljs-keyword">from</span> module1 <span class="hljs-keyword">import</span> foo
<span class="hljs-keyword">from</span> module2 <span class="hljs-keyword">import</span> foo

<span class="hljs-comment"># 输出goodbye, world!</span>
foo()</code></pre>
<p>需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，（即<code>import XXX</code>后就会执行函数中的命令，而印象后续操作）因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中：</p>
<p>module3.py</p>
<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">pass</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">pass</span>


<span class="hljs-comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span>
<span class="hljs-comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    print(<span class="hljs-string">'call foo()'</span>)
    foo()
    print(<span class="hljs-string">'call bar()'</span>)
    bar()</code></pre>
<p>test.py</p>
<pre><code class="hljs Python"><span class="hljs-keyword">import</span> module3

<span class="hljs-comment"># 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</span></code></pre>
<p><strong>说明：</strong><code>pass</code>是空语句，是为了保持程序结构的完整性。不做任何事情，一般用做占位语句。</p>
<h1 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h1><h2 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h2><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    str1 = <span class="hljs-string">'hello, world!'</span>
    <span class="hljs-comment"># 通过len函数计算字符串的长度</span>
    print(len(str1))  <span class="hljs-comment"># 13</span>
    <span class="hljs-comment"># 获得字符串首字母大写的拷贝</span>
    print(str1.capitalize())  <span class="hljs-comment"># Hello, world!</span>
    <span class="hljs-comment"># 获得字符串变大写后的拷贝</span>
    print(str1.upper())  <span class="hljs-comment"># HELLO, WORLD!</span>
    <span class="hljs-comment"># 从字符串中查找子串所在位置</span>
    print(str1.find(<span class="hljs-string">'or'</span>))  <span class="hljs-comment"># 8</span>
    print(str1.find(<span class="hljs-string">'shit'</span>))  <span class="hljs-comment"># -1</span>
    <span class="hljs-comment"># 与find类似但找不到子串时会引发异常</span>
    <span class="hljs-comment"># print(str1.index('or'))</span>
    <span class="hljs-comment"># print(str1.index('shit'))</span>
    <span class="hljs-comment"># 检查字符串是否以指定的字符串开头</span>
    print(str1.startswith(<span class="hljs-string">'He'</span>))  <span class="hljs-comment"># False</span>
    print(str1.startswith(<span class="hljs-string">'hel'</span>))  <span class="hljs-comment"># True</span>
    <span class="hljs-comment"># 检查字符串是否以指定的字符串结尾</span>
    print(str1.endswith(<span class="hljs-string">'!'</span>))  <span class="hljs-comment"># True</span>
    <span class="hljs-comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span>
    print(str1.center(<span class="hljs-number">50</span>, <span class="hljs-string">'*'</span>))<span class="hljs-comment">#******************hello, world!*******************</span>
    <span class="hljs-comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span>
    print(str1.rjust(<span class="hljs-number">50</span>, <span class="hljs-string">' '</span>))<span class="hljs-comment">#                                     hello, world!</span>
    str2 = <span class="hljs-string">'abc123456'</span>
    <span class="hljs-comment"># 从字符串中取出指定位置的字符(下标运算)</span>
    print(str2[<span class="hljs-number">2</span>])  <span class="hljs-comment"># c</span>
    <span class="hljs-comment"># 字符串切片(从指定的开始索引到指定的结束索引)</span>
    print(str2[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])  <span class="hljs-comment"># c12</span>
    print(str2[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># c123456</span>
    print(str2[<span class="hljs-number">2</span>::<span class="hljs-number">2</span>])  <span class="hljs-comment"># c246</span>
    print(str2[::<span class="hljs-number">2</span>])  <span class="hljs-comment"># ac246</span>
    print(str2[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 654321cba</span>
    print(str2[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 45</span>
    <span class="hljs-comment"># 检查字符串是否由数字构成</span>
    print(str2.isdigit())  <span class="hljs-comment"># False</span>
    <span class="hljs-comment"># 检查字符串是否以字母构成</span>
    print(str2.isalpha())  <span class="hljs-comment"># False</span>
    <span class="hljs-comment"># 检查字符串是否以数字和字母构成</span>
    print(str2.isalnum())  <span class="hljs-comment"># True</span>
    str3 = <span class="hljs-string">'  jackfrued@126.com '</span>
    print(str3)
    <span class="hljs-comment"># 获得字符串修剪左右两侧空格的拷贝</span>
    print(str3.strip())


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre>
<h2 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h2><ul>
<li>定义列表、使用下标访问列表元素以及添加和删除元素的操作。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">100</span>]
    print(list1)<span class="hljs-comment">#[1, 3, 5, 7, 100]</span>
    list2 = [<span class="hljs-string">'hello'</span>] * <span class="hljs-number">5</span>
    print(list2)<span class="hljs-comment">#['hello', 'hello', 'hello', 'hello', 'hello']</span>
    <span class="hljs-comment"># 计算列表长度(元素个数)</span>
    print(len(list1))<span class="hljs-comment">#5</span>
    <span class="hljs-comment"># 下标(索引)运算</span>
    print(list1[<span class="hljs-number">0</span>])<span class="hljs-comment">#1</span>
    print(list1[<span class="hljs-number">4</span>])<span class="hljs-comment">#100</span>
    <span class="hljs-comment"># print(list1[5])  # IndexError: list index out of range</span>
    print(list1[<span class="hljs-number">-1</span>])<span class="hljs-comment">#100</span>
    print(list1[<span class="hljs-number">-3</span>])<span class="hljs-comment">#5</span>
    list1[<span class="hljs-number">2</span>] = <span class="hljs-number">300</span>
    print(list1)<span class="hljs-comment">#[1, 3, 300, 7, 100]</span>
    <span class="hljs-comment"># 添加元素</span>
    list1.append(<span class="hljs-number">200</span>)<span class="hljs-comment">#在列表后添加</span>
    list1.insert(<span class="hljs-number">1</span>, <span class="hljs-number">400</span>)<span class="hljs-comment">#在列表前添加</span>
    list1 += [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>]<span class="hljs-comment">#在后添加</span>
    print(list1)<span class="hljs-comment">#[1, 400, 3, 300, 7, 100, 200, 1000, 2000]</span>
    print(len(list1))<span class="hljs-comment">#9</span>
    <span class="hljs-comment"># 删除元素</span>
    list1.remove(<span class="hljs-number">3</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-number">1234</span> <span class="hljs-keyword">in</span> list1:
        list1.remove(<span class="hljs-number">1234</span>)
    <span class="hljs-keyword">del</span> list1[<span class="hljs-number">0</span>]
    print(list1)<span class="hljs-comment">#[400, 300, 7, 100, 200, 1000, 2000]</span>
    <span class="hljs-comment"># 清空列表元素</span>
    list1.clear()
    print(list1)<span class="hljs-comment">#[]</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre></li>
<li>列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    fruits = [<span class="hljs-string">'grape'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'strawberry'</span>, <span class="hljs-string">'waxberry'</span>]
    fruits += [<span class="hljs-string">'pitaya'</span>, <span class="hljs-string">'pear'</span>, <span class="hljs-string">'mango'</span>]
    <span class="hljs-comment"># 循环遍历列表元素</span>
    <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits:
        print(fruit.title(), end=<span class="hljs-string">' '</span>)<span class="hljs-comment">#title函数使所有字母开头大写</span>
    print()<span class="hljs-comment">#Grape Apple Strawberry Waxberry Pitaya Pear Mango </span>
    <span class="hljs-comment"># 列表切片</span>
    fruits2 = fruits[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]
    print(fruits2)
    <span class="hljs-comment"># fruit3 = fruits  # 没有复制列表只创建了新的引用</span>
    <span class="hljs-comment"># 可以通过完整切片操作来复制列表</span>
    fruits3 = fruits[:]
    print(fruits3)
    fruits4 = fruits[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>]
    print(fruits4)
    <span class="hljs-comment"># 可以通过反向切片操作来获得倒转后的列表的拷贝</span>
    fruits5 = fruits[::<span class="hljs-number">-1</span>]
    print(fruits5)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre></li>
</ul>
<ol>
<li>title函数使所有字母开头大写</li>
</ol>
<ul>
<li>列表的排序操作。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    list1 = [<span class="hljs-string">'orange'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'zoo'</span>, <span class="hljs-string">'internationalization'</span>, <span class="hljs-string">'blueberry'</span>]
    list2 = sorted(list1)
    <span class="hljs-comment"># sorted函数返回列表排序后的拷贝不会修改传入的列表</span>
    <span class="hljs-comment"># 函数的设计就应该像sorted函数一样尽可能不产生副作用</span>
    list3 = sorted(list1, reverse=<span class="hljs-literal">True</span>)
    <span class="hljs-comment"># 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span>
    list4 = sorted(list1, key=len)
    print(list1)<span class="hljs-comment">#['orange', 'apple', 'zoo'，'internationalization', 'blueberry']</span>
    print(list2)<span class="hljs-comment">#['apple', 'blueberry', 'internationalization', 'orange', 'zoo']</span>
    print(list3)<span class="hljs-comment">#['zoo', 'orange', 'internationalization', 'blueberry', 'apple']</span>
    print(list4)<span class="hljs-comment">#['zoo', 'apple', 'orange', 'blueberry', 'internationalization']</span>
    <span class="hljs-comment"># 给列表对象发出排序消息直接在列表对象上进行排序</span>
    list1.sort(reverse=<span class="hljs-literal">True</span>)
    print(list1)<span class="hljs-comment">#['zoo', 'orange', 'internationalization', 'blueberry', 'apple']</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre></li>
<li>使用列表的生成式语法来创建列表<pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    f = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]
    print(f)
    f = [x + y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-string">'ABCDE'</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-string">'1234567'</span>]
    print(f)
    <span class="hljs-comment"># 用列表的生成表达式语法创建列表容器</span>
    <span class="hljs-comment"># 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span>
    f = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)]
    print(sys.getsizeof(f))  <span class="hljs-comment"># 查看对象占用内存的字节数</span>
    print(f)
    <span class="hljs-comment"># 请注意下面的代码创建的不是一个列表而是一个生成器对象</span>
    <span class="hljs-comment"># 通过生成器可以获取到数据但它不占用额外的空间存储数据</span>
    <span class="hljs-comment"># 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span>
    f = (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>))
    print(sys.getsizeof(f))  <span class="hljs-comment"># 相比生成式生成器不占用存储数据的空间</span>
    print(f)
    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> f:
        print(val)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre></li>
<li>通过<code>yield</code>关键字将一个普通函数改造成生成器函数。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span>:</span>
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n):
        a, b = b, a + b
        <span class="hljs-keyword">yield</span> a


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> fib(<span class="hljs-number">20</span>):
        print(val)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre>
<h2 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h2>Python 的元组与列表类似，不同之处在于元组的元素不能修改</li>
</ul>
<p>定义和使用元组。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># 定义元组</span>
    t = (<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">'四川成都'</span>)
    print(t)
    <span class="hljs-comment"># 获取元组中的元素</span>
    print(t[<span class="hljs-number">0</span>])
    print(t[<span class="hljs-number">3</span>])
    <span class="hljs-comment"># 遍历元组中的值</span>
    <span class="hljs-keyword">for</span> member <span class="hljs-keyword">in</span> t:
        print(member)
    <span class="hljs-comment"># 重新给元组赋值</span>
    <span class="hljs-comment"># t[0] = '王大锤'  # TypeError</span>
    <span class="hljs-comment"># 变量t重新引用了新的元组原来的元组将被垃圾回收</span>
    t = (<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">'云南昆明'</span>)
    print(t)
    <span class="hljs-comment"># 将元组转换成列表</span>
    person = list(t)
    print(person)
    <span class="hljs-comment"># 列表是可以修改它的元素的</span>
    person[<span class="hljs-number">0</span>] = <span class="hljs-string">'李小龙'</span>
    person[<span class="hljs-number">1</span>] = <span class="hljs-number">25</span>
    print(person)
    <span class="hljs-comment"># 将列表转换成元组</span>
    fruits_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]
    fruits_tuple = tuple(fruits_list)
    print(fruits_tuple)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre><br>元组的优势：</p>
<ol>
<li>元组中的元素是无法修改的。</li>
<li>元组在创建时间和占用的空间上面都优于列表。<h2 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h2>Python中的集合不允许有重复元素，而且可以进行交集、并集、差集等运算。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    set1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;
    print(set1)<span class="hljs-comment">#&#123;1, 2, 3&#125;</span>
    print(<span class="hljs-string">'Length ='</span>, len(set1))<span class="hljs-comment">#Length = 3</span>
    set2 = set(range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))
    print(set2)<span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span>
    set1.add(<span class="hljs-number">4</span>)
    set1.add(<span class="hljs-number">5</span>)
    set2.update([<span class="hljs-number">11</span>, <span class="hljs-number">12</span>])
    print(set1)<span class="hljs-comment">#&#123;1, 2, 3, 4, 5&#125;</span>
    print(set2)<span class="hljs-comment">#&#123;1, 2, 3, 6, 7, 8, 9, 11, 12&#125;</span>
    set2.discard(<span class="hljs-number">5</span>)
    <span class="hljs-comment"># remove的元素如果不存在会引发KeyError</span>
    <span class="hljs-keyword">if</span> <span class="hljs-number">4</span> <span class="hljs-keyword">in</span> set2:
        set2.remove(<span class="hljs-number">4</span>)
    print(set2)
    <span class="hljs-comment"># 遍历集合容器</span>
    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> set2:
        print(elem ** <span class="hljs-number">2</span>, end=<span class="hljs-string">' '</span>)
    print()
    <span class="hljs-comment"># 将元组转换成集合</span>
    set3 = set((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>))
    print(set3.pop())
    print(set3)
    <span class="hljs-comment"># 集合的交集、并集、差集、对称差运算</span>
    print(set1 &amp; set2)
    <span class="hljs-comment"># print(set1.intersection(set2))</span>
    print(set1 | set2)
    <span class="hljs-comment"># print(set1.union(set2))</span>
    print(set1 - set2)
    <span class="hljs-comment"># print(set1.difference(set2))</span>
    print(set1 ^ set2)
    <span class="hljs-comment"># print(set1.symmetric_difference(set2))</span>
    <span class="hljs-comment"># 判断子集和超集</span>
    print(set2 &lt;= set1)
    <span class="hljs-comment"># print(set2.issubset(set1))</span>
    print(set3 &lt;= set1)
    <span class="hljs-comment"># print(set3.issubset(set1))</span>
    print(set1 &gt;= set2)
    <span class="hljs-comment"># print(set1.issuperset(set2))</span>
    print(set1 &gt;= set3)
    <span class="hljs-comment"># print(set1.issuperset(set3))</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre>
<h2 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h2>字典是另一种可变容器模型，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    scores = &#123;<span class="hljs-string">'骆昊'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'白元芳'</span>: <span class="hljs-number">78</span>, <span class="hljs-string">'狄仁杰'</span>: <span class="hljs-number">82</span>&#125;
    <span class="hljs-comment"># 通过键可以获取字典中对应的值</span>
    print(scores[<span class="hljs-string">'骆昊'</span>])
    print(scores[<span class="hljs-string">'狄仁杰'</span>])
    <span class="hljs-comment"># 对字典进行遍历(遍历的其实是键再通过键取对应的值)</span>
    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> scores:
        print(<span class="hljs-string">'%s\t---&gt;\t%d'</span> % (elem, scores[elem]))
    <span class="hljs-comment"># 更新字典中的元素</span>
    scores[<span class="hljs-string">'白元芳'</span>] = <span class="hljs-number">65</span>
    scores[<span class="hljs-string">'诸葛王朗'</span>] = <span class="hljs-number">71</span>
    scores.update(冷面=<span class="hljs-number">67</span>, 方启鹤=<span class="hljs-number">85</span>)
    print(scores)
    <span class="hljs-keyword">if</span> <span class="hljs-string">'武则天'</span> <span class="hljs-keyword">in</span> scores:
        print(scores[<span class="hljs-string">'武则天'</span>])
    print(scores.get(<span class="hljs-string">'武则天'</span>))
    <span class="hljs-comment"># get方法也是通过键获取对应的值但是可以设置默认值</span>
    print(scores.get(<span class="hljs-string">'武则天'</span>, <span class="hljs-number">60</span>))
    <span class="hljs-comment"># 删除字典中的元素</span>
    print(scores.popitem())
    print(scores.popitem())
    print(scores.pop(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">100</span>))
    <span class="hljs-comment"># 清空字典</span>
    scores.clear()
    print(scores)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre>
</li>
</ol>
<h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>在Python中可以使用<code>class</code>关键字定义类。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span>
    <span class="hljs-comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
        self.name = name
        self.age = age

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, course_name)</span>:</span>
        print(<span class="hljs-string">'%s正在学习%s.'</span> % (self.name, course_name))

    <span class="hljs-comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span>
    <span class="hljs-comment"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">watch_movie</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self.age &lt; <span class="hljs-number">18</span>:
            print(<span class="hljs-string">'%s只能观看《熊出没》.'</span> % self.name)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">'%s正在观看岛国爱情大电影.'</span> % self.name)</code></pre></p>
<blockquote>
<p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。\<br><code>self</code>不可少，且必须放在其他形参前面。</p>
<h2 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h2><p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># 创建学生对象并指定姓名和年龄</span>
    stu1 = Student(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>)
    <span class="hljs-comment"># 给对象发study消息</span>
    stu1.study(<span class="hljs-string">'Python程序设计'</span>)
    <span class="hljs-comment"># 给对象发watch_av消息</span>
    stu1.watch_movie()
    stu2 = Student(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">15</span>)
    stu2.study(<span class="hljs-string">'思想品德'</span>)
    stu2.watch_movie()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
    <span class="hljs-comment">#output:</span>
    <span class="hljs-comment">#骆昊正在学习Python程序设计.</span>
    <span class="hljs-comment">#骆昊正在观看岛国爱情大电影.</span>
    <span class="hljs-comment">#王大锤正在学习思想品德.</span>
    <span class="hljs-comment">#王大锤只能观看《熊出没》.</span></code></pre><br>方法前面的后缀为<code>self</code>的值</p>
<h2 id="访问可见性问题"><a href="#访问可见性问题" class="headerlink" title="访问可见性问题"></a>访问可见性问题</h2><p>在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, foo)</span>:</span>
        self.__foo = foo

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bar</span><span class="hljs-params">(self)</span>:</span>
        print(self.__foo)
        print(<span class="hljs-string">'__bar'</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    test = Test(<span class="hljs-string">'hello'</span>)
    <span class="hljs-comment"># AttributeError（报错）: 'Test' object has no attribute '__bar'</span>
    test.__bar()
    <span class="hljs-comment"># AttributeError: 'Test' object has no attribute '__foo'</span>
    print(test.__foo)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()</code></pre><br>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, foo)</span>:</span>
        self.__foo = foo

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bar</span><span class="hljs-params">(self)</span>:</span>
        print(self.__foo)
        print(<span class="hljs-string">'__bar'</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    test = Test(<span class="hljs-string">'hello'</span>)
    test._Test__bar()
    print(test._Test__foo)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()</code></pre></p>
</blockquote>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”</p>
<h2 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h2><p>如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
        self._name = name
        self._age = age

    <span class="hljs-comment"># 访问器 - getter方法</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._name

    <span class="hljs-comment"># 访问器 - getter方法</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._age

    <span class="hljs-comment"># 修改器 - setter方法</span>
<span class="hljs-meta">    @age.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>
        self._age = age

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._age &lt;= <span class="hljs-number">16</span>:
            print(<span class="hljs-string">'%s正在玩飞行棋.'</span> % self._name)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">'%s正在玩斗地主.'</span> % self._name)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    person = Person(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">12</span>)
    person.play()
    person.age = <span class="hljs-number">22</span>
    person.play()
    <span class="hljs-comment"># person.name = '白元芳'  # AttributeError: can't set attribute</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre></p>
<h2 id="slots魔法"><a href="#slots魔法" class="headerlink" title="slots魔法"></a><strong>slots</strong>魔法</h2><p>Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。\<br>但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p>
<p>?<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-comment"># 限定Person对象只能绑定_name, _age和_gender属性</span>
    __slots__ = (<span class="hljs-string">'_name'</span>, <span class="hljs-string">'_age'</span>, <span class="hljs-string">'_gender'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
        self._name = name
        self._age = age

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._name

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._age

<span class="hljs-meta">    @age.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>
        self._age = age

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._age &lt;= <span class="hljs-number">16</span>:
            print(<span class="hljs-string">'%s正在玩飞行棋.'</span> % self._name)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">'%s正在玩斗地主.'</span> % self._name)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    person = Person(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">22</span>)
    person.play()
    person._gender = <span class="hljs-string">'男'</span>
    <span class="hljs-comment"># AttributeError: 'Person' object has no attribute '_is_gay'</span>
    <span class="hljs-comment"># person._is_gay = True</span></code></pre></p>
<h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在<strong>类中的方法并不需要都是对象方法</strong>。<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, a, b, c)</span>:</span>
        self._a = a
        self._b = b
        self._c = c

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(a, b, c)</span>:</span>
        <span class="hljs-keyword">return</span> a + b &gt; c <span class="hljs-keyword">and</span> b + c &gt; a <span class="hljs-keyword">and</span> a + c &gt; b

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._a + self._b + self._c

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span><span class="hljs-params">(self)</span>:</span>
        half = self.perimeter() / <span class="hljs-number">2</span>
        <span class="hljs-keyword">return</span> sqrt(half * (half - self._a) *
                    (half - self._b) * (half - self._c))


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    a, b, c = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>
    <span class="hljs-comment"># 静态方法和类方法都是通过给类发消息来调用的</span>
    <span class="hljs-keyword">if</span> Triangle.is_valid(a, b, c):
        t = Triangle(a, b, c)
        print(t.perimeter())
        <span class="hljs-comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span>
        <span class="hljs-comment"># print(Triangle.perimeter(t))</span>
        print(t.area())
        <span class="hljs-comment"># print(Triangle.area(t))</span>
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">'无法构成三角形.'</span>)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre><br>Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象\<br>（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象。<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time, localtime, sleep


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""数字时钟"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hour=<span class="hljs-number">0</span>, minute=<span class="hljs-number">0</span>, second=<span class="hljs-number">0</span>)</span>:</span>
        self._hour = hour
        self._minute = minute
        self._second = second

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span><span class="hljs-params">(cls)</span>:</span>
        ctime = localtime(time())
        <span class="hljs-keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"""走字"""</span>
        self._second += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> self._second == <span class="hljs-number">60</span>:
            self._second = <span class="hljs-number">0</span>
            self._minute += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> self._minute == <span class="hljs-number">60</span>:
                self._minute = <span class="hljs-number">0</span>
                self._hour += <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> self._hour == <span class="hljs-number">24</span>:
                    self._hour = <span class="hljs-number">0</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"""显示时间"""</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'%02d:%02d:%02d'</span> % \
               (self._hour, self._minute, self._second)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># 通过类方法创建对象并获取系统时间</span>
    clock = Clock.now()
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        print(clock.show())
        sleep(<span class="hljs-number">1</span>)
        clock.run()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre></p>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>类和类之间的关系有三种：is-a、has-a和use-a关系。</p>
<ul>
<li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li>
<li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li>
<li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li>
</ul>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接<strong>继承</strong>下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。</p>
<pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">"""人"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
        self._name = name
        self._age = age

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._name

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._age

<span class="hljs-meta">    @age.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>
        self._age = age

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">'%s正在愉快的玩耍.'</span> % self._name)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">watch_av</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._age &gt;= <span class="hljs-number">18</span>:
            print(<span class="hljs-string">'%s正在观看爱情动作片.'</span> % self._name)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">'%s只能观看《熊出没》.'</span> % self._name)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(Person)</span>:</span>
    <span class="hljs-string">"""学生"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, grade)</span>:</span>
        super().__init__(name, age)
        self._grade = grade
    <span class="hljs-comment">#继承Person类</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._grade

<span class="hljs-meta">    @grade.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span><span class="hljs-params">(self, grade)</span>:</span>
        self._grade = grade

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, course)</span>:</span>
        print(<span class="hljs-string">'%s的%s正在学习%s.'</span> % (self._grade, self._name, course))


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(Person)</span>:</span>
    <span class="hljs-string">"""老师"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, title)</span>:</span>
        super().__init__(name, age)
        self._title = title

<span class="hljs-meta">    @property</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._title

<span class="hljs-meta">    @title.setter</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self, title)</span>:</span>
        self._title = title

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teach</span><span class="hljs-params">(self, course)</span>:</span>
        print(<span class="hljs-string">'%s%s正在讲%s.'</span> % (self._name, self._title, course))


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    stu = Student(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'初三'</span>)
    stu.study(<span class="hljs-string">'数学'</span>)
    stu.watch_av()
    t = Teacher(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>, <span class="hljs-string">'老叫兽'</span>)
    t.teach(<span class="hljs-string">'Python程序设计'</span>)
    t.watch_av()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre>
<p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法<strong>重写</strong>（override）。</p>
<p>通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是<strong>多态</strong>（poly-morphism）<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span><span class="hljs-params">(object, metaclass=ABCMeta)</span>:</span>
    <span class="hljs-string">"""宠物"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nickname)</span>:</span>
        self._nickname = nickname

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"""发出声音"""</span>
        <span class="hljs-keyword">pass</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><span class="hljs-params">(Pet)</span>:</span>
    <span class="hljs-string">"""狗"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">'%s: 汪汪汪...'</span> % self._nickname)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span><span class="hljs-params">(Pet)</span>:</span>
    <span class="hljs-string">"""猫"""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">'%s: 喵...喵...'</span> % self._nickname)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    pets = [Dog(<span class="hljs-string">'旺财'</span>), Cat(<span class="hljs-string">'凯蒂'</span>), Dog(<span class="hljs-string">'大黄'</span>)]
    <span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> pets:
        pet.make_voice()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()</code></pre><br>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/qrng/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zijun Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Web">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/23/qrng/" itemprop="url">QMNG</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-23T19:20:33+08:00">
                2020-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/physics-note/" itemprop="url" rel="index">
                    <span itemprop="name">physics note</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h1><p><strong>问题</strong></p>
<ul>
<li>随机性的来源？<br>随机性检验？or量子力学假设？认为QRNG为真随机数的依据（逻辑链）？</li>
</ul>
<h1 id="量子力学"><a href="#量子力学" class="headerlink" title="量子力学"></a>量子力学</h1><h2 id="EPR佯谬"><a href="#EPR佯谬" class="headerlink" title="EPR佯谬"></a>EPR佯谬</h2><p>考虑一个$\pi^0$介子到电子——正电子的衰变：</p>
<script type="math/tex; mode=display">\pi^0 \rightarrow e^- +e^+</script><p>由于$\pi^0$的自旋为0，由角动量守恒，要求电子与正电子对处在单态组态。</p>
<p>EPR实验的BOHM方案：一个静止$\pi^0$介子衰变为电子-正电子对。<br><strong><script type="math/tex">\frac{1}{\sqrt{2}}(\uparrow_-\downarrow+\uparrow_+\downarrow_-）</script></strong></p>
<p>如果电子的自旋向上，正电子的自旋必须向下，反之亦然。在任何一个特定的π 0 介子衰变中，量子力学无法预测会得到哪一种自旋组合，但是它明确指出电子、正电子自旋的测量是 相关的，平均说来得到每一种组合的几率是 1/2。</p>
<p>定域性：任何<strong>影响</strong>的传播速度都不能超过光速</p>
<p>结论：波函数的坍塌是瞬时的！</p>
<h2 id="Bell定理"><a href="#Bell定理" class="headerlink" title="Bell定理"></a>Bell定理</h2><p>推广实验：<br>Bell 让两个探测器都能独立的转动。第一个测量电子自旋沿一个单位矢量<strong>a</strong>的分量， 第二个测量正电子自旋沿另一个单位矢量<strong>b</strong>的分量。<br>简单起见，以$h/2$为单位记录自旋;则每个探测器沿指定方向记录+1(自旋向上)或-1(自旋向下)<br>测量结果<br><img src="/img/1.png" srcset="/img/loading.gif" alt=""></p>
<p><strong>计算自旋乘积的平均值</strong>$P(a,b)$（量子力学结论）<br>对任意的指向，由量子力学有</p>
<script type="math/tex; mode=display">P(a,b)=-a\cdot b</script><p>特别的：</p>
<ul>
<li>如果两个探测器方向是平行$(b=a)$<script type="math/tex; mode=display">P(a,a)=-1</script></li>
<li>如果安排探测器方向反平行$(b=-a)$<script type="math/tex; mode=display">P(a,-a)=1</script></li>
</ul>
<p><strong>Bell不等式</strong>（隐变量结论）</p>
<ul>
<li>假设电子，正电子体系的“完整”态是由隐变量 λ 表征的( λ<br>从一个衰变到下一个的变化是我们不知也不可控制的)。</li>
<li>假设电子测量的结果是独立于正电子探测器指向( b )的——这个指向可以在对电子马上要进行测量之前由试验者选择， 使得指向选择的信息无法在电子测量之前传到电子。(这就是<strong>定域性假设</strong>。)</li>
<li>设函数$A(a,\lambda)$给出电子测量结果，函数$B(b,\lambda)$给出正电子测量结果<br>$A(a,\lambda)=\pm1 $         $B(b,\lambda)=\pm1$<br>当探测器指向一致时，有完全（反）相关<script type="math/tex">A(a,\lambda)=-B(b,\lambda)</script>测量乘积的平均值为<script type="math/tex">P(a,b)=-\int\rho(\lambda) A(a,\lambda) B(b,\lambda) d \lambda</script>其中为隐变量的几率密度，有$\int \rho d\lambda=1$，不同的理论有不同的<br>消去B有<script type="math/tex">P(a,b)=-\int\rho(\lambda) A(a,\lambda) A(b,\lambda) d \lambda</script><br>对任意的单位矢量c，有<script type="math/tex">P(a,b)-P(a,c)=-\int \rho(\lambda)[A(a,\lambda)A(b,\lambda)-A(a,\lambda)A(c,\lambda)]d\lambda</script><script type="math/tex; mode=display">=-\int \rho(\lambda)[1-A(b,\lambda)A(c,\lambda)]A(a,\lambda)A(b,\lambda)d\lambda</script>(<em>$[A(b,\lambda)]^2 =1$</em>)<br>又因为$-1\leq [A(a,\lambda)B(b,\lambda)]\leq +1$，所以$\rho(\lambda)[1-A(b,\lambda)A(c,\lambda)]\ge 0 $</li>
</ul>
<script type="math/tex; mode=display">|P(a,b)-P(a,c)|\leq \int \rho (\lambda)[1-A(b,\lambda)A(c,\lambda)]d\lambda</script><p>即<strong><script type="math/tex">|P(a,b)-P(a,c)|\leq 1+P(b,c)</script></strong></p>
<p>可以计算出，Bell不等式与量子力学的结论矛盾。</p>
<hr>
<h1 id="量子随机数"><a href="#量子随机数" class="headerlink" title="量子随机数"></a>量子随机数</h1><h2 id="真随机数基础知识"><a href="#真随机数基础知识" class="headerlink" title="真随机数基础知识"></a>真随机数基础知识</h2><p>定义：<br>随机数是不存在<strong>周期性</strong>或明显的规律的非确定<strong>时序</strong>（时序特性），满足一定的统计规律（统计特性）<br>理想二进制随机序列的特性：</p>
<ul>
<li><strong>统计均匀性</strong>出现0和1的概率为均匀分布即<script type="math/tex">p(x_i)=\frac{1}{2}</script>其中$x_i =0,1$<br>扩展到N进制，则出现0，1，2，…，N-1的概率为均匀分布，即<script type="math/tex">p(x_i)=\frac{1}{N}</script></li>
<li><strong>相互无关性</strong>每一位信息与序列中其余的信息之间没有关联，使用<em>自相关系数</em>表示<script type="math/tex">a_k= \delta[k]</script>    $k\in(-\infty,+\infty)$     ,$k\in Z$（没有周期性）</li>
<li><strong>不可预测性</strong>无法以超过$p(x<em>i)=0.5$的精确度向前（后）预测产生的随机信息$P(x_i)=P(x_i|x</em>{i-m}x<em>{i-m+1}…x</em>{i-1})$,$P(x<em>i)=P(x_i|x</em>{i+m}x<em>{i+m-1}…x</em>{i+1})$</li>
<li><strong>不可重复性</strong>无法在有限的时间内产生完全相同的随机序列</li>
</ul>
<h2 id="真随机数发生器的设计"><a href="#真随机数发生器的设计" class="headerlink" title="真随机数发生器的设计"></a>真随机数发生器的设计</h2><h3 id="量子随机源"><a href="#量子随机源" class="headerlink" title="量子随机源"></a>量子随机源</h3><p> <strong>离散型随机源</strong>例子——单光子源。优点：简单，好实现<br>实际方案为：将激光进行衰减，使脉冲的平均光子数$\mu$降到单光子数量级（准单光子源）。</p>
<ul>
<li>空间分辨特性：单光子对路径选择的随机性</li>
<li>时间分辨特性：在相干时间内对单光子进行测量，响应时间具有随机性<br>将脉冲的相干态以Fock态$|n&gt;$展开<script type="math/tex; mode=display">|a>=e^{-|a|^2/2}\sum_{n=0}^{\infty}\frac{a^n}{n!}|n></script>相干态的光子数分布符合柏松分布：<script type="math/tex">p(n)=<n|a><a|n>=\frac{<n>^n e^{-<n>}}{n!}</script>其中$<n>=|a|^2$为平均光子数<br>当通过衰减器后平均光子数为$\lambda$探测器效率为$\eta$<script type="math/tex; mode=display">p(n)=\frac{<\eta \lambda>^n e^{-<\eta \lambda>}}{n!}</script>此时平均光子数为$\eta \lambda$，且通过衰减器之后仍未泊松分布。<br>故二阶相关系数为$g^{(2)}(0)=1$?各个脉冲之间无聚束（Bunchin）也无（Anti—Bunchi）？</li>
</ul>
<p><strong>连续性随机源</strong>例子——激光相位噪声，放大自发辐射噪声，真空散粒噪声。优点：数据多，快。<br>  统计指标——平均值，方差，平均强度<br>对随机信号$x(t)$</p>
<p>统计性质——</p>
<ul>
<li><strong>概率密度分布函数</strong><script type="math/tex; mode=display">p(x)=\lim_{\Delta x\to0}\frac{P(x(t)\in (x,x+\Delta x))}{\Delta x}</script>与时序无关，描述的是信号取值的分布</li>
<li><strong>功率谱密度函数</strong><script type="math/tex; mode=display">G(f)=\lim_{\Delta f\to 0}\frac{\Psi_x^2(f,f+\Delta f)}{\Delta f }</script>信号的功率谱密度函数与自相关系数互为Fourier变换关系（Wiener—Khintchine定理），用来描述噪声信号的相干性。<br> （补充）</li>
</ul>
<h3 id="探测与采样"><a href="#探测与采样" class="headerlink" title="探测与采样"></a>探测与采样</h3><h4 id="器件"><a href="#器件" class="headerlink" title="器件"></a>器件</h4><p>对离散型真随机数产生方案中，探测方式为单光子探测器。可以直接作为数字化的随机序列输出</p>
<p>对连续型真随机数，探测结果为连续的，如光电传感器。需要将连续型结果转化为离散型的二进制信息。<br>采集器分别有：</p>
<ul>
<li><strong>比较器</strong></li>
</ul>
<p><img src="/img/2.png" srcset="/img/loading.gif" alt=""><br>预先设置调谐的阈值电平$U_{th}(t)$，比较探测信号与阈值电平的大小输出二进制信息<br>优点：结构简单，可以达到GHz的带宽与GSa/s的采样频率（不快）<br>缺点：1.速度慢，每次只能输出1bit的信息。2.阈值电平设置问题，会产生非均匀分布，要使用von Neumann方法消除偏差，更慢！</p>
<ul>
<li><strong>模-数转化器</strong></li>
</ul>
<p><img src="/img/3.png" srcset="/img/loading.gif" alt=""><br>改良的比较器，有多个阈值和一个前置滤波器。输出的信号通过具有较大带宽$B_{pre}$的前置滤波器（为使探测模块的信号采样不失真），之后逐级与阈值比较，输出二进制信号。<br>模-数转化器最大允许的采样速率一般可以大于器件自身的采样速率——“过采样”，合理使用过采样可以提速。<br>优点：速度快，好应用</p>
<ul>
<li><strong>数字示波器</strong><br>多级模-数转化器<br>优点：一体化。缺点：功率体积太大</li>
</ul>
<h4 id="采样速率与采样精度的影响"><a href="#采样速率与采样精度的影响" class="headerlink" title="采样速率与采样精度的影响"></a>采样速率与采样精度的影响</h4><p>采样速率与采样精度会对随机数发生器的输出产生影响。<br>        原始序列产生速率=采样速率*采样精度<br>单位：采样速率为个数/秒（Sa/s），采样精度为比特（bit）</p>
<ul>
<li><strong>采样速率</strong><br>实际过程中，不是采样速率越大越好。<br>由于噪声功率谱密度函数与自相关函数互为傅立叶变化关系，其参数——噪声功率谱的线宽与信号的相干时间，二者互为倒数。<br><em>这意味着</em>：采样速率越大数据中的相关性也越大。同时采样速率过快也会使后处理中最小熵下降，使用m-LSB时要舍弃更多的数据。<br>选择采样速率的操作：通过采样后信号的熵估算，平衡采样速率与相关性。使后处理出来的数据在可靠的基础上最多</li>
<li><strong>采样精度</strong>采样精度由采集器决定<br>采样精度越高，就可以更精准的描述信号中的随机性，有效信息（每一个采样信号的信息量）也越大。模-数转化器有8、10、12bit的精度，一般为8bit。</li>
</ul>
<p><img src="/img/4.png" srcset="/img/loading.gif" alt=""></p>
<p>对一个高斯分布<script type="math/tex">p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-x^2/2\sigma^2}</script>，其信息熵只与方差有关<script type="math/tex">H(x)=-\int_{-\infty}^{\infty} p(x) log_2 p(x) dx=\frac{1}{2} log_2 2\pi e\sigma^2</script><br>采样精度提高后信号的分布函数方差更接近随机数方差。<br>当然，采样精度也不是越大越好。<br>在采样速率对于经典噪声与量子噪声都不是“过采样”时继续提高采样精度，量子与经典噪声都会等幅度的增加划分。因此，提高采样精度并不可以提高最终序列的产生速率，反而增加了后处理的难度。</p>
<h3 id="算法后处理"><a href="#算法后处理" class="headerlink" title="算法后处理"></a>算法后处理</h3><p>目的：提高采样速率</p>
<ol>
<li><strong>von Neumann方法</strong><br>重新定义联合事件：</li>
</ol>
<ul>
<li>连续两个bit位出现10的组合，称为新bit<strong>1</strong></li>
<li>连续两个bit位出现01的组合，称为新bit<strong>0</strong></li>
<li>其他全部舍弃（00，11）<br>作用：无论原始数据有何偏差，都可以使处理后的序列统计分布均匀$P(01)=P(10)$<br>缺点：产生速率损失大，速率也不稳定。输出序列和输入序列的长度比为$(1/4-e(n)^2)$，$e(n)^2$为原始数据的bias。</li>
</ul>
<ol>
<li><strong>逻辑异或（Exclusive OR）操作</strong><br>任意两个bit位$A_J$，$A_i$可以视为独立同分布，通过异或操作$B=A_i \oplus A_j$得到概率分布为<script type="math/tex; mode=display">P(B)=P(A_i\oplus A_j)=P(|A_i - A_j|)=P(A_i)P(A_j)</script>由于$A_J$，$A_i$分布相同，则可以将任意分布转化为对阵分布<br><img src="/img/5.png" srcset="/img/loading.gif" alt=""><br>异或操作：1.每个比特与后续数据进行异或操作，且每个bit只用一次<br> 2.每个比特与后续数据进行异或操作</li>
</ol>
<p><img src="/img/6.png" srcset="/img/loading.gif" alt=""></p>
<p>作用：1.改善统计分布，减小数据采集时引入的经典bias。<br>    2.具有较高的输入/输出比（1or1/2）<br><img src="/img/7.png" srcset="/img/loading.gif" alt=""><br>缺点：引入了一定的相关性与经典信息</p>
<ol>
<li><strong>最低有效位（m—LSB）操作</strong><br>保留每一次采样信号的m比特最低有效位。<br><img src="/img/8.png" srcset="/img/loading.gif" alt=""></li>
</ol>
<h3 id="随机性检验"><a href="#随机性检验" class="headerlink" title="随机性检验"></a>随机性检验</h3><ul>
<li><strong>算数平均值</strong>由均匀性，算数平均值为1/2。<script type="math/tex; mode=display">e(n)=\bar{X}-\frac{1}{2}</script>$e(n)$为偏置</li>
<li><strong>k阶自相关系数</strong>，是带检验序列$X_0$与自身位移后得到的序列$X_k$之间相关性的度量<script type="math/tex; mode=display">a_k=\frac{E[(x_i -\mu)(x_{i+k}-\mu)]}{\sigma^2}=\frac{\sum_i (x_i -\mu)(x_{(i+k)  modn}-\mu)}{\sum_i (x_i -\mu)^2}</script>式中n为序列长度，$\mu$ $\sigma$分别为序列的平均值与标准差。<br>对于理想随机数，$a_0=1$，$a_k=0$当$k\ne 0$时</li>
<li><strong>信息熵</strong>（Shannon熵）考察n比特长度作为基本单元子序列的概率密度分布<script type="math/tex; mode=display">H_n(X)=-\sum_{i=1}^{k^n} p_i log_k p_i</script>其中：k为进制，n为基本单位长度，$p_i$为子序列在总长度为N比特中出现的概率。规定$p_i=0$时$p_i log_k p_i=0$<br>信息熵是对序列概率的加权平均描述可以在一定程度上表示比特之间的统计分布和相关性的大小<br>对于理想二进制均匀分布，$p_i =1/N$其中$(i=0,1,2,…,2^n-1)$则此时信息熵最大值$H_n(X)=n$。<em>物理意义：</em>所有信息都有价值，有最大的非确定性4</li>
<li><strong>最小熵</strong><script type="math/tex">H_{n-min}=-log_k (max[p_i])</script><br>最小熵刻画了随机序列不确定的最小下限。m-LSB后处理使用最小熵确定m的值</li>
</ul>
<h4 id="输出序列的实际检验"><a href="#输出序列的实际检验" class="headerlink" title="输出序列的实际检验"></a>输出序列的实际检验</h4><ul>
<li><strong>标准检验包</strong><br>一套公认的的检验体系，基本思路：将一个带检测的输出序列划分为多个固定长度的子序列，根据置信水平（$\alpha=0.01$）给出待检序列通过检测的概率<br>1.DIEHARD统计检验包。<br>有18种子检测<br><img src="/img/9.png" srcset="/img/loading.gif" alt=""><br>所有检测共需要80M的待检测数据，每一个检测会给出一个p值，当$p&gt;\alpha$则通过检测。<br>对于6—11子检测，只能给出划分后子序列的p值，通过K-S Test转化为一个p值。<br>2.NIST-STS统计检验包。<br>有15个子检测<br><img src="/img/10.png" srcset="/img/loading.gif" alt=""><br>通过所有子检测需要有1G的比特长度，若不足检测会继续进行。<br>NIST-STS会给出两个值<br>p-值：同上，一般的判决阈值为$\alpha=0.0001$。<br>序列通过子检验的成功比例：假定划分的子序列数量为n，置信水平为$\alpha$<br>子序列通过单项检验的成功率取值在一个高斯分布中，其区间为<script type="math/tex">[1-\alpha-3\sqrt{\frac{\alpha (1-\alpha )}{n}},1-\alpha+3\sqrt{\frac{\alpha (1-\alpha )}{n}}]</script>当比例落入区间时，视为通过检测包。一般预设值为（n=1000，$\alpha=0.01$）区间为[0.9805，0.9995]</li>
<li><strong>三倍标准差（$3\sigma$）检测</strong></li>
</ul>
<p>指标：偏置$e(n)$，$k$阶自相关系数 $\alpha_k(n)$。</p>
<p>基本思想：由理想抛硬币模型所模拟的二进制随机序列的统计参数在一定置信水平下与数据长度相关。<br>1.偏置$e(n)$的$3\sigma$检验标准<br>理想抛硬币模型为均匀分布$P(1)=P(0)=1/2$<br>n次抛硬币出现m次正面的组合数为<script type="math/tex">N_n(m)=C_n^m</script><br>为伯努力分布，对其归一化<br>可以求出该分布的期望$E(x)=\frac{1}{2}$方差$D(x)=\frac{1}{4n}$<br>由中心极限定理，当$n\rightarrow \infty$时，p（x）趋于高斯分布<script type="math/tex">E(X),\sigma (x))=N(\frac{1}{2},\frac{1}{2\sqrt{n}})</script><br>同时偏置$p[e(x)]$也符合高斯分布</p>
<script type="math/tex; mode=display">p[e(n)]=N(e(X),\sigma (x))=N(0,\frac{1}{2\sqrt{n}})=\frac{1}{\sqrt{2\pi}\sigma_e}exp(-x^2/2\sigma_e^2)</script><p>在高斯分布中位于$[-3\sigma,+3\sigma]$区间的概率为99.7%，也就是偏置有99.7%落入$[-\frac{3}{2\sqrt{n}},+\frac{3}{2\sqrt{n}}]$。<br>对于落入区域以外的待检测序列，极大可能不满足随机序列的统计特征。<br>描述：<br>长度为n的随机序列，偏置$e(n)$满足：$|e(n)|&gt; \frac{3}{2\sqrt{n}}$，且序列仍为真随机序列的概率只有0.3%<br>2.自相关系数$\alpha_k(n)$的$3\sigma$检验标准<br>改写自相关的定义：</p>
<script type="math/tex; mode=display">a_1(n)\approx \frac{\sum_{i=1}^n y_i |_{y_i = [(1/2+e)^2,(1/2-e)^2,(-1/4+e^2)]}}{n(1/4+e^2)}\approx \frac{\sum_{i=1}^n y_i |_{y_i=[+1,-1]}}{n}</script><p><em>简化规则：</em><br> $x<em>i$ 为而进制，则 $x_i=0,1$<br>令 $y_1 =[x_i -E(x)][x</em>{(i+1)mod n}-E(x)]$ ，由 x_i$ 的取值 $y_i$ 只有三种取法 $y_i=(1/2+e)^2,(1/2-e)^2,(-1/4+e^2)$<br>当 $n-&gt;\infty$ 时，此时$e(n)$很小，故$y_i$中$e^2$项可以忽略<br>由数据之间的独立性，$y_i$中$-2e,+2e$项个数可以相互抵消<br>则一阶自相关系数满足高斯分布</p>
<script type="math/tex; mode=display">p[a_1 (n)]=N(0,\sigma_a)=\frac{1}{\sqrt{2 \pi}\sigma_a} exp(-x^2/2\sigma_a^2)</script><p>由于偏置$e(n)$中$y_i$取值为$\pm 1/2$，而一阶自相关系数中 $y_i$ 取值为 $\pm 1$ ，则</p>
<script type="math/tex; mode=display">\sigma_a=2\sigma_e=\frac{1}{\sqrt{n}}</script><p><em>描述</em>：<br>长度为n的随机序列，一阶自相关系数满足$|a_1(n)|&gt;\frac{3}{\sqrt{n}}$，且仍为真随机序列的概率只有0.3%<br>此方法可以推广到k阶</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zijun Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Web">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/23/1/" itemprop="url">Berry Phase</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-23T19:20:33+08:00">
                2020-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/physics-note/" itemprop="url" rel="index">
                    <span itemprop="name">physics note</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry-Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’"><a href="#我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry-Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’" class="headerlink" title="   我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’!"></a>   <strong>我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’!</strong></h2><h1 id="不含时哈密顿量"><a href="#不含时哈密顿量" class="headerlink" title="不含时哈密顿量"></a>不含时哈密顿量</h1><p>由Schrodinger equation</p>
<script type="math/tex; mode=display">i \, \hbar \frac{\partial}{\partial t} | \psi\rangle= H(t) |\psi\rangle</script><p>其边界条件为</p>
<script type="math/tex; mode=display">|\psi_{(t=0)}\rangle=|\psi_{（0）}\rangle</script><p>当哈密顿量不含时时，$H(t)=H$ （其中H可为多体的哈密顿量）</p>
<script type="math/tex; mode=display">H|n\rangle=E_n |n\rangle</script><p>$\langle m | n \rangle = \delta_{mn}$  </p>
<p>其中$\left| n\right\rangle$为Schrodinger方程的解系，满足正交归一性$\langle m | n \rangle = \delta_{mn}$</p>
<p>这也意味着$|n&gt;$为完备集，即$\left| \psi(t)\right\rangle=\sum_{n} c_n (t)|n\rangle$。  </p>
<p>其中$c_{n}(t)=\langle n | \psi(t)\rangle$。同时有</p>
<script type="math/tex; mode=display">\left| \psi(t)\right\rangle=\sum_{n} \langle n | \psi(t)\rangle|n\rangle=\sum_{n} |n \rangle \langle n| \psi(t)\rangle</script><p>即 $\sum_{n}|n \rangle \langle n|=1$  </p>
<p>由上则$|\psi(t=0)\rangle=\sum_{n} c_n (t=0)|n\rangle$</p>
<p>$c_{n}(t=0)=\langle n|\psi(0)\rangle$</p>
<p>带入Schrodinger方程中</p>
<script type="math/tex; mode=display">i \, \hbar \frac{\partial}{\partial t} \sum_{n} c_n(t) | n \rangle= H \sum_{n} c_{n}(t)|n\rangle=\sum_{n} c_{n}(t) E_{n}|n\rangle</script><p>两边同时作用$| n \rangle$</p>
<script type="math/tex; mode=display">i\, \hbar \frac{\partial}{\partial t} \sum_{n} c_n(t)\langle m|n\rangle= \sum_n c_{n}(t) E_{n}\langle m | n\rangle</script><p>带入正交归一化条件</p>
<script type="math/tex; mode=display">i \,\hbar \frac{\partial}{\partial t} c_{m}(t)=E_{m} C_{m}(t)</script><p>通过积分解方程为</p>
<script type="math/tex; mode=display">i\, \hbar\left[\ln C_{n}(t)-\ln C_{n}(t=0)\right]=E_{n} t</script><p>解为$c<em>{m}(t)=c</em>{m}(t=0) e^{-i E_{m} t / \hbar}$</p>
<p>若把$c_{m}(t=0)$记为$c_n$，则</p>
<script type="math/tex; mode=display">|\psi(t)\rangle=\sum_{n} C_{n} e^{-i E t / \, \hbar}|n\rangle</script><p>其中 $e^{-i E t / \, \hbar}$ 为时间演化因子</p>
<p>特别的，若设 $c<em>{n}=\delta</em>{n m}$ 为初始条件，则</p>
<script type="math/tex; mode=display">| \psi \rangle=\sum_{n} \delta_{n m} e^{-i E_{n} t /  \, \hbar}|n\rangle=e^{-i E_{n} t / \, \hbar} | m\rangle</script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zijun Wei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/%E5%BD%92%E6%A1%A3">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zijun Wei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
