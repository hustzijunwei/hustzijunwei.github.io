<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Quantum Optics -- Quantization of electromagnetic fields</title>
    <link href="/2020/05/30/Quantumoptics/"/>
    <url>/2020/05/30/Quantumoptics/</url>
    
    <content type="html"><![CDATA[<h1 id="遇事不决，量子力学！"><a href="#遇事不决，量子力学！" class="headerlink" title="遇事不决，量子力学！"></a>遇事不决，量子力学！</h1><p>通过电动力学中我们可以列出自由电磁场中的Maxwell方程</p><script type="math/tex; mode=display">\begin{aligned} \nabla \cdot {B} &=0 \\ \nabla \times {E} &=-\frac{\partial {B}}{\partial t} \\\nabla \cdot {D} &=0 \\ \nabla \times {H} &=\frac{\partial{D}}{\partial t} \end{aligned}</script><p>其中E和B都可以使用矢势 $A(\boldsymbol{r}, t)$ 表示：$\begin{aligned} &amp;\boldsymbol{B}=\nabla \times \boldsymbol{A}\ &amp;\boldsymbol{E}=-\frac{\partial \boldsymbol{A}}{\partial t} \end{aligned}$<br>   我们在这里取库伦规范 $\nabla \cdot \boldsymbol{A}=0$</p><p>正如我们在电动力学中做过无数遍的化简：上述Maxwell方程组可以化简为关于 $A(\boldsymbol{r}, t)$的波动方程：</p><script type="math/tex; mode=display">\nabla^{2} \boldsymbol{A}(\boldsymbol{r}, t)=\frac{1}{c^{2}} \frac{\partial^{2} \boldsymbol{A}(\boldsymbol{r}, t)}{\partial t^{2}}</script><p>而这个方程具有行波解的形式 </p><script type="math/tex; mode=display">\boldsymbol{A}(\boldsymbol{r}, t)=\boldsymbol{A}^{(+)}(\boldsymbol{r}, t)+\boldsymbol{A}^{(-)}(\boldsymbol{r}, t)</script><p>其中 ${A}^{(-)}=\left({A}^{(+)}\right)^* $互为复共轭</p><p>接下来我们可使用一组正交基对 $A^{(+)}(r, t)$ 经行展开 </p><script type="math/tex; mode=display">{A}^{(+)}({r}, t)=\sum_{k} c_{k} {u}_{k}({r}) {e}^{-i \omega_{k} t}</script><p>其中正交基为 $u_k (r)$ 满足：</p><ul><li>方程： <script type="math/tex; mode=display">\left(\nabla^{2}+\frac{\omega_{k}^{2}}{c^{2}}\right) {u}_{k}({r})=0</script></li><li>规范：<script type="math/tex; mode=display">\nabla \cdot {u}_{k}({r})=0</script></li><li>正交归一性：<script type="math/tex; mode=display">\int_{V} {u}_{k}^{*}({r}) {u}_{k^{\prime}}({r}) {d} {r}=\delta_{k k^{\prime}}</script></li></ul><p>由上述几个条件可以解出基的值（这同我们在解波导问题很相近）</p><script type="math/tex; mode=display">{u}_{k}(\boldsymbol{r})=L^{-3 / 2} \hat{\boldsymbol{e}}^{(\lambda)} \exp (\boldsymbol{i} \boldsymbol{k} \cdot \boldsymbol{r})</script><p>其中 $\hat{e}^{(\lambda)}$表偏振方向的选择。之后讨论同波导中解法，有：</p><script type="math/tex; mode=display">k_{x}=\frac{2 \pi n_{x}}{L}, \quad k_{y}=\frac{2 \pi n_{y}}{L}, \quad k_{z}=\frac{2 \pi n_{z}}{L}, \quad n_{x}, n_{y}, n_{z}=0, \pm 1, \pm 2, \ldots</script><p>可以观察到$u_k (r)$满足的方程与量子力学中谐振子满足的方程是相似的，这也亦为之我们可以使用谐振子的代数解法来解决$u_k (r)$的问题。经过计算可得：</p><script type="math/tex; mode=display">\boldsymbol{A}(\boldsymbol{r}, t)=\sum_{k}\left(\frac{\hbar}{2 \omega_{k} \epsilon_{0}} \cdot\right)^{1 / 2}\left[a_{k} \boldsymbol{u}_{k}(\boldsymbol{r}) {e}^{-i \omega_{k} t}+a_{k}^{\dagger} \boldsymbol{u}_{k}^{*}(\boldsymbol{r}) {e}^{i \omega_{k} t}\right]</script><p>则，与之对应的电场为：</p><script type="math/tex; mode=display">\boldsymbol{E}(\boldsymbol{r}, t)=i \sum_{k}\left(\frac{\hbar \omega_{k}}{2 \epsilon_{0}}\right)^{1 / 2}\left[a_{k} \boldsymbol{u}_{k}(\boldsymbol{r}){e}^{-i \omega_{k} t}-a_{k}^{\dagger} \boldsymbol{u}_{k}^{*}(\boldsymbol{r}) {e}^{i \omega_{k} t}\right]</script><p>这里的 $a_{k}^{\dagger}$ 与$a_k$ 即为光场中的升降阶算符，其中$k$为标记不同光场的脚标。满足对易关系：</p><script type="math/tex; mode=display">\left[a_{k}, a_{k^{\prime}}\right]=\left[a_{k}^{\dagger}, a_{k^{\prime}}^{\dagger}\right]=0, \quad\left[a_{k}, a_{k^{\prime}}^{\dagger}\right]=\delta_{k k^{\prime}}</script><p>在电磁学中电磁场的Hamiltonian为 $H=\frac{1}{2} \int\left(\epsilon_0 {E}^2+\mu_0 {H}^2 \right) {d} {r}$<br>带入计算得到的E有（这里两算符相乘要注意满足的对易关系）</p><script type="math/tex; mode=display">H=\sum_{k} \hbar \omega_{k}\left(a_{k}^{\dagger} a_{k}+\frac{1}{2}\right)</script><p>这里就可以得到量子化的电磁场。<br>remark：因为 $N=a_{k}^{\dagger}a_k$ 代表的是光子数所以可以发现在$n=0$（即真空态）时也会有 $\frac{1}{2} \hbar \omega_k$ 的能量。<br>这就可以有很多新奇的现象，比如<a href="https://zhuanlan.zhihu.com/p/32439577" target="_blank" rel="noopener">蔡老师的一篇文章</a>。挖坑：有时间我也试着去调研，并使用matlab复现一下论文中的一些结论。</p><h1 id="Fock态或粒子数态（fock老是拼错为fork，英语渣渣）"><a href="#Fock态或粒子数态（fock老是拼错为fork，英语渣渣）" class="headerlink" title="Fock态或粒子数态（fock老是拼错为fork，英语渣渣）"></a>Fock态或粒子数态（fock老是拼错为fork，英语渣渣）</h1><p>这就是一般最常见的表示的态，由于Hamiltonian具有 $h \omega_k (n_k +\frac{1}{2})$ 的本征值，其中$n_k$自然数。则一种自然的想法就是用 $|n_k \rangle$ 来表示H的本征态。</p><p>我们就称这个态为Fock态或者是粒子数态。其中$N=a_{k}^{\dagger} a_k$为粒子数算符</p><script type="math/tex; mode=display">a_{k}^{\dagger} a_{k}\left|n_{k}\right\rangle= n_{k}\left|n_{k}\right\rangle</script><p>将$a_{k}^{\dagger} $与$a_k$作用到$\left|n_k\right\rangle$上有</p><script type="math/tex; mode=display">a_{k}\left|n_{k}\right\rangle= n_{k}^{1 / 2}\left|n_{k}-1\right\rangle, \quad a_{k}^{\dagger}\left|n_{k}\right\rangle=\left(n_{k}+1\right)^{1 / 2}\left|n_{k}+1\right\rangle</script><p>特别的对于基态 $a_k |0\rangle= 0$ ，这也很好的反应出为什么叫升降阶算符。对任意一个态$|n_k \rangle$有</p><script type="math/tex; mode=display">\left|n_{k}\right\rangle=\frac{\left(a_{k}^{\dagger}\right)^{n_{k}}}{\left(n_{k} !\right)^{1 / 2}}|0\rangle, \quad n_{k}=0,1,2\ldots</script><p>这很明显可以得到：</p><ul><li>正交归一性： <script type="math/tex; mode=display">\left\langle n_{k} | m_{k}\right\rangle=\delta_{m n}</script></li><li>完备性：   <script type="math/tex; mode=display">\sum_{n_{k}=0}^{\infty}\left|n_{k}\right\rangle\left\langle n_{k}\right|=1</script>remark：fock态是最常见的一种表示方法，同时也是最直观的。往后的一些描述最好可以有直观的描述，这有助于理解。</li></ul><h1 id="相干态"><a href="#相干态" class="headerlink" title="相干态"></a>相干态</h1><p>对于相干光其光子数是不确定的，但是其满足不确定性原理的下限。为了描述这种相干光，我们需要引入相干态，而只需要简单的对 $\left|n_{k}\right\rangle$ 作幺正变化即可。</p><p>$D(\alpha)=\exp \left(\alpha a^{\dagger}-\alpha^{*} a\right)$ 其中 $\alpha$为任意的一个复数。<br>引理1：<br>   当 $[A,[A, B]]=[B,[A, B]]=0$ 时有 $\mathrm{e}^{A+B}=\mathrm{e}^{A} \mathrm{e}^{B} \mathrm{e}^{-[A, B] / 2}$ </p><p>化简得到 $D(\alpha)=\mathrm{e}^{-|\alpha|^{2} / 2} \mathrm{e}^{\alpha a^{\dagger}} \mathrm{e}^{-\alpha^{*} a}$ ，进而研究 $D(\alpha)$ 的性质：</p><ul><li><script type="math/tex; mode=display">D^{\dagger}(\alpha)=D^{-1}(\alpha)=D(-\alpha)</script></li><li><script type="math/tex; mode=display">D^{\dagger}(\alpha) a D(\alpha)=a+\alpha</script></li><li><script type="math/tex; mode=display">D^{\dagger}(\alpha) a^{\dagger} D(\alpha)=a^{\dagger}+\alpha^{*}</script></li><li><script type="math/tex; mode=display">D(\alpha+\beta)=D(\alpha) D(\beta) \exp \left(-\mathrm{i} \operatorname{Im}\left\{\alpha \beta^{*}\right\}\right)</script></li></ul><p>故，相干态 $|\alpha\rangle |\alpha\rangle$ 可由$D(\alpha)$作用在基态上产生： $|\alpha\rangle= D(\alpha)|0\rangle $，z<br>同时可得$|\alpha\rangle$为算符$a$的本征态， $a|\alpha\rangle=\alpha|\alpha\rangle$。</p><p>证明过程： $D^{\dagger}(\alpha) a|\alpha\rangle= D^{\dagger}(\alpha) a D(\alpha)|0\rangle=(a+\alpha)|0\rangle=\alpha|0\rangle$ ，之后俩边在同时乘 $D(\alpha)$。这里因为$a$为非厄米算符，所以$\alpha$ 为复数。<br>在 $a|\alpha\rangle=\alpha|\alpha\rangle$ 两边同时乘上 $\langle n|$ 有 $(n+1)^{1 / 2}\langle n+1 | \alpha\rangle=\alpha\langle n | \alpha\rangle $<br>即 </p><script type="math/tex; mode=display">\langle n | \alpha\rangle=\frac{\alpha^{n}}{(n !)^{1 / 2}}\langle 0 | \alpha\rangle</script><p>所以$|\alpha\rangle$可以表示为 $|\alpha\rangle=\sum|n\rangle\langle n | \alpha\rangle=\langle 0 | \alpha\rangle \sum_{n} \frac{\alpha^{n}}{(n !)^{1 / 2}}|n\rangle$<br>又因为通过计算有： </p><script type="math/tex; mode=display">\langle 0 | \alpha\rangle= e^{-|\alpha|^{2} / 2}</script><p>则</p><script type="math/tex; mode=display">|\alpha\rangle=\mathrm{e}^{-|\alpha|^{2} / 2} \sum \frac{\alpha^{n}}{(n !)^{1 / 2}}|n\rangle</script><p>光子数分布为： </p><script type="math/tex; mode=display">P(n)=|\langle n | \alpha\rangle|^{2}=\frac{|\alpha|^{2 n} \mathrm{e}^{-|\alpha|^{2}}}{n !}</script><p>其中平均光子数为 </p><script type="math/tex; mode=display">\bar{n}=\left\langle\alpha\left|a^{\dagger} a\right| \alpha\right\rangle=|\alpha|^{2}</script><ul><li>对于两个相干态来说有： <script type="math/tex; mode=display">\langle\beta | \alpha\rangle=\left\langle 0\left|D^{\dagger}(\beta) D(\alpha)\right| 0\right\rangle =\exp \left[-\frac{1}{2}\left(|\alpha|^{2}+|\beta|^{2}\right)+\alpha \beta^{*}\right]</script> 则 $|\langle\beta | \alpha\rangle|^{2}=\mathrm{e}^{-|\alpha-\beta|^{2}}$ 当 $|\alpha-\beta| \gg 1$ 时两个相干态 $|\alpha\rangle$ 与 $|\beta\rangle$ 相互正交</li><li>同时态$|\alpha\rangle$也存在完备性： $\frac{1}{\pi} \int|\alpha\rangle\langle\alpha| \mathrm{d}^{2} \alpha=1$</li></ul><h1 id="Squeezed-States（压缩态？）"><a href="#Squeezed-States（压缩态？）" class="headerlink" title="Squeezed States（压缩态？）"></a>Squeezed States（压缩态？）</h1><p>Squeezed States是更满足最小不确定性原理的更广义的态，相干态为其中是一种特殊的形式。</p><p>若我们令 </p><script type="math/tex; mode=display">a=\frac{X_{1}+\mathrm{i} X_{2}}{2}</script><p>由$a_{k}^{\dagger}$与$a_k$的对易关系我们可以得到： </p><script type="math/tex; mode=display">\left[X_{1}, X_{2}\right]=2 \mathrm{i}</script><p>且X1、X2满足不确定关系 $\Delta X_1 \Delta X_2 \geq 1$ ，特别的当 $\Delta X_1=\Delta X_2=1$ 时即为相干态。<br><img src="/img_QO/1.png" srcset="/img/loading.gif" alt="势能如图"><br>(a)相干态(b)Squeezed State<br>如图，当$\Delta X_1=\Delta X_2=1$为相干态；相干态$|\alpha\rangle$振幅的平均值为为$\alpha$对应图中的圆心，圆代表误差范围；当X1、X2任意时就是Squeezed state$|\alpha, \epsilon\rangle$ </p><p>同在相干态中的操作，Squeezed state也可以由幺正变化作用在相干态上来生成。 $|\alpha, \epsilon\rangle= D(\alpha) S(\epsilon)|0\rangle$</p><p>其中， $S(\epsilon)=\exp \left(1 / 2 \epsilon^{*} a^{2}-1 / 2 \epsilon a^{\dagger 2}\right)$ 。 $\epsilon$ 为Squeezed state对应的下标$\epsilon=r \mathrm{e}^{2 \mathrm{i} \phi}$</p><p>$S(\varepsilon)$满足的一些性质：</p><ul><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon)=S^{-1}(\varepsilon)=S(-\varepsilon)</script></li><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon) a S(\varepsilon)=a \cosh r-a^{\dagger} \mathrm{e}^{-2 \mathrm{i} \phi} \sinh r</script></li><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon) a^{\dagger} S(\varepsilon)=a^{\dagger} \cosh r-a \mathrm{e}^{-2 \mathrm{i} \phi} \sinh r</script></li><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon)\left(Y_{1}+\mathrm{i} Y_{2}\right) S(\varepsilon)=Y_{1} \mathrm{e}^{-r}+\mathrm{i} Y_{2} \mathrm{e}^{r}</script>其中 <script type="math/tex; mode=display">Y_{1}+\mathrm{i} Y_{2}=\left(X_{1}+\mathrm{i} X_{2}\right) \mathrm{e}^{-\mathrm{i} \phi}</script></li></ul><p>则Squeezed States对应不同的满足 $\Delta X<em>{1} \Delta X</em>{2} \ge 1$ 的 $\Delta X<em>{1}$、$\Delta X</em>{2}$ ，且某一个小于相干态。<br><img src="/img_QO/2.png" srcset="/img/loading.gif" alt="势能如图"><br>黑色点处代表相干态，阴影部分代表Squeezed state<br>一般压缩态$|\alpha, \varepsilon\rangle$中$r=|\boldsymbol{\varepsilon}|$称为压缩因子。</p><p>在Squeezed state表象下：</p><ul><li><script type="math/tex; mode=display">\left\langle X_{1}+\mathrm{i} X_{2}\right\rangle=\left\langle Y_{1}+\mathrm{i} Y_{2}\right\rangle \mathrm{e}^{\mathrm{i} \phi}=2 \alpha</script></li><li><script type="math/tex; mode=display">\Delta Y_{1}=\mathrm{e}^{-r},  \Delta Y_{2}=\mathrm{e}^{r}</script></li><li><script type="math/tex; mode=display">\langle N\rangle=\left|\alpha^{2}\right|+\sinh ^{2} r</script></li><li><script type="math/tex; mode=display">(\Delta N)^{2}=\left|\alpha \cosh r-\alpha^{*} \mathrm{e}^{2 i \phi} \sinh r\right|^{2}+2 \cosh ^{2} r \sinh ^{2} r</script>对应的物理图像可以理解为图1的坐标旋转。<h2 id="p-s-压缩态的光子数分布："><a href="#p-s-压缩态的光子数分布：" class="headerlink" title="p.s.压缩态的光子数分布："></a>p.s.压缩态的光子数分布：</h2>对于态 $|\alpha, r\rangle$ 其光子数分布为 <script type="math/tex; mode=display">p(n)=(n ! \cosh r)^{-1}\left[\frac{1}{2} \tanh r\right]^{n} \exp \left[-|\alpha|^{2}-\frac{1}{2} \tanh r\left(\left(\alpha^{*}\right)^{2} \mathrm{e}^{\mathrm{i} \phi}+\alpha^{2} \mathrm{e}^{-\mathrm{i} \phi}\right)\right]\left|H_{n}(z)\right|^{2}</script>其中 $z=\frac{\alpha+\alpha^{*} \mathrm{e}^{\mathrm{i} \phi} \tanh r}{\sqrt{2 \mathrm{e}^{\mathrm{i} \phi} \tanh r}}$ 可以将其视为一种广义的泊松分布。<br><img src="/img_QO/3.png" srcset="/img/loading.gif" alt="势能如图"><br>当压缩率r过大时，其光子数分布会随n震荡。</li></ul><h1 id="双光子的相干态"><a href="#双光子的相干态" class="headerlink" title="双光子的相干态"></a>双光子的相干态</h1><p>当然，也可以使用另一种方法来定义压缩态。<br>此时我们定义：若 $b=\mu a+v a^{\dagger}$且$|\mu|^{2}-|v|^{2}=1$，则$\left[b, b^{\dagger}\right]=1$</p><p>可以通过变换由a得到b，即 $b=U a U^{\dagger} $</p><p>对于b的本征值问题有 </p><script type="math/tex; mode=display">b|\beta\rangle_{\mathrm{g}}=\beta|\beta\rangle_{\mathrm{g}}</script><p>其中$|\beta\rangle_g=U|\beta\rangle$。$|\beta\rangle$为$a$的本征态。</p><p>可以证明$|\beta\rangle_g$的方向是与相干态的方向平行的。所以我们可以使用基态来得到$|\beta\rangle_g$，即</p><script type="math/tex; mode=display">|\beta\rangle_{\mathrm{g}}=D_{\mathrm{g}}(\beta)|0\rangle_{\mathrm{g}}</script><p>其中<script type="math/tex">D_{\mathrm{g}}(\beta)=\mathrm{e}^{\beta \mathrm{b}^{\dagger}-\beta^{*} b}</script></p><script type="math/tex; mode=display">|0\rangle_{\mathrm{g}}=U|0\rangle</script><p>这里$|\beta\rangle_g$就是双光子的相干态。</p><p>可以发现双光子态是完备的，</p><script type="math/tex; mode=display">\int|\beta\rangle_{\mathrm{g}} g\langle\beta| \frac{\mathrm{d}^{2} \beta}{\pi}=1</script><p>而其模为</p><script type="math/tex; mode=display">\mathrm{g}\left\langle\beta | \beta^{\prime}\right\rangle_{\mathrm{g}}=\exp \left(\beta^{*} \beta^{\prime}-\frac{1}{2}|\beta|^{2}-\frac{1}{2}\left|\beta^{\prime}\right|^{2}\right)</script><p>这时我们发现若令 $U=S(\varepsilon)$，当$\mu=coshr$且则双光子的相干态与压缩态是一样的。即：</p><script type="math/tex; mode=display">|\beta\rangle_{\mathrm{g}}=S(\varepsilon) D(\beta)|0\rangle</script><h1 id="电场中的方差"><a href="#电场中的方差" class="headerlink" title="电场中的方差"></a>电场中的方差</h1><p>当我们通过X1与X2来表述电场时：</p><script type="math/tex; mode=display">E(\boldsymbol{r}, t)=\frac{1}{\sqrt{L^{3}}}\left(\frac{\hbar \omega}{2 \varepsilon_{0}}\right)^{1 / 2}\left[X_{1} \sin (\omega t-\boldsymbol{k} \cdot \boldsymbol{r})-X_{2} \cos (\omega t-\boldsymbol{k} \cdot \boldsymbol{r})\right]</script><p>可以很容易得到其方差为 </p><script type="math/tex; mode=display">\begin{aligned} V(E(\boldsymbol{r}, t))=& K\left\{V\left(X_{1}\right) \sin ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})+V\left(X_{2}\right) \cos ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})\right.\\ &\left.-\sin [2(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})] V\left(X_{1}, X_{2}\right)\right\} \end{aligned}</script><p>其中： </p><script type="math/tex; mode=display">\begin{aligned} K &=\frac{1}{L^{3}}\left(\frac{2 \hbar \omega}{\varepsilon_{0}}\right) \\ V\left(X_{1}, X_{2}\right) &=\frac{\left\langle\left(X_{1} X_{2}\right)+\left(X_{2} X_{1}\right)\right\rangle}{2}-\left\langle X_{1}\right\rangle\left\langle X_{2}\right\rangle \end{aligned}</script><p>由于最小不确定性原理 $V\left(X_1, X_2\right)=0$，有 </p><script type="math/tex; mode=display">V(E(\boldsymbol{r}, t))=K\left[V\left(X_{1}\right) \sin ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})+V\left(X_{2}\right) \cos ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})\right]</script><p><img src="/img_QO/4.png" srcset="/img/loading.gif" alt="势能如图"><br>图为电场的平均值与不确定度的关系，使用线条的粗细代表不确定度的大小。<br>由图中可以看出来：相干态（a）的方差均匀分布，这可以用上述的误差图看出，相干态的误差为圆形；而对于压缩态(b)(c），由于其误差为椭圆会呈现出不同的图案来。</p><h1 id="Multimode-Squeezed-States"><a href="#Multimode-Squeezed-States" class="headerlink" title="Multimode Squeezed States"></a>Multimode Squeezed States</h1><p>正如上面我们讨论到的，对于单一模的态不会存在压缩态，即压缩态存在于多模中。</p><p>双模的压缩态可以定义为 </p><script type="math/tex; mode=display">\left|\alpha_{+}, \alpha_{-}\right\rangle= D_{+}\left(\alpha_{+}\right) D_{-}\left(\alpha_{-}\right) S(G)|0\rangle</script><p>其中，位移算符</p><script type="math/tex; mode=display">D_{\pm}(\alpha)=\exp \left(\alpha a_{\pm}^{\dagger}-\alpha^{*} a_{\pm}\right)</script><p>幺正算符</p><script type="math/tex; mode=display">S(G)=\exp \left(G^* a_+ a_--G a_{+}^{\dagger} a_{-}^{\dagger}\right)</script><p>对幺正算符有</p><script type="math/tex; mode=display">S^{\dagger}(G) a_{\pm} S(G)=a_{\pm} \cosh r-a_{\mp}^{\dagger} \mathrm{e}^{\mathrm{i} \theta} \sinh r 其中 G=r \mathrm{e}^{\mathrm{i} \theta}</script><p>由上述有：</p><script type="math/tex; mode=display">\begin{aligned} \left\langle a_{\pm}\right\rangle &=\alpha_{\pm} \\ \left\langle a_{\pm} a_{\pm}\right\rangle &=\alpha_{\pm}^{2} \\ \left\langle a_{+} a_{-}\right\rangle &=\alpha_{+} \alpha_{-}-\mathrm{e}^{\mathrm{i} \theta} \sinh r \cosh r \\ \left\langle a_{\pm}^{\dagger} a_{\pm}\right\rangle &=\left|\alpha_{\pm}\right|^{2}+\sinh ^{2} r \end{aligned}</script><p>我们可以定义一个正交算符</p><script type="math/tex; mode=display">X=\frac{1}{\sqrt{2}}\left(a_{+}+a_{+}^{\dagger}+a_{-}+a_{-}^{\dagger}\right)</script><p>则这个算符的平均值与方差分别为：</p><script type="math/tex; mode=display">\begin{aligned} \langle X\rangle &= 2\left(\operatorname{Re}\left\{\alpha_{+}\right\}+\operatorname{Re}\left\{\alpha_{-}\right\}\right) \\ V(X) &=\left(\mathrm{e}^{-2 r} \cos ^{2} \frac{\theta}{2}+\mathrm{e}^{2 r} \sin ^{2} \frac{\theta}{2}\right) \end{aligned}</script>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Quantum Optics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Berry Phase</title>
    <link href="/2020/05/30/1/"/>
    <url>/2020/05/30/1/</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry-Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’"><a href="#我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry-Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’" class="headerlink" title="   我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’!"></a>   <strong>我翻开物理书一查，这里面没有年代，歪歪斜斜的每页上都写着‘Berry Phase’两个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是‘近似’!</strong></h2><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h2 id="不含时哈密顿量"><a href="#不含时哈密顿量" class="headerlink" title="不含时哈密顿量"></a>不含时哈密顿量</h2><p>由Schrodinger equation</p><script type="math/tex; mode=display">i \, \hbar \frac{\partial}{\partial t} | \psi\rangle= H(t) |\psi\rangle</script><p>其边界条件为</p><script type="math/tex; mode=display">|\psi_{(t=0)}\rangle=|\psi_{（0）}\rangle</script><p>当哈密顿量不含时时，$H(t)=H$ （其中H可为多体的哈密顿量）</p><script type="math/tex; mode=display">H|n\rangle=E_n |n\rangle</script><p>$\langle m | n \rangle = \delta_{mn}$  </p><p>其中$\left| n\right\rangle$为Schrodinger方程的解系，满足正交归一性$\langle m | n \rangle = \delta_{mn}$</p><p>这也意味着$|n&gt;$为完备集，即$\left| \psi(t)\right\rangle=\sum_{n} c_n (t)|n\rangle$。  </p><p>其中$c_{n}(t)=\langle n | \psi(t)\rangle$。同时有</p><script type="math/tex; mode=display">\left| \psi(t)\right\rangle=\sum_{n} \langle n | \psi(t)\rangle|n\rangle=\sum_{n} |n \rangle \langle n| \psi(t)\rangle</script><p>即 $\sum_{n}|n \rangle \langle n|=1$  </p><p>由上则$|\psi(t=0)\rangle=\sum_{n} c_n (t=0)|n\rangle$</p><p>$c_{n}(t=0)=\langle n|\psi(0)\rangle$</p><p>带入Schrodinger方程中</p><script type="math/tex; mode=display">i \, \hbar \frac{\partial}{\partial t} \sum_{n} c_n(t) | n \rangle= H \sum_{n} c_{n}(t)|n\rangle=\sum_{n} c_{n}(t) E_{n}|n\rangle</script><p>两边同时作用$| n \rangle$</p><script type="math/tex; mode=display">i\, \hbar \frac{\partial}{\partial t} \sum_{n} c_n(t)\langle m|n\rangle= \sum_n c_{n}(t) E_{n}\langle m | n\rangle</script><p>带入正交归一化条件</p><script type="math/tex; mode=display">i \,\hbar \frac{\partial}{\partial t} c_{m}(t)=E_{m} C_{m}(t)</script><p>通过积分解方程为</p><script type="math/tex; mode=display">i\, \hbar\left[\ln C_{n}(t)-\ln C_{n}(t=0)\right]=E_{n} t</script><p>解为$c_m (t)=c_m (t=0) e^{-i E_m t / \hbar}$</p><p>若把$c_{m}(t=0)$记为$c_n$，则</p><script type="math/tex; mode=display">|\psi(t)\rangle=\sum_{n} C_{n} e^{-i E t / \, \hbar}|n\rangle</script><p>其中 $e^{-i E t / \, \hbar}$ 为时间演化因子</p><p>特别的，若设 $c<em>{n}=\delta</em>{n m}$ 为初始条件，则</p><script type="math/tex; mode=display">| \psi \rangle=\sum_{n} \delta_{n m} e^{-i E_{n} t /  \, \hbar}|n\rangle=e^{-i E_{n} t / \, \hbar} | m\rangle</script><h2 id="含时哈密顿量"><a href="#含时哈密顿量" class="headerlink" title="含时哈密顿量"></a>含时哈密顿量</h2><p>当哈密顿量含时时H(t)</p><p>本质上还是解schrodinger方程$H(t)|n(t)\rangle= E_{n}(t)|n(t)\rangle$</p><p>尝试运用近似————将方程中的t看成参数。</p><p>对一个例子：对长度随时间变化的无限深势阱</p><script type="math/tex; mode=display">H(t)=\left\{\begin{array}{cc}{+\infty} & {x>L(t)} \\ {0} & {x \in[0, L(t)]} \\ {+\infty} & {x<0}\end{array}\right.</script><p><img src="/img_QM2/1.png" srcset="/img/loading.gif" alt="势能如图"><br>则此时</p><script type="math/tex; mode=display">E_{n}(t)=\frac{n^{2} h^{2}}{8 m L^{2} C t}</script><p>但是这肯定是无意义的，是可以自己计算的</p><p>所以这个近似是错误的</p><p>从数学上解释可以有。当随时间变化时，本征函数要满足正交归一化条件</p><script type="math/tex; mode=display">\begin{array}{l}{\sum_{n}|n(t)\rangle\langle n(t)|=1} \\ {\langle n(t) | m(t)\rangle=\delta m n}\end{array}</script><p>但当时间变化时这个关系不能很好的满足！</p><p>当然这种近似也不是完全没有作用的，在电子多体理论中哈密顿量为</p><script type="math/tex; mode=display">H(t)=-\frac{\hbar^{2}}{2 m} \sum_{i=1}^{N} \nabla_{i}^{2}+\sum_{i=1}^{N} V\left(\vec{r}_{i}, t\right)</script><p>可以使用上面的近似（1983年）</p><script type="math/tex; mode=display">{\Psi}=e^{-i \int^t} E\left(t^{\prime}\right) d t^{\prime} /\, \hbar {\Psi} (0)</script><p>这其中的E就为$H(t)|n(t)\rangle= E_{n}(t)|n(t)\rangle$解出的E</p><h2 id="近似"><a href="#近似" class="headerlink" title="近似"></a>近似</h2><script type="math/tex; mode=display">|\psi(t)\rangle \doteq \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}(t') d t^{\prime}+i \gamma_{n}(t)\right] |n (t)\rangle</script><p>同时这里的 $|n\rangle$ 为上面计算的正交归一基</p><p>接下来计算这个近似解：</p><p>带入shrodinger方程$i \hbar \frac{\partial}{\partial t}|\psi\rangle= H(t)|\psi\rangle$有</p><script type="math/tex; mode=display">\left.c_{n}(t) H(t) |n(t)\right\rangle= i \hbar \dot{c}_n(t)|n(t)\rangle+ i \hbar c_n (t)\frac{d}{d t}|n(t)\rangle</script><p>这其中$\dot{c}_n (t)$为c对时间的导数，又由于$H(t)|n(t)\rangle= E_n (t)|n(t)\rangle$则可得方程</p><script type="math/tex; mode=display">\dot{c}_{n}(t)=c_{n}(t)\left[-\frac{i}{\hbar} E_{n}(t)+i \dot{\gamma}_{n}(t)\right]</script><p>带入上式有</p><script type="math/tex; mode=display">\dot{\gamma}_{n}(t)=i\langle n|\dot{n}\rangle   (1)</script><p>其中 $|\dot{n}\rangle$ 为 $\frac{d}{d t}|n(t)\rangle$ ，写成积分模式为</p><script type="math/tex; mode=display">\gamma_{n}(t)=i \int_{0}^{t}\left\langle n\left(t^{\prime}\right) | \dot{n}\left(t^{\prime}\right)\right\rangle d t^{\prime}</script><p>进一步，当H由参数$R(t)$决定时(H通过R来依赖t）即$H(t)=H \cdot \vec{R}(t)$。$\vec{R}(t)$是一个多方向的取值函数，则</p><script type="math/tex; mode=display">\frac{d}{d t} |n \left(\vec{R}(t)\right)\rangle =\left(\frac{d}{d t} \vec{R}(t)\right) \cdot \nabla_{\vec{R}} \cdot | n (\vec{R}_{(t)})\rangle</script><p>其中</p><script type="math/tex; mode=display">\bar{R}=\left(R_{1}, \cdots, R_{n}\right) \quad \nabla_{\bar{R}}=\sum_{i}^{n} \hat{e}_{i} \frac{\partial}{\partial R_{j}}</script><p>带入（1）式有,使用牛顿记号表示R对时间t的导数。</p><script type="math/tex; mode=display">\left.\dot{\gamma}_{n}(t)=i\left\langle n(\vec{R}(t))\left|\vec{\nabla}_{R}\right| n(\vec{R}(t))\right\rangle\right\rangle \cdot \dot{\vec{R}}(t)</script><p>则可得：</p><script type="math/tex; mode=display">| \psi(t)\rangle = \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(\vec{R}\left(t^{\prime}\right)\right) d t^{\prime}\right]\exp \left[-\int_{0}^{t} \langle n(t^{\prime}) \left|\dot{n}\left(t^{\prime}\right)\right\rangle d t^{\prime}\right]|n (\vec{R}(t))\rangle</script><p>可以观察到该结构有一定的对称性，可以约定</p><p>第一项可设为动力学因子，这与量1中是相同的</p><script type="math/tex; mode=display">\alpha_{n}(t)=-\frac{1}{\hbar} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}  (2)</script><p>第二项即为Barry phase，是一个‘多出来’的一项</p><script type="math/tex; mode=display">\gamma_{n}(t)=i \int_{0}^{t} \langle n(t^{\prime}) \left|\dot{n}\left(t^{\prime}\right)\right\rangle d t^{\prime}   (3)</script><p>则此时$| \psi(t)\rangle$可以改写为简单的形式</p><script type="math/tex; mode=display">| \psi(t)\rangle = \exp (i \alpha_{n}(t)) \exp (i\gamma_{n}(t))|n (\vec{R}(t))\rangle   (4)</script><p>式（2）（3）（4）即为Barry phase理论的核心！</p><p><strong>specially:</strong>$\vec{R}_{(t=0)}=\vec{R}(t=T)$即R(t)可以周期回归，则</p><script type="math/tex; mode=display">\gamma_{n}(t=T)=i \oint_{c} \langle n (\vec{R}) | \nabla_{R} n(\vec{R}) \rangle \cdot d \vec{R}</script><h1 id="引入——绝热条件"><a href="#引入——绝热条件" class="headerlink" title="引入——绝热条件"></a>引入——绝热条件</h1><p>现在不妨重新严格的解一遍。此时参考H不含时$|\psi(t)\rangle=\sum_{n}c_n(t)|n(t)\rangle$<br>对于$c_n (t)$可以将其设为,可以看出这种设法相当于是将$c_n (t)$以不同能量组成的时间演化算子展开。咕这种展开是不失一般性的。</p><script type="math/tex; mode=display">c_n(t)=a_n (t) \exp [-\frac{i}{n} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}]</script><p>带入Schrodinger方程中$i \hbar \frac{\partial}{\partial t} | \psi \rangle= H(t)|\psi\rangle$<br>则</p><script type="math/tex; mode=display">i \hbar \sum_{n}\left\{\dot{a}_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t\right]|n(t)\rangle\right.-\frac{i}{\hbar} a_{n}(t) E_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right] |n(t)\rangle</script><script type="math/tex; mode=display">\left.+a_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right] \frac{\partial}{\partial t}|n(t)\rangle\right\}=\sum_{n} a_n (t) E_{n}(t) \exp [-\frac{i}{\hbar} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}] |n(t)\rangle</script><p>化简后即为</p><script type="math/tex; mode=display">i \hbar \sum_{n}\left\{\dot{a}_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t\right]|n(t)\rangle\right.\left.+a_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right] \frac{\partial}{\partial t}|n(t)\rangle\right\}=0</script><p>操作：同时左乘$\langle l(t) |$，其中l为n中的一个本征态（即$\langle l(t) | n \rangle = \delta_{l n}$）。有</p><script type="math/tex; mode=display">i \hbar \left\{\dot{a}_{l} (t) \exp \left(-\frac{i}{\hbar} \int_{0}^{t} E_{l} (t^{\prime}) d t^{\prime}\right)\right\}+\sum_{n} a_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right]\left\langle l(t)\left|\frac{\partial}{\partial t}\right| n(t)\right\rangle=0</script><p>则有</p><script type="math/tex; mode=display">\dot{a}_{n}(t)=-\sum_{i \neq n} a_{l}(t) \exp \left(\frac{i}{\hbar} \int_{0}^{t}\left[E_{n}\left(t^{\prime}\right)-E_{l}\left(t^{\prime}\right)\right] d t^{\prime}\right)\langle n | \dot{l} \rangle -a_{n}(t)\langle n / \dot{l}\rangle</script><p>此时若令出态为$|\psi_0\rangle=|m_0\rangle$。则可以单独提出 $l=m$ 的一项，为</p><script type="math/tex; mode=display">\dot{a}_{n}(t)= -a_{n}(t)\langle n / \dot{l}\rangle</script><script type="math/tex; mode=display">-a_{m}(t) \exp \left(\frac{i}{\hbar} \int_{0}^{t}\left[E_{n}\left(t^{\prime}\right)-E_{m}\left(t^{\prime}\right)\right] d t^{\prime}\right)\langle n | \dot{m} \rangle</script><script type="math/tex; mode=display">-\sum_{i \neq n or m} a_{l}(t) \exp \left(\frac{i}{\hbar} \int_{0}^{t}\left[E_{n}\left(t^{\prime}\right)-E_{l}\left(t^{\prime}\right)\right] d t^{\prime}\right)\langle n | \dot{l} \rangle</script><p>接下来做近似：对于这个近似我们希望可以使$\dot{a}_{n}(t)$很小，同时由$\sum_n \left|a_n (t)\right|^2 =1$<br>可知a（t）的图像为<br><img src="/img_QM2/2.png" srcset="/img/loading.gif" alt="势能如图"><br>我们可知，只需使$\langle n | \dot{m} \rangle$较小，既可以使a（t）小。具体逻辑链如图</p><p><img src="/img_QM2/3.png" srcset="/img/loading.gif" alt="势能如图"><br>其中箭头代表可以推出，而1、2、3则为$\dot{a}_{n}(t)$中的分项。<br>对$\langle n | \dot{m} \rangle$做无量纲化，则可以得到大名鼎鼎的绝热近似。</p><script type="math/tex; mode=display">\left |\frac{\langle n | \dot{m}\rangle}{\left(E_{m}-E_{n}\right)\hbar}\right | <<1</script><p>对于任意$n \neq m$都成立<br>接下来会给出绝热近似的另一种表述以及更深一步的讨论：</p><p>绝热近似也可以理解为$\dot{H}(t)$为小量，即：</p><script type="math/tex; mode=display">\left|\frac{\hbar \langle m|\dot{n}\rangle}{E_{n}-E_{m}}\right|=\frac{\hbar\langle m|\dot{H}| n\rangle}{\left(E_{n}-E_{m}\right)^{2}}<<1</script><p>证明如下：</p><p>由$H(t)|n(t)\rangle= E_{n}(t)|n(t)\rangle$，两边同时对t求导</p><script type="math/tex; mode=display">\left(\frac{\partial}{\partial t} H(t)\right)|n(t)\rangle+ H \frac{\partial}{\partial t}|n\rangle=\dot{E}_{n}(t)|n(t)\rangle+ E_{n}|\dot{n}(t)\rangle</script><p>内积：</p><script type="math/tex; mode=display">\left\langle m\left|\left(\frac{\partial}{\partial t} H(t)\right)\right| n(t)\right\rangle + {\langle m|H| \dot{n}\rangle}={\left\langle m\left|\dot{E}_{n}(t)\right| n\right\rangle}+\left\langle m\left|E_{n}\right| \dot{n}\right\rangle</script><p>其中${\langle m|H| \dot{n}\rangle}= E_m \langle m|\dot{n}\rangle$，由于$m \neq n$</p><p>${\left\langle m\left|\dot{E}_n (t)\right| n\right\rangle}=0$。<br>则有</p><script type="math/tex; mode=display">\langle m (t) |  \dot{n}(t) \rangle=\frac{\langle m(t)|\dot{H} (t) n(t)\rangle}{E_{n}(t)-E_{m} (t)}</script><p>Q.E.D</p><p>则由绝热近似可得：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{\dot{a}_{m}(t)=-a_{m}(t)\langle m|\dot{m}\rangle} \\ {\dot{a}_{n}(t)=0 \quad(n \neq m)}\end{array}\right.</script><p>咕</p><script type="math/tex; mode=display">a_{m}(t)=a_{m}(0) \exp \left[-\int_{0}^{t}\langle m (t')|\dot{m}(t')\rangle d t' \right]</script><p>若令</p><script type="math/tex; mode=display">i \gamma_m (t)= \left[-\int_{0}^{t}\langle m (t')|\dot{m} (t') \rangle d t' \right]</script><p>则$a_m (t)=a_m (0) \exp [i \gamma_m (t)]$</p><script type="math/tex; mode=display">|\psi(t)\rangle = \sum_{n} a_n (t) \exp [-\frac{i}{n} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}]|n(t)\rangle</script><script type="math/tex; mode=display">=a_{m}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{m}\left(t^{\prime}\right) d t^{\prime}\right]|m(t)\rangle</script><script type="math/tex; mode=display">=e^{i[\alpha_{m}(t)+\gamma_{m}(t)]} |m(t)\rangle</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{\alpha_{n}(t)=-\frac{1}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}} \\ {\gamma_{m}(t)=i \int_{0}^{t}\langle n | n\rangle d t'}\end{array}\right.</script><p>其中$\gamma_{m}(t)$为Barry phase</p><p>以上即为绝热近似与Barry phase的关系。接下来带入到一个例子中来看看具体的计算</p><h2 id="Example-spin-in-maginatic-fields"><a href="#Example-spin-in-maginatic-fields" class="headerlink" title="Example: spin in maginatic fields"></a>Example: spin in maginatic fields</h2><p>对于一个自旋系统，其哈密顿量为：</p><script type="math/tex; mode=display">H(\vec{B}(t))=  -\vec{\mu} \cdot \vec{B}(t)=-\vec{\mu} \vec{\sigma} \cdot \vec{B}(t)</script><script type="math/tex; mode=display">=-\vec{\mu} \left[\sigma_{x} B_{x}+\sigma_{y} B_{y}+\sigma_{z} B_{z}\right]</script><p>其中：$\vec{\sigma}$为Pauli矩阵；且set周期性磁场为$\vec{B}(t)=\left(B_1 \cos 2 w_0 t, B_1 \sin 2 w_1 t, B_0 \right)$<br>即当$t=T=\frac{\pi}{w_0}$时回归。</p><p>解方程:</p><script type="math/tex; mode=display">H(t)\left|\psi_{\pm}(t)\right\rangle= E_{1}(t)\left|\psi_{\pm}(t)\right\rangle</script><p>即解H的本征问题，其中</p><script type="math/tex; mode=display">H(t)= -\mu_{B}\left(B_x \left[\begin{array}{ll}{0} & {1} \\ {1} & {0}\end{array}\right] + B_y \left[\begin{array}{ll}{0} & {-i} \\ {i} & {0}\end{array}\right] +B_z \left[\begin{array}{ll}{1} & {0} \\ {0} & {-1}\end{array}\right]\right)</script><script type="math/tex; mode=display">=-\vec{\mu}_B \left[\begin{array}{cc}{B_{0}} & {B_{1} e^{-i 2 k t}} \\ {B_{1} e^{i 2 k_{k} t}} & {-B_{0}}\end{array}\right]</script><p>本征函数</p><script type="math/tex; mode=display">\left|\psi_{-}(t)\right\rangle=\left[\begin{array}{l}{\cos \frac{\theta}{2}} \\ {\sin \frac{\theta}{2} e^{-2 i w_{0} t}}\end{array}\right]</script><script type="math/tex; mode=display">\left|\psi_{+}(t)\right\rangle=\left[\begin{array}{l}{-\sin \frac{\theta}{2}} \\ {\cos \frac{\theta}{2} e^{\sin \alpha \cdot t}}\end{array}\right]</script><p>其中$\theta=\tan ^-1\left(\frac{B_1}{B_0}\right)$<br>其对应的本征值为</p><script type="math/tex; mode=display">E_{-}(t)=-\mu_{B} \sqrt{B_{0}^{2}+B_{1}^{2}}</script><script type="math/tex; mode=display">E_{+}(t)=\mu_{B} \sqrt{B_{0}^{2}+B_{1}^{2}}</script><p>现在来计算这个问题中的Barry phase<br>首先我们设</p><script type="math/tex; mode=display">|\psi(t)\rangle= e^{i\left[\alpha_n (t)+\gamma_n (t)\right]} |m(t)\rangle</script><p>其中设<script type="math/tex">|\psi(0)\rangle=\left|\psi_- (t=0)\right\rangle</script>为初始值</p><script type="math/tex; mode=display">\gamma_{n}(t)= i \int_{0}^{t}\left\langle\psi\left(t^{\prime}\right) | \dot{\psi} \left(t^{\prime}\right)\right\rangle d t^{\prime}</script><script type="math/tex; mode=display">= i \int_{0}^{t}\left[\cos \frac{\theta}{2}, \sin \frac{\theta}{2} e^{-2 i w_{0} t^{\prime}}\right]\left[\begin{array}{c}{0} \\ {-2 i w_{0} \sin \frac{\theta}{2} e^{-2 i w_{0} t^{\prime}}}\end{array}\right] \quad d t^{\prime}</script><script type="math/tex; mode=display">=-2 i \int_{0}^{t} i w_{0} \sin \frac{\theta}{2} d t^{\prime}</script><script type="math/tex; mode=display">=2 w_{0} t \sin ^{2}\left(\frac{\theta}{2}\right)</script><p>则态函数可表示为</p><script type="math/tex; mode=display">|\psi(t)\rangle= \exp [i \gamma(t)] \exp \left[-\frac{i}{\hbar} \int_{0}^{t} d t^{\prime} E_{-}\left(t^{\prime}\right)\right] |\psi_{-} (t)\rangle</script><script type="math/tex; mode=display">= \exp \left[i 2 w_{0} t \sin ^{2} \frac{\theta}{2}\right]\exp \left[-\frac{i}{\pi} \mu_{B} \sqrt{B_{0}^{2}+B_{1}^{2}} T\right] |\psi_{-} (t)\rangle</script><p>其中$T=\frac{\pi}{w_{0}}$为周期。</p><h1 id="Effective-fields-near-degenenacy（简并）-point"><a href="#Effective-fields-near-degenenacy（简并）-point" class="headerlink" title="Effective fields near degenenacy（简并） point"></a>Effective fields near degenenacy（简并） point</h1><p>我们可以考虑另一种Barry phase的表示形式：</p><script type="math/tex; mode=display">\gamma_{n}(c)=\oint_{c}  i\left\langle n\left(\vec{R}\right) | \nabla_{\vec{R}} n_{(\vec{R})}\right\rangle \cdot d \vec{R}</script><p><img src="/img_QM2/4.png" srcset="/img/loading.gif" alt="势能如图"><br>接下来先证明$\gamma_n (c)$为实数。<br>即，</p><script type="math/tex; mode=display">\langle n(\vec{R}) | \nabla_{\vec{R}} n_{(\vec{R})}\rangle</script><p>为虚数<br>$\Longrightarrow$  由$\nabla_R \cdot\langle n(\vec{R}) | n(\vec{R})\rangle= 0$，其中$\langle n(\vec{R}) | n(\vec{R})\rangle=1$<br>展开有$0=\langle\nabla_R n(\vec{R}) | n(\vec{R})\rangle + \langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle=(\langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle)^*+\langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle$</p><p>由此可知$\langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle$为虚数，则$\gamma_n (c)$为实数。</p><p>接下来我们将$\gamma_n (c)$改写$\Longrightarrow$ $\gamma_n (c)=-{Im}\left[\oint_c \left\langle n(\vec{R}) | \nabla_R  n(\vec{k})\right\rangle \cdot d \vec{R}\right]$<br>我们令$-{A_n}(\vec{R})   = i \langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle$则有</p><script type="math/tex; mode=display">\gamma_n (c)=-\oint_c {A_n }(\vec{R}) \cdot d \vec{R}=-\iint_S [\vec{\nabla}_R  \times \vec{A}_n (\vec{R})] \cdot d \vec{S}</script><p>其中$-{A_n }(\vec{R})$称为磁矢势，所以我们有：$\gamma_n (c)=-\iint_S \vec{B}_n (\vec{R}) \cdot d \vec{S}$。我们可以称$\vec{B}_n (\vec{R})$为磁场也可以称为有效场，由此 $\gamma_n (c)$即为磁通量</p><p>我们来接着讨论这个磁场$\vec{B}_n$,首先可以写出磁场$\vec{B}_n$，这里第二给等号是因为对易</p><script type="math/tex; mode=display">\vec{B}_{n}(\vec{R})=\nabla_{R} \times {Im} \langle n(\vec{R}) | \nabla_{R} n(\vec{R})\rangle=Im \nabla_{\vec{R}} \times\langle n(\vec{R}) | \nabla_{R} n(\vec{R})\rangle</script><p>由此我们将$\vec{B}_{n}$写为</p><script type="math/tex; mode=display">\vec{B}_{n}(\vec{R})=I m \sum_{m \neq n} \frac{\langle n(\vec{R})|\nabla_{R} H| m(\vec{R})\rangle \times \langle m(\vec{R})|\nabla_{\vec{R}} H| n(R)\rangle.}{[E_{n}(\vec{R})-E_{m}(\vec{R})]^{2}}</script><p>在证明这个式子之前我们先来谈一谈这个式子的‘好处’：这个式子使原来对$| n(\vec{R})\rangle$的$\nabla_{R}$转化为对哈密顿量H（通常已知）的作用，这可以极大的简化计算\<br>$\Longrightarrow$  由</p><script type="math/tex; mode=display">\begin{aligned}\vec{B}_{n}(\vec{R}) &={Im}\left[\langle  \nabla_{R} n(\vec{R})|\times | \nabla_{R} n(\vec{R}) \rangle+\langle n(\vec{R}) |\nabla_{R} \times \nabla_{R} n(\vec{R}) \rangle\right]\\&=I m \left[\sum_{m \neq n}\langle\nabla_{R} n(\vec{R}) | m(\vec{R})\rangle \times \langle m(\vec{R})| \nabla_{R} n(\vec{R})\rangle +\langle\nabla_{R} n(\vec{R}) | n(\vec{R})\rangle \times \langle n(\vec{R})| \nabla_{R} n(\vec{R})\rangle\right]\end{aligned}</script><p>因为$\langle n(\vec{R}) | \nabla_{R} n(\vec{R})\rangle$为虚数故最后一项$=0$，由此B可改写为</p><script type="math/tex; mode=display">\begin{aligned}\left(B_{n}\right)_{i}&=I m\left[\varepsilon_{i j k}\left\langle\partial_{j} n | \partial_{k} n\right\rangle\right] =I m\left[\varepsilon_{i j k} \sum_{m}\langle \partial_{j} n | m\rangle\left\langle m | \partial_{k} n\right\rangle\right]\\&=I m\left[\varepsilon_{i j k} \sum_{m \neq n}\langle\partial_{j} n | m\rangle\langle m | \partial_{k} n\rangle+\langle\partial_{j} n | n\rangle\langle n | \partial_{k} n\rangle\right]\end{aligned}</script><p>最后一项</p><script type="math/tex; mode=display">=\epsilon_{ijk} \left\langle n | \partial_j  n\right\rangle\left\langle\partial_k n | n\right\rangle=\epsilon_{ijk} \left\langle n | \partial_k n\right\rangle\left\langle\partial_j n | n\right\rangle=0</script><p>则有</p><script type="math/tex; mode=display">\vec{B}_n (\vec{R})=I m \left[\sum_{m \neq n}\langle\nabla_R n(\vec{R}) | m(\vec{R})\rangle \times \langle m(\vec{R})| \nabla_R n(\vec{R})\rangle \right]</script><p>接下来我们只需证明：<script type="math/tex">\left\langle m | \nabla_{\vec{R}} n\right\rangle=\frac{\left\langle m| \nabla_{\vec{R}} H | n\right\rangle}{E_n -E_m }</script>即可</p><p>$\Longrightarrow$  由哈密顿量H的本征值$H|n\rangle=E_n |n\rangle$</p><p>两边同时作用$\nabla_R$，有$\left.\left(\nabla_R H\right)|n\rangle+H \nabla_R |n\rangle=\left(\nabla_R E_n \right)\left|n\rangle+E_n \nabla_R \right| n\right\rangle$</p><p>在同时乘上$\langle m|$，有</p><script type="math/tex; mode=display">\left\langle m\left|\nabla_R H\right| n\right\rangle+\left\langle m\left|H \nabla_{R}^{}\right| n\right\rangle=\left\langle m\left|\nabla_R E_n \right| n\right\rangle+\left\langle m\left|E_n \nabla_R \right| n\right\rangle</script><p>其中</p><script type="math/tex; mode=display">\left\langle m\left|H \nabla_{R}\right| n\right\rangle=E_{n}\left\langle m\left|\nabla_{\vec{R}}\right| n\right\rangle</script><p>而</p><script type="math/tex; mode=display">\langle m|\nabla_R E_n| n\rangle=\nabla_{\vec{R}} E_n \langle m | n\rangle=0</script><p>由此可以证明</p><p>接着我们来讨论一下这个问题下的能级问题，即当$E_n$与$E_m$相邻很近时，如图所示<br><img src="/img_QM2/5.png" srcset="/img/loading.gif" alt="势能如图"><br>其中$*$点代表我们讨论的点，$\cdot$代表$E_n=E_m$时的简并点</p><p>此时我们有：$E_n=E_m$</p><script type="math/tex; mode=display">\begin{aligned}&H(\vec{R}^*)|m(\vec{R}^{*})\rangle=E_{m}(\vec{R}^{*})|m(\vec{R}^{*})\rangle\\&H(\vec{R}^{*})|n(\vec{R}^{*})\rangle=E_{n}(\vec{R}^{*})|n(\vec{R}^{*})\rangle\end{aligned}</script><p>我们简化符号：$|n\rangle-&gt; |+\rangle\quad| m\rangle -&gt; |-\rangle$。则磁场B为</p><script type="math/tex; mode=display">\vec{B}_{n}(\vec{R})=I m  \frac{\langle +(\vec{R})|\nabla_{R} H| -(\vec{R})\rangle \times \langle -(\vec{R})|\nabla_{\vec{R}} H| +(R)\rangle.}{[E_{+}(\vec{R})-E_{-}(\vec{R})]^{2}}</script><p>哈密顿量的本征值也简并为</p><script type="math/tex; mode=display">\begin{aligned}H(\vec{R}^{*})|\pm(\vec{R}^{*})\rangle &=E_{\pm}\left|\pm\left(\vec{R}^{*}\right)\right\rangle \\&=E\left|\pm\left(\vec{R}^{*}\right)\right\rangle\end{aligned}</script><p>使用$|\pm\rangle$为基展开H，有</p><script type="math/tex; mode=display">H(\vec{R})=\left[\begin{array}{ll}H_{11}(\vec{R}) & H_{12}(\vec{R}) \\H_{21}(\vec{R}) & H_{22}(\vec{R})\end{array}\right]</script><p>特殊的</p><script type="math/tex; mode=display">H(\vec{R}^{*})=\left[\begin{array}{ll}E(\vec{R}^{*}) & 0 \\0 & E(\vec{R}^{*})\end{array}\right]</script><p>其中$E(\vec{R}^*)$为常数，经过适当调整可使其为</p><script type="math/tex; mode=display">H\left(\vec{R}^* \right)=0</script><p>同时我们也可以使用泡利矩阵$\sigma$展开：</p><script type="math/tex; mode=display">H(\vec{R})=\vec{\sigma} \cdot \vec{R} \pm \vec{\sigma}_0 \cdot \vec{R^* }</script><p>其中$\sigma_0$为常数使得</p><script type="math/tex; mode=display">H\left(\vec{R}^* \right)=0</script><p>当我们令$R=(x,y,z)$时</p><script type="math/tex; mode=display">H(\vec{R})=\left[\begin{array}{cc}z & x-i y \\x+i y & z\end{array}\right]</script><p>解其本征值有</p><script type="math/tex; mode=display">E_+ (\vec{R})=-E_- (\vec{R})=R</script><p>由泡利矩阵的展开表示我们有$\nabla_R (H(\vec{R}))=\vec{\sigma}$，带入到磁场B的计算中有：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}B_{+ x}=Im\left[  \frac{\langle+|\sigma_{y}|-\rangle \times \langle-|\sigma_{z}|+\rangle}{2 R^{2}} \right]=0 \\B_{+ y}=Im\left[  \frac{\langle+|\sigma_{z}|-\rangle \times \langle-|\sigma_{x}|+\rangle}{2 R^{2}} \right]=0 \\B_{+ z}=Im\left[  \frac{\langle+|\sigma_{x}|-\rangle \times \langle-|\sigma_{y}|+\rangle}{2 R^{2}} \right]=\frac{1}{2 R^{2}}\end{array}\right.</script><p>即，磁极单子</p><script type="math/tex; mode=display">\vec{B}_+ (\vec{R})=\frac{\vec{R}}{2 R^3 }</script><p>由此</p><script type="math/tex; mode=display">\gamma_+ (c)=-\gamma_{-}(c)=-\iint_{S}[\vec{B}_{+}(\vec{R})] \cdot d \vec{S}=-\iint_{S}[\frac{\vec{R}}{2 R^{3}}] \cdot d \vec{S}=-\frac{1}{2} \Omega(c)</script><p>可以用立体角来表示磁通，如图所示</p><p><img src="/img_QM2/6.png" srcset="/img/loading.gif" alt="势能如图"></p><p>即磁通对应闭合曲线C在R空间中的立体角</p><h1 id="Aharanov-Anandan-Phases"><a href="#Aharanov-Anandan-Phases" class="headerlink" title="Aharanov-Anandan Phases"></a>Aharanov-Anandan Phases</h1><p>当态随着时间周期性演化时：</p><script type="math/tex; mode=display">|\psi(T)\rangle=\exp \left[i \gamma_{n}(T)\right] \exp \left[i \alpha_{n}(T)\right] | \psi(0)\rangle</script><p>其中T为周期，</p><script type="math/tex; mode=display">\alpha_n (T)=-\frac{1}{\hbar} \int_{0}^{T} E_n \left(t^{\prime}\right) d t^{\prime}</script><p>接下我们看到如果我们将$|\psi(T)\rangle$改写为$|\psi(T)\rangle=e^{i \phi} | \psi(0)\rangle$，则我们可以看到$\phi \neq \alpha$<br>在这里我们重新定义$\alpha(T)$为</p><script type="math/tex; mode=display">\alpha(T)=-\frac{1}{\hbar} \int_{0}^{t} d t<\psi(t)|H(t)| \psi(t)\rangle</script><p>在证明$\phi \neq \alpha$之前我们需要先说明一下当$H(t)=H$即不含时且在同一个态上演化时$\phi = \alpha$<br>$\Longrightarrow$ 由薛定谔方程：$i \hbar \frac{\partial}{\partial E} |\psi(t) \rangle=H(t)|\psi(t)\rangle$，其中H可以含时也可以不随时间变化<br>我们令$|\tilde{\psi}(t)\rangle=e^{-i f(t)}|\psi(t)\rangle \quad f(T)-f(0)=\phi$则经过应该周期后$|\tilde{\psi}(T)\rangle=|\tilde{\psi}(0)\rangle$。带入到薛定谔方程中</p><script type="math/tex; mode=display">H(t)|\psi(t)\rangle=i \hbar \frac{\partial}{\partial t}\left[e^{-i f(t)} | \tilde{\psi}(t)\right]=-\hbar \dot{f}(t)|\psi(t)\rangle+i \hbar e^{i f(t)} \frac{\partial}{\partial t}|\tilde{\psi}(t)\rangle</script><p>两边同时作用$\langle\psi(t)|$</p><script type="math/tex; mode=display">-\hbar \dot{f}(t)+i \hbar \langle \psi(t)|e^{i f(t)} \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle=\langle\psi(t)|H(t)| \psi(t)\rangle</script><script type="math/tex; mode=display">\hbar \dot{f}(t)=\langle\tilde{\psi}(t)|i \hbar \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle-\langle\psi(t)|H(t)| \psi(t)\rangle</script><p>两边作用积分$\int_{0}^{T} d t$</p><script type="math/tex; mode=display">\hbar[f(T)-f(0)]=\int_{0}^{T} d t\langle\tilde{\psi}(t)|i \hbar \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle+\hbar \alpha</script><p>其中$f(T)-f(0)=\phi$而</p><script type="math/tex; mode=display">\int_{0}^{T} d t\langle\tilde{\psi}(t)|i \hbar \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle=\hbar \gamma</script><p>由此$\phi \neq \alpha$</p><p>Example:</p><script type="math/tex; mode=display">H(t)=H \quad H|\psi_{\pm}\rangle=E_{\pm}| \psi_{\pm}\rangle\quad|\psi(0)\rangle=\cos \frac{\theta}{2}|\psi_{-} \rangle+\sin \frac{\theta}{2}| \psi_{+}\rangle</script><p>$\Longrightarrow$ </p><script type="math/tex; mode=display">\begin{aligned}|\psi(t)\rangle &=e^{-i E_{-}t / \hbar} \cos \frac{\theta}{2} \beta|\psi_{-} \rangle + e^{-i E_{+} t / \hbar} \sin \frac{\theta}{2}| \psi_{+} \rangle \\&=e^{-i E_{-}t / \hbar}[\cos \frac{\theta}{2} |\psi_{-} \rangle + e^{-i(E_{+} - E_{-}) t / \hbar} \sin \frac{\theta}{2} | \psi_{+}\rangle]\end{aligned}</script><p>当我们令</p><script type="math/tex; mode=display">T {\longrightarrow}(E_{ + }-E_{ - }) T/ \hbar=2 \pi</script><p>我们有</p><script type="math/tex; mode=display">|\psi(T)\rangle=e^{-i E_- T / t}|\psi(0)\rangle</script><p>由此有$\phi=E_{ - } T / t$</p><script type="math/tex; mode=display">\begin{aligned}\alpha(T) &=-\frac{1}{\hbar} \int_{0}^{t} d t\langle\psi(t)|H(t)| \psi(t)\rangle \\ &=-\frac{1}{\hbar} \int_{0}^{T} d t\left[\cos \frac{\theta}{2}\langle\psi_{-}|+e^{-i(E_{+}-E_{-}) t / \hbar} \sin \frac{\theta}{2}\langle\psi_{+}|\right]\left[\cos \frac{\theta}{2} \theta|\psi \rangle + e^{-i(E_{+} -E_{-}) t / \hbar} \sin \frac{\theta}{2}| \psi_{+}\rangle\right]\\ &=-\frac{1}{\hbar}[E_{-}T\cos ^{2} \frac{\theta}{2}+E_{+}T \sin \frac{\theta}{2}]\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\begin{aligned}\gamma(T)&=\phi-\alpha(T)=\frac{-E_{-} \hbar}{\hbar}+\frac{1}{\hbar}[E_{-}T\cos ^{2} \frac{\theta}{2}+E_{+}T \sin \frac{\theta}{2}]\\&=\frac{1}{\hbar}\left[E_{+} -E_{-}\right] T \frac{1-\cos \theta}{2}=\left\{\begin{array}{ll} 0 & \theta=0 \\ 2 \pi & \theta=\pi \end{array}\right.\end{aligned}</script><h1 id="Gauge-invariance-of-QM"><a href="#Gauge-invariance-of-QM" class="headerlink" title="Gauge invariance of QM"></a>Gauge invariance of QM</h1><p>在电磁学中有</p><script type="math/tex; mode=display">\vec{E}=-\nabla V-\frac{1}{c} \frac{\partial \vec{A}}{\partial t} \quad \vec{B}=\nabla \times \vec{A}</script><p>我们引入了规范</p><script type="math/tex; mode=display">V \rightarrow V+\frac{1}{c} \frac{\partial}{\partial t} X \quad \vec{A} \rightarrow \vec{A}+\nabla X</script><p>其中X为Gauge，当X变化时E，B并不随规范变化。</p><p>在QM中我们也会运用到规范，尤其时薛定谔方程$\left[\frac{p^2}{2 m}+V(\vec{r}, t)\right] \psi(r, t)=i \hbar \frac{\partial}{\partial t} \psi$中的哈密顿量含时时我们需要引入磁场B，即改写<br>动量P为</p><script type="math/tex; mode=display">{\vec{p}}^{\prime}\rightarrow \vec{p}-\frac{q \vec{A}}{c}</script><p>其中我们称$ \vec{p}$为Canonical momentum，$\vec{p}^{\prime}$为Kinematic momentum<br>由此我们可以得到薛定谔电磁学绘景</p><script type="math/tex; mode=display">\left[\frac{1}{2 m}\left(\vec{p}-\frac{q \vec{A}}{c}\right)^{2}+V(r, t)\right] \psi(r, t)=i \hbar \frac{\partial}{\partial t} \psi</script><p>此时我们若令</p><script type="math/tex; mode=display">V^{\prime} =V+\frac{1}{c} \frac{\partial}{\partial t} X \quad \vec{A}^{\prime} = \vec{A}+\nabla X</script><p>则有</p><script type="math/tex; mode=display">\left[\frac{1}{2 m}\left(\vec{p}-\frac{q \vec{A}^{\prime}}{c}\right)^{2}+V^{\prime}(r, t)\right] \psi^{\prime}(r, t)=i \hbar \frac{\partial}{\partial t} \psi^{\prime}</script><p>之后我们就可以得到$\psi^{\prime}=e^{i q X / \hbar c} \psi$。我们将规范带入即可证明。</p><h1 id="Phase-due-to-scalar-potential-V-t-and-vector-potential-vec-A-R"><a href="#Phase-due-to-scalar-potential-V-t-and-vector-potential-vec-A-R" class="headerlink" title="Phase due to scalar potential $V(t)$ and vector potential $\vec{A}(R)$"></a>Phase due to scalar potential $V(t)$ and vector potential $\vec{A}(R)$</h1><p>在上一节我们已经意识到当我们改变哈密顿量H的方法不同时会得到不一样的随时间演化的态\<br>这一节我们来讨论方程</p><script type="math/tex; mode=display">i \hbar \frac{\partial}{\partial t} \psi_{0}(\vec{r}, t)=H_{0}(t) \psi_{0}(\vec{r}, t)</script><ul><li>$H(t)=H_0 (t)+V(t)$：当我们给哈密顿量加上随时间变换是标量势时则<script type="math/tex; mode=display">i \hbar \frac{\partial}{\partial t} \psi(\vec{r}, t)=H(t) \psi(\vec{r}, t)</script>此时态演化为<script type="math/tex; mode=display">\psi(\vec{r}, t)=\psi_{0}(\vec{r}, t) e^{-i \int_{t_{0}}^{t} V(t^{\prime}) d t^{\prime}}=\psi_{0}(\vec{r}, t) e^{-i S(t) / \hbar}</script>其中$S(t)=\int_{t_0}^t V\left(t^{\prime}\right) d t^{\prime}$</li></ul><ul><li>$H_{0}(t)\stackrel{+\vec{A}}{\longrightarrow}H(t)$：当我们给哈密顿量加上随时间变换是矢势时有<script type="math/tex; mode=display">\psi(\vec{r}, t)=\psi_{0}(\vec{r}, t) e^{-i \frac{q}{c}\int_{\vec{r}_{0}}^{\vec{r}} \vec{A}(\vec{r}^{\prime}) d \vec{r}^{\prime}}</script> 接下来我们来证明一下这个式子<br> $\Longrightarrow$ <script type="math/tex; mode=display">\begin{aligned}\vec{p} e^{-i \frac{s}{\hbar}} &=e^{-i \frac{s}{\hbar}}(-i \hbar) \nabla\left(-i \frac{s}{\hbar}\right) \\&=\exp \left(-i \frac{s}{\hbar}\right)(-)\left(-\frac{\hbar}{c}\right) \nabla \int^{\vec{r}}_{\vec{r}_{0}} \vec{A}(\vec{r}^{\prime}) d \vec{r} ^{\prime}\\ &=\exp \left(-i \frac{s}{\hbar}\right) \frac{q}{c} \vec{A}(\vec{r})\end{aligned}</script> 由此<script type="math/tex; mode=display">\left[\vec{p}-\frac{q}{c} \vec{A}(r)\right] f(\vec{r}, t) e^{-i  S / \hbar}=</script><script type="math/tex; mode=display">[\vec{p} f(\vec{r}, t)] e^{-i {S}/{\hbar}}+f(\vec{r}, t)\left(\vec{p} e^{-i S / \hbar}\right)-\frac{q}{c} \vec{A} (\vec{r})  f(\vec{r}, t) e^{-i S / \hbar}=(\vec{p} f(\vec{r}, t)) e^{-i S / \hbar}</script> 因此有<script type="math/tex; mode=display">\frac{1}{2 m}\left[\vec{p}-\frac{q}{c} \vec{A}(\vec{r})\right]^{2} \psi_{0}(\vec{r}, t) e^{-i S/ \hbar}=\frac{1}{2 m}\left[p^{2} \psi_{0}(\vec{r}, t)\right] e^{-i S / \hbar}</script> 带入到方程中可以验证得到<br>综上所述，在H随时间变化的一般情况下我们有<script type="math/tex; mode=display">H(t) \sim \psi(\vec{r}, t)=\psi_{0}(\vec{v}, t) e^{-i S / \hbar}</script>其中<script type="math/tex; mode=display">S(\vec{r}, t)={- \frac{q}{c}\int_{\vec{r}_{0}}^{\vec{r}} \vec{A}(\vec{r}^{\prime}) d \vec{r}^{\prime}}+\int_{t_{0}}^{t} V\left(t^{\prime}\right) d t^{\prime}</script></li></ul><h1 id="AB-effect-1959"><a href="#AB-effect-1959" class="headerlink" title="AB effect(1959)"></a>AB effect(1959)</h1><p>如图<br><img src="/img_QM2/7.png" srcset="/img/loading.gif" alt="势能如图"></p><script type="math/tex; mode=display">\int_{\vec{r}_{0}}^{\vec{r}} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)+\int_{\vec{r}}^{\vec{r}_0} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)=\oint d r^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)=\iint_S d s^{\prime} \vec{B}\left(\vec{r}^{\prime}\right)={\Phi}</script><p>其中$\Phi$为磁通，当$\Phi\ne 0$时</p><script type="math/tex; mode=display">\int_{\vec{r}_{0}}^{\vec{r}} d \vec{r}^{\prime} \vec{A}(\vec{r}^{\prime}) \ne  \int_{\vec{r}}^{\vec{r}_0} d \vec{r}^{\prime} \vec{A}(\vec{r}^{\prime}</script><p>这一条式子是可以实验测量得到的。其意义在于$\vec{A}(\vec{r})$在量子力学中是可以观测的！</p><p>实验——<br><img src="/img_QM2/8.png" srcset="/img/loading.gif" alt="实验示意图"><br>实验使用中子束，这样中间的磁场不会对其波函数产生作用。</p><ul><li><p>$B=0$<br> 初始波函数分为$\psi_0 (\vec{r}, t) \sim \psi_1 (\vec{r}, t)+\psi_2 (\vec{r}, t)$为相干的，此时他们只会分别沿着$p_1$与$p_2$走</p><ul><li>在A-B-D路线中<script type="math/tex; mode=display">\left|\psi_{2}(\vec{r}, t)\right|\ll \left|\psi_{1}(\vec{r}, t)\right|</script></li><li>在A-C-D路线中<script type="math/tex; mode=display">\left|\psi_{1}(\vec{r}, t)\right|\ll \left|\psi_{2}(\vec{r}, t)\right|</script></li></ul></li><li><p>$B \ne 0$</p><script type="math/tex; mode=display">\psi(\vec{r}, t) =exp[\frac{iq}{\hbar c}\int_{p_1} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)]\psi_{1}(\vec{r}, t)+exp[\frac{iq}{\hbar c}\int_{p_2} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)]\psi_{2}(\vec{r}, t)</script><p> 所以</p><script type="math/tex; mode=display">\begin{aligned}\psi(\vec{r}, t) &=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)exp[\frac{iq}{\hbar c}(\int_{p_1}-\int_{p_2}) d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)]\\&=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)e^{\frac{i q}{\hbar c}\Phi}\end{aligned}</script><p> 因此</p><script type="math/tex; mode=display">|\psi(\vec{r}, t)|^{2}=\left|\psi_{1}\right|^{2}+\left|\psi_{2}\right|^{2}+2\left|\psi_{1}\psi_{2}\right| \cos \left[\varphi_{1}(\vec{r}, t)-\varphi_{2}(\vec{r},t)+\frac{q \Psi}{\hbar c}\right]</script><p> 其中$\varphi_1$与$\varphi_2$为初始相位<br> 此时我们测量粒子到达D点概率，可以发现一个相移，且这个相移的大小与中间的磁通量有关。</p></li></ul><h1 id="Electric-potential-AB-effect"><a href="#Electric-potential-AB-effect" class="headerlink" title="Electric potential AB effect"></a>Electric potential AB effect</h1><p>上一节的实验验证了磁势A对态的影响，接下来验证V对态的影响就显得十分顺其自然了<br><img src="/img_QM2/9.png" srcset="/img/loading.gif" alt="实验示意图"><br>在改实验设想中</p><script type="math/tex; mode=display">\begin{aligned}\psi(\vec{r}, t) &=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)exp\left[i[(\int_{p_1}-\int_{p_2}) d t^{\prime} V(t^{\prime})]/\hbar\right]\\&=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)e^{-i \Delta V \tau /\hbar}\end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\int_{p_1}V\left(t^{\prime}\right) d t^{\prime}=V_2 \tau \qquad \int_{p_2}V\left(t^{\prime}\right) d t^{\prime}=V_2 \tau</script><p>$V_1$为$p_1$路径上的电压，$V_2$为$p_2$路径上的电压而$\tau$为粒子通过电压区域的时间。<br>同上节的讨论，我们测量粒子到达终点的概率时可以发现一个大小与$\Delta V$有关的相移。</p><h1 id="Scalar-AB-experiment-1992"><a href="#Scalar-AB-experiment-1992" class="headerlink" title="Scalar AB experiment(1992)"></a>Scalar AB experiment(1992)</h1><p>上一节的实验在1992年实现了<br><img src="/img_QM2/10.png" srcset="/img/loading.gif" alt="实验示意图"><br>这个实验利用$V=-\vec{\mu} \vec{B}=-\mu_B \vec{\sigma}\vec{B}$来给粒子加上标势</p><p>最终粒子概率的相位变化为</p><script type="math/tex; mode=display">\Delta \phi=\Delta V \tau / \hbar=\frac{\sigma}{\hbar} \mu_B B \tau</script><p>其中$\sigma$为常数可以取$\pm 1$</p><h1 id="Gravitationally-induced-phase-1975"><a href="#Gravitationally-induced-phase-1975" class="headerlink" title="Gravitationally induced phase(1975)"></a>Gravitationally induced phase(1975)</h1><p>不光是电势，引力势能也是标势，也有人用引力势来做了相关实验<br><img src="/img_QM2/11.png" srcset="/img/loading.gif" alt="实验示意图"><br>这个实验中势能的变化为</p><script type="math/tex; mode=display">\Delta V=m g l_{2} \sin \alpha</script><p>其中$\alpha$为实验平面ABCD的仰角<br><img src="/img_QM2/12.png" srcset="/img/loading.gif" alt="实验示意图"><br>由此可知</p><script type="math/tex; mode=display">\Delta \phi=\frac{\Delta V \cdot T}{\hbar}=\frac{m g l_{2} \sin \alpha T}{\hbar}</script><p><img src="/img_QM2/13.png" srcset="/img/loading.gif" alt="实验示意图"><br>最后可以发现随着$\alpha$的变化相移会震荡</p>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>introduction to python</title>
    <link href="/2020/05/29/note/"/>
    <url>/2020/05/29/note/</url>
    
    <content type="html"><![CDATA[<h1 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h1><h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><ul><li>整型：(int)</li><li>字符串型：字符串是以单引号或双引号括起来的任意文本</li><li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写）</li><li>复数型：虚部的<code>i</code>换成了<code>j</code>。<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><strong>输入：</strong>\<br>使用input()函数获取键盘输入，使用int()进行类型转换<pre><code class="hljs Python">a = int(input(<span class="hljs-string">'a = '</span>))</code></pre>若为<code>a = input(&#39;a = &#39;)</code>则此时a为字符串</li></ul><p><strong>输出：</strong><br><pre><code class="hljs Python">a=<span class="hljs-number">1</span>print(<span class="hljs-string">"a = "</span>, a)</code></pre><br>输出为a=1<br><pre><code class="hljs Python">a = int(input(<span class="hljs-string">'a = '</span>))b = int(input(<span class="hljs-string">'b = '</span>))print(<span class="hljs-string">'%d + %d = %d'</span> % (a, b, a + b))</code></pre><br>对<code>print</code>的理解——使用占位符格式化输出的字符串<code>%d</code>中<code>d</code>可以是任意的字符，代表占位。\<br>但占位字符需保持一致.下述代码不能通过编译<br><pre><code class="hljs Python"><span class="hljs-string">'''</span><span class="hljs-string">错误示范</span><span class="hljs-string">'''</span>print(<span class="hljs-string">'%a + %b = %b'</span> % (a, b, a + b))</code></pre><br><strong>检查变量的类型：</strong><br><pre><code class="hljs Python"><span class="hljs-string">'''</span><span class="hljs-string">显示变量的数据类型</span><span class="hljs-string">'''</span>print(type(a))</code></pre><br><strong>变量转换的内置函数</strong></p><ul><li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code>：将一个字符串转换成浮点数。</li><li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>按照优先级从高到低的顺序列出了所有的运算符</li></ul><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> ,<code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> ,<code>+</code> ,<code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code>, <code>/</code>, <code>%</code> ,<code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> ,<code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code>, <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> ,`\</td><td>`</td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code>, <code>&lt;</code> ,<code>&gt;</code>, <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> ,<code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code> , <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> ,<code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code>, <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> ,<code>+=</code> ,<code>-=</code> ,<code>*=</code> ,<code>/=</code>, <code>%=</code>, <code>//=</code> ,<code>**=</code> ,<code>&amp;=</code>, `</td><td>=<code>,</code>^=<code>,</code>&gt;&gt;=<code>,</code>&lt;&lt;=`</td><td>（复合）赋值运算符</td></tr></tbody></table></div><h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><h2 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h2><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span><span class="hljs-string">分段函数求值</span><span class="hljs-string"></span><span class="hljs-string">        3x - 5  (x &gt; 1)</span><span class="hljs-string">f(x) =  x + 2   (-1 &lt;= x &lt;= 1)</span><span class="hljs-string">        5x + 3  (x &lt; -1)</span><span class="hljs-string"></span><span class="hljs-string">"""</span>x = float(input(<span class="hljs-string">'x = '</span>))<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:    y = <span class="hljs-number">3</span> * x - <span class="hljs-number">5</span><span class="hljs-keyword">elif</span> x &gt;= <span class="hljs-number">-1</span>:    y = x + <span class="hljs-number">2</span><span class="hljs-keyword">else</span>:    y = <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span>print(<span class="hljs-string">'f(%.2f) = %.2f'</span> % (x, y))</code></pre><br>Python中使用了缩进的方式来设置代码的层次结构，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。<br><pre><code class="hljs Python">x = float(input(<span class="hljs-string">'x = '</span>))<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:    y = <span class="hljs-number">3</span> * x - <span class="hljs-number">5</span><span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">-1</span>:        y = x + <span class="hljs-number">2</span>    <span class="hljs-keyword">else</span>:        y = <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span>print(<span class="hljs-string">'f(%.2f) = %.2f'</span> % (x, y))</code></pre><br><strong>补充</strong>\<br>1.使用random模块的randint函数生成指定范围的随机数来模拟<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint</code></pre><br>2.使用了<code>math</code>模块的<code>sqrt</code>函数来计算平方根。<br><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matha = float(input(<span class="hljs-string">'a = '</span>))b = float(input(<span class="hljs-string">'b = '</span>))c = float(input(<span class="hljs-string">'c = '</span>))<span class="hljs-keyword">if</span> a + b &gt; c <span class="hljs-keyword">and</span> a + c &gt; b <span class="hljs-keyword">and</span> b + c &gt; a:    print(<span class="hljs-string">'周长: %f'</span> % (a + b + c))    p = (a + b + c) / <span class="hljs-number">2</span>    area = math.sqrt(p * (p - a) * (p - b) * (p - c))    print(<span class="hljs-string">'面积: %f'</span> % (area))<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'不能构成三角形'</span>)</code></pre><br>3.Python内置的<code>abs()</code>函数取绝对值</p><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h2><p>明确的知道循环执行的次数或者要对一个容器进行迭代，推荐使用<code>for-in</code>循环。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span><span class="hljs-string">用for循环实现1~100求和</span><span class="hljs-string"></span><span class="hljs-string">"""</span>sum = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>):    sum += xprint(sum)</code></pre><br><strong>说明：</strong><code>range</code>类型\<br><code>range</code>可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的</p><ul><li><code>range(101)</code>可以产生一个0到100的整数序列。</li><li><code>range(1, 100)</code>可以产生一个1到99的整数序列。</li><li><code>range(1, 100, 2)</code>可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。</li></ul><p>注意：最后一位数不取。</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>要构造不知道具体循环次数的循环结构，推荐使用<code>while</code>循环。\<br><code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>循环继续，表达式的值为<code>False</code>循环结束。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span><span class="hljs-string">猜数字游戏</span><span class="hljs-string">计算机出一个1~100之间的随机数由人来猜</span><span class="hljs-string">计算机根据人猜的数字分别给出提示大一点/小一点/猜对了</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> randomanswer = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)counter = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    counter += <span class="hljs-number">1</span>    number = int(input(<span class="hljs-string">'请输入: '</span>))    <span class="hljs-keyword">if</span> number &lt; answer:        print(<span class="hljs-string">'大一点'</span>)    <span class="hljs-keyword">elif</span> number &gt; answer:        print(<span class="hljs-string">'小一点'</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">'恭喜你猜对了!'</span>)        <span class="hljs-keyword">break</span>print(<span class="hljs-string">'你总共猜了%d次'</span> % counter)<span class="hljs-keyword">if</span> counter &gt; <span class="hljs-number">7</span>:    print(<span class="hljs-string">'你的智商余额明显不足'</span>)</code></pre><br><strong>说明</strong>\<br>1.<code>answer = random.randint(1, 100)</code>的理解：调用<code>random</code>包的<code>randint</code>函数。不可以只写<code>answer =randint(1, 100)</code>。要想直接使用<code>randint</code>，开头需改为<code>from randint import random</code>\<br>2.<code>while True:</code>的理解：循环条件一直为true，循环一致进行。\<br>3.使用<code>break</code>关键字来提前终止循环，当条件成立时（esle）运行<code>break</code>循环中断。注意<code>break</code>只能终止它所在的那个循环（跳出循环）。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮（不终止循环）</p><p>补充 ：<code>#%%</code>开启交互模式</p><h2 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h2><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在Python中使用<code>def</code>关键字来定义函数，在函数名后面的圆括号中可以放置传递给函数的参数，函数执行完成后我们可以通过<code>return</code>关键字来返回一个值。</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span><span class="hljs-params">(num)</span>:</span>    <span class="hljs-string">"""</span><span class="hljs-string">    求阶乘</span><span class="hljs-string">    </span><span class="hljs-string">    :param num: 非负整数</span><span class="hljs-string">    :return: num的阶乘</span><span class="hljs-string">    """</span>    result = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>):        result *= n    <span class="hljs-keyword">return</span> resultm = int(input(<span class="hljs-string">'m = '</span>))n = int(input(<span class="hljs-string">'n = '</span>))<span class="hljs-comment"># 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span>print(factorial(m) // factorial(n) // factorial(m - n))</code></pre><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>在Python中，函数的参数可以有默认值，也支持使用可变参数。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>, c=<span class="hljs-number">0</span>)</span>:</span>    <span class="hljs-keyword">return</span> a + b + c<span class="hljs-comment"># 传递参数时可以不按照设定的顺序进行传递，变量的设定与位置无关</span>print(add(c=<span class="hljs-number">50</span>, a=<span class="hljs-number">100</span>, b=<span class="hljs-number">200</span>))</code></pre><br>对0个或多个参数进行加法运算<br><pre><code class="hljs Python"><span class="hljs-comment"># 在参数名前面的*表示args是一个可变参数</span><span class="hljs-comment"># 即在调用add函数时可以传入0个或多个参数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(*args)</span>:</span>    total = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> args:        total += val    <span class="hljs-keyword">return</span> totalprint(add())print(add(<span class="hljs-number">1</span>))print(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))print(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))print(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>))</code></pre><br>可以把<code>args</code>理解为一个数组，<code>val</code>从数组中按顺序取值</p><h2 id="用模块管理函数、"><a href="#用模块管理函数、" class="headerlink" title="用模块管理函数、"></a>用模块管理函数、</h2><p>在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义。\<br>解决方法：\<br>Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块就可以区分到底要使用的是哪个模块中的函数，代码如下所示。</p><p>module1.py</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'hello, world!'</span>)</code></pre><p>module2.py</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'goodbye, world!'</span>)</code></pre><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> module1 <span class="hljs-keyword">import</span> foo<span class="hljs-comment"># 输出hello, world!</span>foo()<span class="hljs-keyword">from</span> module2 <span class="hljs-keyword">import</span> foo<span class="hljs-comment"># 输出goodbye, world!</span>foo()</code></pre><p>也可以按照如下所示的方式来区分到底要使用哪一个<code>foo</code>函数。</p><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> module1 <span class="hljs-keyword">as</span> m1<span class="hljs-keyword">import</span> module2 <span class="hljs-keyword">as</span> m2m1.foo()m2.foo()</code></pre><p>但如果同时调用两个两次函数，后导入的函数还是会覆盖之前的函数，如：</p><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> module1 <span class="hljs-keyword">import</span> foo<span class="hljs-keyword">from</span> module2 <span class="hljs-keyword">import</span> foo<span class="hljs-comment"># 输出goodbye, world!</span>foo()</code></pre><p>需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，（即<code>import XXX</code>后就会执行函数中的命令，而印象后续操作）因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中：</p><p>module3.py</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span><span class="hljs-comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    print(<span class="hljs-string">'call foo()'</span>)    foo()    print(<span class="hljs-string">'call bar()'</span>)    bar()</code></pre><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> module3<span class="hljs-comment"># 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</span></code></pre><p><strong>说明：</strong><code>pass</code>是空语句，是为了保持程序结构的完整性。不做任何事情，一般用做占位语句。</p><h1 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h1><h2 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h2><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    str1 = <span class="hljs-string">'hello, world!'</span>    <span class="hljs-comment"># 通过len函数计算字符串的长度</span>    print(len(str1))  <span class="hljs-comment"># 13</span>    <span class="hljs-comment"># 获得字符串首字母大写的拷贝</span>    print(str1.capitalize())  <span class="hljs-comment"># Hello, world!</span>    <span class="hljs-comment"># 获得字符串变大写后的拷贝</span>    print(str1.upper())  <span class="hljs-comment"># HELLO, WORLD!</span>    <span class="hljs-comment"># 从字符串中查找子串所在位置</span>    print(str1.find(<span class="hljs-string">'or'</span>))  <span class="hljs-comment"># 8</span>    print(str1.find(<span class="hljs-string">'shit'</span>))  <span class="hljs-comment"># -1</span>    <span class="hljs-comment"># 与find类似但找不到子串时会引发异常</span>    <span class="hljs-comment"># print(str1.index('or'))</span>    <span class="hljs-comment"># print(str1.index('shit'))</span>    <span class="hljs-comment"># 检查字符串是否以指定的字符串开头</span>    print(str1.startswith(<span class="hljs-string">'He'</span>))  <span class="hljs-comment"># False</span>    print(str1.startswith(<span class="hljs-string">'hel'</span>))  <span class="hljs-comment"># True</span>    <span class="hljs-comment"># 检查字符串是否以指定的字符串结尾</span>    print(str1.endswith(<span class="hljs-string">'!'</span>))  <span class="hljs-comment"># True</span>    <span class="hljs-comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span>    print(str1.center(<span class="hljs-number">50</span>, <span class="hljs-string">'*'</span>))<span class="hljs-comment">#******************hello, world!*******************</span>    <span class="hljs-comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span>    print(str1.rjust(<span class="hljs-number">50</span>, <span class="hljs-string">' '</span>))<span class="hljs-comment">#                                     hello, world!</span>    str2 = <span class="hljs-string">'abc123456'</span>    <span class="hljs-comment"># 从字符串中取出指定位置的字符(下标运算)</span>    print(str2[<span class="hljs-number">2</span>])  <span class="hljs-comment"># c</span>    <span class="hljs-comment"># 字符串切片(从指定的开始索引到指定的结束索引)</span>    print(str2[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])  <span class="hljs-comment"># c12</span>    print(str2[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># c123456</span>    print(str2[<span class="hljs-number">2</span>::<span class="hljs-number">2</span>])  <span class="hljs-comment"># c246</span>    print(str2[::<span class="hljs-number">2</span>])  <span class="hljs-comment"># ac246</span>    print(str2[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 654321cba</span>    print(str2[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 45</span>    <span class="hljs-comment"># 检查字符串是否由数字构成</span>    print(str2.isdigit())  <span class="hljs-comment"># False</span>    <span class="hljs-comment"># 检查字符串是否以字母构成</span>    print(str2.isalpha())  <span class="hljs-comment"># False</span>    <span class="hljs-comment"># 检查字符串是否以数字和字母构成</span>    print(str2.isalnum())  <span class="hljs-comment"># True</span>    str3 = <span class="hljs-string">'  jackfrued@126.com '</span>    print(str3)    <span class="hljs-comment"># 获得字符串修剪左右两侧空格的拷贝</span>    print(str3.strip())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h2><ul><li>定义列表、使用下标访问列表元素以及添加和删除元素的操作。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">100</span>]    print(list1)<span class="hljs-comment">#[1, 3, 5, 7, 100]</span>    list2 = [<span class="hljs-string">'hello'</span>] * <span class="hljs-number">5</span>    print(list2)<span class="hljs-comment">#['hello', 'hello', 'hello', 'hello', 'hello']</span>    <span class="hljs-comment"># 计算列表长度(元素个数)</span>    print(len(list1))<span class="hljs-comment">#5</span>    <span class="hljs-comment"># 下标(索引)运算</span>    print(list1[<span class="hljs-number">0</span>])<span class="hljs-comment">#1</span>    print(list1[<span class="hljs-number">4</span>])<span class="hljs-comment">#100</span>    <span class="hljs-comment"># print(list1[5])  # IndexError: list index out of range</span>    print(list1[<span class="hljs-number">-1</span>])<span class="hljs-comment">#100</span>    print(list1[<span class="hljs-number">-3</span>])<span class="hljs-comment">#5</span>    list1[<span class="hljs-number">2</span>] = <span class="hljs-number">300</span>    print(list1)<span class="hljs-comment">#[1, 3, 300, 7, 100]</span>    <span class="hljs-comment"># 添加元素</span>    list1.append(<span class="hljs-number">200</span>)<span class="hljs-comment">#在列表后添加</span>    list1.insert(<span class="hljs-number">1</span>, <span class="hljs-number">400</span>)<span class="hljs-comment">#在列表前添加</span>    list1 += [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>]<span class="hljs-comment">#在后添加</span>    print(list1)<span class="hljs-comment">#[1, 400, 3, 300, 7, 100, 200, 1000, 2000]</span>    print(len(list1))<span class="hljs-comment">#9</span>    <span class="hljs-comment"># 删除元素</span>    list1.remove(<span class="hljs-number">3</span>)    <span class="hljs-keyword">if</span> <span class="hljs-number">1234</span> <span class="hljs-keyword">in</span> list1:        list1.remove(<span class="hljs-number">1234</span>)    <span class="hljs-keyword">del</span> list1[<span class="hljs-number">0</span>]    print(list1)<span class="hljs-comment">#[400, 300, 7, 100, 200, 1000, 2000]</span>    <span class="hljs-comment"># 清空列表元素</span>    list1.clear()    print(list1)<span class="hljs-comment">#[]</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li><li>列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    fruits = [<span class="hljs-string">'grape'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'strawberry'</span>, <span class="hljs-string">'waxberry'</span>]    fruits += [<span class="hljs-string">'pitaya'</span>, <span class="hljs-string">'pear'</span>, <span class="hljs-string">'mango'</span>]    <span class="hljs-comment"># 循环遍历列表元素</span>    <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits:        print(fruit.title(), end=<span class="hljs-string">' '</span>)<span class="hljs-comment">#title函数使所有字母开头大写</span>    print()<span class="hljs-comment">#Grape Apple Strawberry Waxberry Pitaya Pear Mango </span>    <span class="hljs-comment"># 列表切片</span>    fruits2 = fruits[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]    print(fruits2)    <span class="hljs-comment"># fruit3 = fruits  # 没有复制列表只创建了新的引用</span>    <span class="hljs-comment"># 可以通过完整切片操作来复制列表</span>    fruits3 = fruits[:]    print(fruits3)    fruits4 = fruits[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>]    print(fruits4)    <span class="hljs-comment"># 可以通过反向切片操作来获得倒转后的列表的拷贝</span>    fruits5 = fruits[::<span class="hljs-number">-1</span>]    print(fruits5)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li></ul><ol><li>title函数使所有字母开头大写</li></ol><ul><li>列表的排序操作。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    list1 = [<span class="hljs-string">'orange'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'zoo'</span>, <span class="hljs-string">'internationalization'</span>, <span class="hljs-string">'blueberry'</span>]    list2 = sorted(list1)    <span class="hljs-comment"># sorted函数返回列表排序后的拷贝不会修改传入的列表</span>    <span class="hljs-comment"># 函数的设计就应该像sorted函数一样尽可能不产生副作用</span>    list3 = sorted(list1, reverse=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span>    list4 = sorted(list1, key=len)    print(list1)<span class="hljs-comment">#['orange', 'apple', 'zoo'，'internationalization', 'blueberry']</span>    print(list2)<span class="hljs-comment">#['apple', 'blueberry', 'internationalization', 'orange', 'zoo']</span>    print(list3)<span class="hljs-comment">#['zoo', 'orange', 'internationalization', 'blueberry', 'apple']</span>    print(list4)<span class="hljs-comment">#['zoo', 'apple', 'orange', 'blueberry', 'internationalization']</span>    <span class="hljs-comment"># 给列表对象发出排序消息直接在列表对象上进行排序</span>    list1.sort(reverse=<span class="hljs-literal">True</span>)    print(list1)<span class="hljs-comment">#['zoo', 'orange', 'internationalization', 'blueberry', 'apple']</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li><li>使用列表的生成式语法来创建列表<pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    f = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]    print(f)    f = [x + y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-string">'ABCDE'</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-string">'1234567'</span>]    print(f)    <span class="hljs-comment"># 用列表的生成表达式语法创建列表容器</span>    <span class="hljs-comment"># 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span>    f = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)]    print(sys.getsizeof(f))  <span class="hljs-comment"># 查看对象占用内存的字节数</span>    print(f)    <span class="hljs-comment"># 请注意下面的代码创建的不是一个列表而是一个生成器对象</span>    <span class="hljs-comment"># 通过生成器可以获取到数据但它不占用额外的空间存储数据</span>    <span class="hljs-comment"># 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span>    f = (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>))    print(sys.getsizeof(f))  <span class="hljs-comment"># 相比生成式生成器不占用存储数据的空间</span>    print(f)    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> f:        print(val)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li><li>通过<code>yield</code>关键字将一个普通函数改造成生成器函数。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span>:</span>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n):        a, b = b, a + b        <span class="hljs-keyword">yield</span> a<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> fib(<span class="hljs-number">20</span>):        print(val)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h2>Python 的元组与列表类似，不同之处在于元组的元素不能修改</li></ul><p>定义和使用元组。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 定义元组</span>    t = (<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">'四川成都'</span>)    print(t)    <span class="hljs-comment"># 获取元组中的元素</span>    print(t[<span class="hljs-number">0</span>])    print(t[<span class="hljs-number">3</span>])    <span class="hljs-comment"># 遍历元组中的值</span>    <span class="hljs-keyword">for</span> member <span class="hljs-keyword">in</span> t:        print(member)    <span class="hljs-comment"># 重新给元组赋值</span>    <span class="hljs-comment"># t[0] = '王大锤'  # TypeError</span>    <span class="hljs-comment"># 变量t重新引用了新的元组原来的元组将被垃圾回收</span>    t = (<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">'云南昆明'</span>)    print(t)    <span class="hljs-comment"># 将元组转换成列表</span>    person = list(t)    print(person)    <span class="hljs-comment"># 列表是可以修改它的元素的</span>    person[<span class="hljs-number">0</span>] = <span class="hljs-string">'李小龙'</span>    person[<span class="hljs-number">1</span>] = <span class="hljs-number">25</span>    print(person)    <span class="hljs-comment"># 将列表转换成元组</span>    fruits_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]    fruits_tuple = tuple(fruits_list)    print(fruits_tuple)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><br>元组的优势：</p><ol><li>元组中的元素是无法修改的。</li><li>元组在创建时间和占用的空间上面都优于列表。<h2 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h2>Python中的集合不允许有重复元素，而且可以进行交集、并集、差集等运算。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    set1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;    print(set1)<span class="hljs-comment">#&#123;1, 2, 3&#125;</span>    print(<span class="hljs-string">'Length ='</span>, len(set1))<span class="hljs-comment">#Length = 3</span>    set2 = set(range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))    print(set2)<span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span>    set1.add(<span class="hljs-number">4</span>)    set1.add(<span class="hljs-number">5</span>)    set2.update([<span class="hljs-number">11</span>, <span class="hljs-number">12</span>])    print(set1)<span class="hljs-comment">#&#123;1, 2, 3, 4, 5&#125;</span>    print(set2)<span class="hljs-comment">#&#123;1, 2, 3, 6, 7, 8, 9, 11, 12&#125;</span>    set2.discard(<span class="hljs-number">5</span>)    <span class="hljs-comment"># remove的元素如果不存在会引发KeyError</span>    <span class="hljs-keyword">if</span> <span class="hljs-number">4</span> <span class="hljs-keyword">in</span> set2:        set2.remove(<span class="hljs-number">4</span>)    print(set2)    <span class="hljs-comment"># 遍历集合容器</span>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> set2:        print(elem ** <span class="hljs-number">2</span>, end=<span class="hljs-string">' '</span>)    print()    <span class="hljs-comment"># 将元组转换成集合</span>    set3 = set((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>))    print(set3.pop())    print(set3)    <span class="hljs-comment"># 集合的交集、并集、差集、对称差运算</span>    print(set1 &amp; set2)    <span class="hljs-comment"># print(set1.intersection(set2))</span>    print(set1 | set2)    <span class="hljs-comment"># print(set1.union(set2))</span>    print(set1 - set2)    <span class="hljs-comment"># print(set1.difference(set2))</span>    print(set1 ^ set2)    <span class="hljs-comment"># print(set1.symmetric_difference(set2))</span>    <span class="hljs-comment"># 判断子集和超集</span>    print(set2 &lt;= set1)    <span class="hljs-comment"># print(set2.issubset(set1))</span>    print(set3 &lt;= set1)    <span class="hljs-comment"># print(set3.issubset(set1))</span>    print(set1 &gt;= set2)    <span class="hljs-comment"># print(set1.issuperset(set2))</span>    print(set1 &gt;= set3)    <span class="hljs-comment"># print(set1.issuperset(set3))</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h2>字典是另一种可变容器模型，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    scores = &#123;<span class="hljs-string">'骆昊'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'白元芳'</span>: <span class="hljs-number">78</span>, <span class="hljs-string">'狄仁杰'</span>: <span class="hljs-number">82</span>&#125;    <span class="hljs-comment"># 通过键可以获取字典中对应的值</span>    print(scores[<span class="hljs-string">'骆昊'</span>])    print(scores[<span class="hljs-string">'狄仁杰'</span>])    <span class="hljs-comment"># 对字典进行遍历(遍历的其实是键再通过键取对应的值)</span>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> scores:        print(<span class="hljs-string">'%s\t---&gt;\t%d'</span> % (elem, scores[elem]))    <span class="hljs-comment"># 更新字典中的元素</span>    scores[<span class="hljs-string">'白元芳'</span>] = <span class="hljs-number">65</span>    scores[<span class="hljs-string">'诸葛王朗'</span>] = <span class="hljs-number">71</span>    scores.update(冷面=<span class="hljs-number">67</span>, 方启鹤=<span class="hljs-number">85</span>)    print(scores)    <span class="hljs-keyword">if</span> <span class="hljs-string">'武则天'</span> <span class="hljs-keyword">in</span> scores:        print(scores[<span class="hljs-string">'武则天'</span>])    print(scores.get(<span class="hljs-string">'武则天'</span>))    <span class="hljs-comment"># get方法也是通过键获取对应的值但是可以设置默认值</span>    print(scores.get(<span class="hljs-string">'武则天'</span>, <span class="hljs-number">60</span>))    <span class="hljs-comment"># 删除字典中的元素</span>    print(scores.popitem())    print(scores.popitem())    print(scores.pop(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">100</span>))    <span class="hljs-comment"># 清空字典</span>    scores.clear()    print(scores)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li></ol><h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>在Python中可以使用<code>class</code>关键字定义类。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span>    <span class="hljs-comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self.name = name        self.age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, course_name)</span>:</span>        print(<span class="hljs-string">'%s正在学习%s.'</span> % (self.name, course_name))    <span class="hljs-comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span>    <span class="hljs-comment"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">watch_movie</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self.age &lt; <span class="hljs-number">18</span>:            print(<span class="hljs-string">'%s只能观看《熊出没》.'</span> % self.name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s正在观看岛国爱情大电影.'</span> % self.name)</code></pre></p><blockquote><p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。\<br><code>self</code>不可少，且必须放在其他形参前面。</p><h2 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h2><p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 创建学生对象并指定姓名和年龄</span>    stu1 = Student(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>)    <span class="hljs-comment"># 给对象发study消息</span>    stu1.study(<span class="hljs-string">'Python程序设计'</span>)    <span class="hljs-comment"># 给对象发watch_av消息</span>    stu1.watch_movie()    stu2 = Student(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">15</span>)    stu2.study(<span class="hljs-string">'思想品德'</span>)    stu2.watch_movie()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()    <span class="hljs-comment">#output:</span>    <span class="hljs-comment">#骆昊正在学习Python程序设计.</span>    <span class="hljs-comment">#骆昊正在观看岛国爱情大电影.</span>    <span class="hljs-comment">#王大锤正在学习思想品德.</span>    <span class="hljs-comment">#王大锤只能观看《熊出没》.</span></code></pre><br>方法前面的后缀为<code>self</code>的值</p><h2 id="访问可见性问题"><a href="#访问可见性问题" class="headerlink" title="访问可见性问题"></a>访问可见性问题</h2><p>在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, foo)</span>:</span>        self.__foo = foo    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bar</span><span class="hljs-params">(self)</span>:</span>        print(self.__foo)        print(<span class="hljs-string">'__bar'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    test = Test(<span class="hljs-string">'hello'</span>)    <span class="hljs-comment"># AttributeError（报错）: 'Test' object has no attribute '__bar'</span>    test.__bar()    <span class="hljs-comment"># AttributeError: 'Test' object has no attribute '__foo'</span>    print(test.__foo)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><br>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, foo)</span>:</span>        self.__foo = foo    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bar</span><span class="hljs-params">(self)</span>:</span>        print(self.__foo)        print(<span class="hljs-string">'__bar'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    test = Test(<span class="hljs-string">'hello'</span>)    test._Test__bar()    print(test._Test__foo)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre></p></blockquote><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”</p><h2 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h2><p>如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self._name = name        self._age = age    <span class="hljs-comment"># 访问器 - getter方法</span><span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._name    <span class="hljs-comment"># 访问器 - getter方法</span><span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._age    <span class="hljs-comment"># 修改器 - setter方法</span><span class="hljs-meta">    @age.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>        self._age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self._age &lt;= <span class="hljs-number">16</span>:            print(<span class="hljs-string">'%s正在玩飞行棋.'</span> % self._name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s正在玩斗地主.'</span> % self._name)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    person = Person(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">12</span>)    person.play()    person.age = <span class="hljs-number">22</span>    person.play()    <span class="hljs-comment"># person.name = '白元芳'  # AttributeError: can't set attribute</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></p><h2 id="slots魔法"><a href="#slots魔法" class="headerlink" title="slots魔法"></a><strong>slots</strong>魔法</h2><p>Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。\<br>但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><p>?<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-comment"># 限定Person对象只能绑定_name, _age和_gender属性</span>    __slots__ = (<span class="hljs-string">'_name'</span>, <span class="hljs-string">'_age'</span>, <span class="hljs-string">'_gender'</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self._name = name        self._age = age<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._name<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._age<span class="hljs-meta">    @age.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>        self._age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self._age &lt;= <span class="hljs-number">16</span>:            print(<span class="hljs-string">'%s正在玩飞行棋.'</span> % self._name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s正在玩斗地主.'</span> % self._name)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    person = Person(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">22</span>)    person.play()    person._gender = <span class="hljs-string">'男'</span>    <span class="hljs-comment"># AttributeError: 'Person' object has no attribute '_is_gay'</span>    <span class="hljs-comment"># person._is_gay = True</span></code></pre></p><h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在<strong>类中的方法并不需要都是对象方法</strong>。<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, a, b, c)</span>:</span>        self._a = a        self._b = b        self._c = c<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(a, b, c)</span>:</span>        <span class="hljs-keyword">return</span> a + b &gt; c <span class="hljs-keyword">and</span> b + c &gt; a <span class="hljs-keyword">and</span> a + c &gt; b    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._a + self._b + self._c    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span><span class="hljs-params">(self)</span>:</span>        half = self.perimeter() / <span class="hljs-number">2</span>        <span class="hljs-keyword">return</span> sqrt(half * (half - self._a) *                    (half - self._b) * (half - self._c))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    a, b, c = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>    <span class="hljs-comment"># 静态方法和类方法都是通过给类发消息来调用的</span>    <span class="hljs-keyword">if</span> Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)        print(t.perimeter())        <span class="hljs-comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span>        <span class="hljs-comment"># print(Triangle.perimeter(t))</span>        print(t.area())        <span class="hljs-comment"># print(Triangle.area(t))</span>    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">'无法构成三角形.'</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><br>Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象\<br>（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象。<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time, localtime, sleep<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-string">"""数字时钟"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hour=<span class="hljs-number">0</span>, minute=<span class="hljs-number">0</span>, second=<span class="hljs-number">0</span>)</span>:</span>        self._hour = hour        self._minute = minute        self._second = second<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span><span class="hljs-params">(cls)</span>:</span>        ctime = localtime(time())        <span class="hljs-keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""走字"""</span>        self._second += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> self._second == <span class="hljs-number">60</span>:            self._second = <span class="hljs-number">0</span>            self._minute += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> self._minute == <span class="hljs-number">60</span>:                self._minute = <span class="hljs-number">0</span>                self._hour += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> self._hour == <span class="hljs-number">24</span>:                    self._hour = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""显示时间"""</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'%02d:%02d:%02d'</span> % \               (self._hour, self._minute, self._second)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 通过类方法创建对象并获取系统时间</span>    clock = Clock.now()    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        print(clock.show())        sleep(<span class="hljs-number">1</span>)        clock.run()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>类和类之间的关系有三种：is-a、has-a和use-a关系。</p><ul><li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接<strong>继承</strong>下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。</p><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-string">"""人"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self._name = name        self._age = age<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._name<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._age<span class="hljs-meta">    @age.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>        self._age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'%s正在愉快的玩耍.'</span> % self._name)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">watch_av</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self._age &gt;= <span class="hljs-number">18</span>:            print(<span class="hljs-string">'%s正在观看爱情动作片.'</span> % self._name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s只能观看《熊出没》.'</span> % self._name)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(Person)</span>:</span>    <span class="hljs-string">"""学生"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, grade)</span>:</span>        super().__init__(name, age)        self._grade = grade    <span class="hljs-comment">#继承Person类</span><span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._grade<span class="hljs-meta">    @grade.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span><span class="hljs-params">(self, grade)</span>:</span>        self._grade = grade    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, course)</span>:</span>        print(<span class="hljs-string">'%s的%s正在学习%s.'</span> % (self._grade, self._name, course))<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(Person)</span>:</span>    <span class="hljs-string">"""老师"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, title)</span>:</span>        super().__init__(name, age)        self._title = title<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._title<span class="hljs-meta">    @title.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self, title)</span>:</span>        self._title = title    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teach</span><span class="hljs-params">(self, course)</span>:</span>        print(<span class="hljs-string">'%s%s正在讲%s.'</span> % (self._name, self._title, course))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    stu = Student(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'初三'</span>)    stu.study(<span class="hljs-string">'数学'</span>)    stu.watch_av()    t = Teacher(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>, <span class="hljs-string">'老叫兽'</span>)    t.teach(<span class="hljs-string">'Python程序设计'</span>)    t.watch_av()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法<strong>重写</strong>（override）。</p><p>通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是<strong>多态</strong>（poly-morphism）<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span><span class="hljs-params">(object, metaclass=ABCMeta)</span>:</span>    <span class="hljs-string">"""宠物"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nickname)</span>:</span>        self._nickname = nickname<span class="hljs-meta">    @abstractmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""发出声音"""</span>        <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><span class="hljs-params">(Pet)</span>:</span>    <span class="hljs-string">"""狗"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'%s: 汪汪汪...'</span> % self._nickname)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span><span class="hljs-params">(Pet)</span>:</span>    <span class="hljs-string">"""猫"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'%s: 喵...喵...'</span> % self._nickname)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    pets = [Dog(<span class="hljs-string">'旺财'</span>), Cat(<span class="hljs-string">'凯蒂'</span>), Dog(<span class="hljs-string">'大黄'</span>)]    <span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> pets:        pet.make_voice()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><br>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p>]]></content>
    
    
    <categories>
      
      <category>computer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QMNG</title>
    <link href="/2020/05/29/qrng/"/>
    <url>/2020/05/29/qrng/</url>
    
    <content type="html"><![CDATA[<h1 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h1><p><strong>问题</strong></p><ul><li>随机性的来源？<br>随机性检验？or量子力学假设？认为QRNG为真随机数的依据（逻辑链）？</li></ul><h1 id="量子力学"><a href="#量子力学" class="headerlink" title="量子力学"></a>量子力学</h1><h2 id="EPR佯谬"><a href="#EPR佯谬" class="headerlink" title="EPR佯谬"></a>EPR佯谬</h2><p>考虑一个$\pi^0$介子到电子——正电子的衰变：</p><script type="math/tex; mode=display">\pi^0 \rightarrow e^- +e^+</script><p>由于$\pi^0$的自旋为0，由角动量守恒，要求电子与正电子对处在单态组态。</p><p>EPR实验的BOHM方案：一个静止$\pi^0$介子衰变为电子-正电子对。<br><strong><script type="math/tex">\frac{1}{\sqrt{2}}(\uparrow_-\downarrow+\uparrow_+\downarrow_-）</script></strong></p><p>如果电子的自旋向上，正电子的自旋必须向下，反之亦然。在任何一个特定的π 0 介子衰变中，量子力学无法预测会得到哪一种自旋组合，但是它明确指出电子、正电子自旋的测量是 相关的，平均说来得到每一种组合的几率是 1/2。</p><p>定域性：任何<strong>影响</strong>的传播速度都不能超过光速</p><p>结论：波函数的坍塌是瞬时的！</p><h2 id="Bell定理"><a href="#Bell定理" class="headerlink" title="Bell定理"></a>Bell定理</h2><p>推广实验：<br>Bell 让两个探测器都能独立的转动。第一个测量电子自旋沿一个单位矢量<strong>a</strong>的分量， 第二个测量正电子自旋沿另一个单位矢量<strong>b</strong>的分量。<br>简单起见，以$h/2$为单位记录自旋;则每个探测器沿指定方向记录+1(自旋向上)或-1(自旋向下)<br>测量结果<br><img src="/img/1.png" srcset="/img/loading.gif" alt=""></p><p><strong>计算自旋乘积的平均值</strong>$P(a,b)$（量子力学结论）<br>对任意的指向，由量子力学有</p><script type="math/tex; mode=display">P(a,b)=-a\cdot b</script><p>特别的：</p><ul><li>如果两个探测器方向是平行$(b=a)$<script type="math/tex; mode=display">P(a,a)=-1</script></li><li>如果安排探测器方向反平行$(b=-a)$<script type="math/tex; mode=display">P(a,-a)=1</script></li></ul><p><strong>Bell不等式</strong>（隐变量结论）</p><ul><li>假设电子，正电子体系的“完整”态是由隐变量 λ 表征的( λ<br>从一个衰变到下一个的变化是我们不知也不可控制的)。</li><li>假设电子测量的结果是独立于正电子探测器指向( b )的——这个指向可以在对电子马上要进行测量之前由试验者选择， 使得指向选择的信息无法在电子测量之前传到电子。(这就是<strong>定域性假设</strong>。)</li><li>设函数$A(a,\lambda)$给出电子测量结果，函数$B(b,\lambda)$给出正电子测量结果<br>$A(a,\lambda)=\pm1 $         $B(b,\lambda)=\pm1$<br>当探测器指向一致时，有完全（反）相关<script type="math/tex">A(a,\lambda)=-B(b,\lambda)</script>测量乘积的平均值为<script type="math/tex">P(a,b)=-\int\rho(\lambda) A(a,\lambda) B(b,\lambda) d \lambda</script>其中为隐变量的几率密度，有$\int \rho d\lambda=1$，不同的理论有不同的<br>消去B有<script type="math/tex">P(a,b)=-\int\rho(\lambda) A(a,\lambda) A(b,\lambda) d \lambda</script><br>对任意的单位矢量c，有<script type="math/tex">P(a,b)-P(a,c)=-\int \rho(\lambda)[A(a,\lambda)A(b,\lambda)-A(a,\lambda)A(c,\lambda)]d\lambda</script><script type="math/tex; mode=display">=-\int \rho(\lambda)[1-A(b,\lambda)A(c,\lambda)]A(a,\lambda)A(b,\lambda)d\lambda</script>(<em>$[A(b,\lambda)]^2 =1$</em>)<br>又因为$-1\leq [A(a,\lambda)B(b,\lambda)]\leq +1$，所以$\rho(\lambda)[1-A(b,\lambda)A(c,\lambda)]\ge 0 $</li></ul><script type="math/tex; mode=display">|P(a,b)-P(a,c)|\leq \int \rho (\lambda)[1-A(b,\lambda)A(c,\lambda)]d\lambda</script><p>即<strong><script type="math/tex">|P(a,b)-P(a,c)|\leq 1+P(b,c)</script></strong></p><p>可以计算出，Bell不等式与量子力学的结论矛盾。</p><hr><h1 id="量子随机数"><a href="#量子随机数" class="headerlink" title="量子随机数"></a>量子随机数</h1><h2 id="真随机数基础知识"><a href="#真随机数基础知识" class="headerlink" title="真随机数基础知识"></a>真随机数基础知识</h2><p>定义：<br>随机数是不存在<strong>周期性</strong>或明显的规律的非确定<strong>时序</strong>（时序特性），满足一定的统计规律（统计特性）<br>理想二进制随机序列的特性：</p><ul><li><strong>统计均匀性</strong>出现0和1的概率为均匀分布即<script type="math/tex">p(x_i)=\frac{1}{2}</script>其中$x_i =0,1$<br>扩展到N进制，则出现0，1，2，…，N-1的概率为均匀分布，即<script type="math/tex">p(x_i)=\frac{1}{N}</script></li><li><strong>相互无关性</strong>每一位信息与序列中其余的信息之间没有关联，使用<em>自相关系数</em>表示<script type="math/tex">a_k= \delta[k]</script>    $k\in(-\infty,+\infty)$     ,$k\in Z$（没有周期性）</li><li><strong>不可预测性</strong>无法以超过$p(x<em>i)=0.5$的精确度向前（后）预测产生的随机信息$P(x_i)=P(x_i|x</em>{i-m}x<em>{i-m+1}…x</em>{i-1})$,$P(x<em>i)=P(x_i|x</em>{i+m}x<em>{i+m-1}…x</em>{i+1})$</li><li><strong>不可重复性</strong>无法在有限的时间内产生完全相同的随机序列</li></ul><h2 id="真随机数发生器的设计"><a href="#真随机数发生器的设计" class="headerlink" title="真随机数发生器的设计"></a>真随机数发生器的设计</h2><h3 id="量子随机源"><a href="#量子随机源" class="headerlink" title="量子随机源"></a>量子随机源</h3><p> <strong>离散型随机源</strong>例子——单光子源。优点：简单，好实现<br>实际方案为：将激光进行衰减，使脉冲的平均光子数$\mu$降到单光子数量级（准单光子源）。</p><ul><li>空间分辨特性：单光子对路径选择的随机性</li><li>时间分辨特性：在相干时间内对单光子进行测量，响应时间具有随机性<br>将脉冲的相干态以Fock态$|n&gt;$展开<script type="math/tex; mode=display">|a>=e^{-|a|^2/2}\sum_{n=0}^{\infty}\frac{a^n}{n!}|n></script>相干态的光子数分布符合柏松分布：<script type="math/tex">p(n)=<n|a><a|n>=\frac{<n>^n e^{-<n>}}{n!}</script>其中$<n>=|a|^2$为平均光子数<br>当通过衰减器后平均光子数为$\lambda$探测器效率为$\eta$<script type="math/tex; mode=display">p(n)=\frac{<\eta \lambda>^n e^{-<\eta \lambda>}}{n!}</script>此时平均光子数为$\eta \lambda$，且通过衰减器之后仍未泊松分布。<br>故二阶相关系数为$g^{(2)}(0)=1$?各个脉冲之间无聚束（Bunchin）也无（Anti—Bunchi）？</li></ul><p><strong>连续性随机源</strong>例子——激光相位噪声，放大自发辐射噪声，真空散粒噪声。优点：数据多，快。<br>  统计指标——平均值，方差，平均强度<br>对随机信号$x(t)$</p><p>统计性质——</p><ul><li><strong>概率密度分布函数</strong><script type="math/tex; mode=display">p(x)=\lim_{\Delta x\to0}\frac{P(x(t)\in (x,x+\Delta x))}{\Delta x}</script>与时序无关，描述的是信号取值的分布</li><li><strong>功率谱密度函数</strong><script type="math/tex; mode=display">G(f)=\lim_{\Delta f\to 0}\frac{\Psi_x^2(f,f+\Delta f)}{\Delta f }</script>信号的功率谱密度函数与自相关系数互为Fourier变换关系（Wiener—Khintchine定理），用来描述噪声信号的相干性。<br> （补充）</li></ul><h3 id="探测与采样"><a href="#探测与采样" class="headerlink" title="探测与采样"></a>探测与采样</h3><h4 id="器件"><a href="#器件" class="headerlink" title="器件"></a>器件</h4><p>对离散型真随机数产生方案中，探测方式为单光子探测器。可以直接作为数字化的随机序列输出</p><p>对连续型真随机数，探测结果为连续的，如光电传感器。需要将连续型结果转化为离散型的二进制信息。<br>采集器分别有：</p><ul><li><strong>比较器</strong></li></ul><p><img src="/img/2.png" srcset="/img/loading.gif" alt=""><br>预先设置调谐的阈值电平$U_{th}(t)$，比较探测信号与阈值电平的大小输出二进制信息<br>优点：结构简单，可以达到GHz的带宽与GSa/s的采样频率（不快）<br>缺点：1.速度慢，每次只能输出1bit的信息。2.阈值电平设置问题，会产生非均匀分布，要使用von Neumann方法消除偏差，更慢！</p><ul><li><strong>模-数转化器</strong></li></ul><p><img src="/img/3.png" srcset="/img/loading.gif" alt=""><br>改良的比较器，有多个阈值和一个前置滤波器。输出的信号通过具有较大带宽$B_{pre}$的前置滤波器（为使探测模块的信号采样不失真），之后逐级与阈值比较，输出二进制信号。<br>模-数转化器最大允许的采样速率一般可以大于器件自身的采样速率——“过采样”，合理使用过采样可以提速。<br>优点：速度快，好应用</p><ul><li><strong>数字示波器</strong><br>多级模-数转化器<br>优点：一体化。缺点：功率体积太大</li></ul><h4 id="采样速率与采样精度的影响"><a href="#采样速率与采样精度的影响" class="headerlink" title="采样速率与采样精度的影响"></a>采样速率与采样精度的影响</h4><p>采样速率与采样精度会对随机数发生器的输出产生影响。<br>        原始序列产生速率=采样速率*采样精度<br>单位：采样速率为个数/秒（Sa/s），采样精度为比特（bit）</p><ul><li><strong>采样速率</strong><br>实际过程中，不是采样速率越大越好。<br>由于噪声功率谱密度函数与自相关函数互为傅立叶变化关系，其参数——噪声功率谱的线宽与信号的相干时间，二者互为倒数。<br><em>这意味着</em>：采样速率越大数据中的相关性也越大。同时采样速率过快也会使后处理中最小熵下降，使用m-LSB时要舍弃更多的数据。<br>选择采样速率的操作：通过采样后信号的熵估算，平衡采样速率与相关性。使后处理出来的数据在可靠的基础上最多</li><li><strong>采样精度</strong>采样精度由采集器决定<br>采样精度越高，就可以更精准的描述信号中的随机性，有效信息（每一个采样信号的信息量）也越大。模-数转化器有8、10、12bit的精度，一般为8bit。</li></ul><p><img src="/img/4.png" srcset="/img/loading.gif" alt=""></p><p>对一个高斯分布<script type="math/tex">p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-x^2/2\sigma^2}</script>，其信息熵只与方差有关<script type="math/tex">H(x)=-\int_{-\infty}^{\infty} p(x) log_2 p(x) dx=\frac{1}{2} log_2 2\pi e\sigma^2</script><br>采样精度提高后信号的分布函数方差更接近随机数方差。<br>当然，采样精度也不是越大越好。<br>在采样速率对于经典噪声与量子噪声都不是“过采样”时继续提高采样精度，量子与经典噪声都会等幅度的增加划分。因此，提高采样精度并不可以提高最终序列的产生速率，反而增加了后处理的难度。</p><h3 id="算法后处理"><a href="#算法后处理" class="headerlink" title="算法后处理"></a>算法后处理</h3><p>目的：提高采样速率</p><ol><li><strong>von Neumann方法</strong><br>重新定义联合事件：</li></ol><ul><li>连续两个bit位出现10的组合，称为新bit<strong>1</strong></li><li>连续两个bit位出现01的组合，称为新bit<strong>0</strong></li><li>其他全部舍弃（00，11）<br>作用：无论原始数据有何偏差，都可以使处理后的序列统计分布均匀$P(01)=P(10)$<br>缺点：产生速率损失大，速率也不稳定。输出序列和输入序列的长度比为$(1/4-e(n)^2)$，$e(n)^2$为原始数据的bias。</li></ul><ol><li><strong>逻辑异或（Exclusive OR）操作</strong><br>任意两个bit位$A_J$，$A_i$可以视为独立同分布，通过异或操作$B=A_i \oplus A_j$得到概率分布为<script type="math/tex; mode=display">P(B)=P(A_i\oplus A_j)=P(|A_i - A_j|)=P(A_i)P(A_j)</script>由于$A_J$，$A_i$分布相同，则可以将任意分布转化为对阵分布<br><img src="/img/5.png" srcset="/img/loading.gif" alt=""><br>异或操作：1.每个比特与后续数据进行异或操作，且每个bit只用一次<br> 2.每个比特与后续数据进行异或操作</li></ol><p><img src="/img/6.png" srcset="/img/loading.gif" alt=""></p><p>作用：1.改善统计分布，减小数据采集时引入的经典bias。<br>    2.具有较高的输入/输出比（1or1/2）<br><img src="/img/7.png" srcset="/img/loading.gif" alt=""><br>缺点：引入了一定的相关性与经典信息</p><ol><li><strong>最低有效位（m—LSB）操作</strong><br>保留每一次采样信号的m比特最低有效位。<br><img src="/img/8.png" srcset="/img/loading.gif" alt=""></li></ol><h3 id="随机性检验"><a href="#随机性检验" class="headerlink" title="随机性检验"></a>随机性检验</h3><ul><li><strong>算数平均值</strong>由均匀性，算数平均值为1/2。<script type="math/tex; mode=display">e(n)=\bar{X}-\frac{1}{2}</script>$e(n)$为偏置</li><li><strong>k阶自相关系数</strong>，是带检验序列$X_0$与自身位移后得到的序列$X_k$之间相关性的度量<script type="math/tex; mode=display">a_k=\frac{E[(x_i -\mu)(x_{i+k}-\mu)]}{\sigma^2}=\frac{\sum_i (x_i -\mu)(x_{(i+k)  modn}-\mu)}{\sum_i (x_i -\mu)^2}</script>式中n为序列长度，$\mu$ $\sigma$分别为序列的平均值与标准差。<br>对于理想随机数，$a_0=1$，$a_k=0$当$k\ne 0$时</li><li><strong>信息熵</strong>（Shannon熵）考察n比特长度作为基本单元子序列的概率密度分布<script type="math/tex; mode=display">H_n(X)=-\sum_{i=1}^{k^n} p_i log_k p_i</script>其中：k为进制，n为基本单位长度，$p_i$为子序列在总长度为N比特中出现的概率。规定$p_i=0$时$p_i log_k p_i=0$<br>信息熵是对序列概率的加权平均描述可以在一定程度上表示比特之间的统计分布和相关性的大小<br>对于理想二进制均匀分布，$p_i =1/N$其中$(i=0,1,2,…,2^n-1)$则此时信息熵最大值$H_n(X)=n$。<em>物理意义：</em>所有信息都有价值，有最大的非确定性4</li><li><strong>最小熵</strong><script type="math/tex">H_{n-min}=-log_k (max[p_i])</script><br>最小熵刻画了随机序列不确定的最小下限。m-LSB后处理使用最小熵确定m的值</li></ul><h4 id="输出序列的实际检验"><a href="#输出序列的实际检验" class="headerlink" title="输出序列的实际检验"></a>输出序列的实际检验</h4><ul><li><strong>标准检验包</strong><br>一套公认的的检验体系，基本思路：将一个带检测的输出序列划分为多个固定长度的子序列，根据置信水平（$\alpha=0.01$）给出待检序列通过检测的概率<br>1.DIEHARD统计检验包。<br>有18种子检测<br><img src="/img/9.png" srcset="/img/loading.gif" alt=""><br>所有检测共需要80M的待检测数据，每一个检测会给出一个p值，当$p&gt;\alpha$则通过检测。<br>对于6—11子检测，只能给出划分后子序列的p值，通过K-S Test转化为一个p值。<br>2.NIST-STS统计检验包。<br>有15个子检测<br><img src="/img/10.png" srcset="/img/loading.gif" alt=""><br>通过所有子检测需要有1G的比特长度，若不足检测会继续进行。<br>NIST-STS会给出两个值<br>p-值：同上，一般的判决阈值为$\alpha=0.0001$。<br>序列通过子检验的成功比例：假定划分的子序列数量为n，置信水平为$\alpha$<br>子序列通过单项检验的成功率取值在一个高斯分布中，其区间为<script type="math/tex">[1-\alpha-3\sqrt{\frac{\alpha (1-\alpha )}{n}},1-\alpha+3\sqrt{\frac{\alpha (1-\alpha )}{n}}]</script>当比例落入区间时，视为通过检测包。一般预设值为（n=1000，$\alpha=0.01$）区间为[0.9805，0.9995]</li><li><strong>三倍标准差（$3\sigma$）检测</strong></li></ul><p>指标：偏置$e(n)$，$k$阶自相关系数 $\alpha_k(n)$。</p><p>基本思想：由理想抛硬币模型所模拟的二进制随机序列的统计参数在一定置信水平下与数据长度相关。<br>1.偏置$e(n)$的$3\sigma$检验标准<br>理想抛硬币模型为均匀分布$P(1)=P(0)=1/2$<br>n次抛硬币出现m次正面的组合数为<script type="math/tex">N_n(m)=C_n^m</script><br>为伯努力分布，对其归一化<br>可以求出该分布的期望$E(x)=\frac{1}{2}$方差$D(x)=\frac{1}{4n}$<br>由中心极限定理，当$n\rightarrow \infty$时，p（x）趋于高斯分布<script type="math/tex">E(X),\sigma (x))=N(\frac{1}{2},\frac{1}{2\sqrt{n}})</script><br>同时偏置$p[e(x)]$也符合高斯分布</p><script type="math/tex; mode=display">p[e(n)]=N(e(X),\sigma (x))=N(0,\frac{1}{2\sqrt{n}})=\frac{1}{\sqrt{2\pi}\sigma_e}exp(-x^2/2\sigma_e^2)</script><p>在高斯分布中位于$[-3\sigma,+3\sigma]$区间的概率为99.7%，也就是偏置有99.7%落入$[-\frac{3}{2\sqrt{n}},+\frac{3}{2\sqrt{n}}]$。<br>对于落入区域以外的待检测序列，极大可能不满足随机序列的统计特征。<br>描述：<br>长度为n的随机序列，偏置$e(n)$满足：$|e(n)|&gt; \frac{3}{2\sqrt{n}}$，且序列仍为真随机序列的概率只有0.3%<br>2.自相关系数$\alpha_k(n)$的$3\sigma$检验标准<br>改写自相关的定义：</p><script type="math/tex; mode=display">a_1(n)\approx \frac{\sum_{i=1}^n y_i |_{y_i = [(1/2+e)^2,(1/2-e)^2,(-1/4+e^2)]}}{n(1/4+e^2)}\approx \frac{\sum_{i=1}^n y_i |_{y_i=[+1,-1]}}{n}</script><p><em>简化规则：</em><br> $x<em>i$ 为而进制，则 $x_i=0,1$<br>令 $y_1 =[x_i -E(x)][x</em>{(i+1)mod n}-E(x)]$ ，由 x_i$ 的取值 $y_i$ 只有三种取法 $y_i=(1/2+e)^2,(1/2-e)^2,(-1/4+e^2)$<br>当 $n-&gt;\infty$ 时，此时$e(n)$很小，故$y_i$中$e^2$项可以忽略<br>由数据之间的独立性，$y_i$中$-2e,+2e$项个数可以相互抵消<br>则一阶自相关系数满足高斯分布</p><script type="math/tex; mode=display">p[a_1 (n)]=N(0,\sigma_a)=\frac{1}{\sqrt{2 \pi}\sigma_a} exp(-x^2/2\sigma_a^2)</script><p>由于偏置$e(n)$中$y_i$取值为$\pm 1/2$，而一阶自相关系数中 $y_i$ 取值为 $\pm 1$ ，则</p><script type="math/tex; mode=display">\sigma_a=2\sigma_e=\frac{1}{\sqrt{n}}</script><p><em>描述</em>：<br>长度为n的随机序列，一阶自相关系数满足$|a_1(n)|&gt;\frac{3}{\sqrt{n}}$，且仍为真随机序列的概率只有0.3%<br>此方法可以推广到k阶</p>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>application of QM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
