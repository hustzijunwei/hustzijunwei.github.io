<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>A review about The Anomalous Hall Effect(AHE)</title>
    <link href="/2020/07/11/reviewreed/AHE/"/>
    <url>/2020/07/11/reviewreed/AHE/</url>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Anomalous Hall effect (AHE) was first found in 1881 by Hall. He reported that Hall effect was ten times larger in ferromagnetic iron. And as the temperature rises, the Hall coefficient rises rapidly.<br>Moreover, the Hall voltage is not directly proportional to the external field, indicating the anomalous Hall effect. The experiment was made by Pugh <a href="#refer"><sup>2<sup></a><a href="#refer"><sup>3<sup></a>and they got an empirical relation</p><script type="math/tex; mode=display">\rho_{x y}=R_{0} H_{z}+R_{s} M_{z}</script><h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><p>The research of AHE then continues for more than 100 years. Now there are three distinct contributions to Hall conductivity<script type="math/tex">\sigma_{x y}</script></p><script type="math/tex; mode=display">\sigma_{x y}^{A H}=\sigma_{x y}^{A H-i n t}+\sigma_{x y}^{A H-s k e w}+\sigma_{x y}^{A H-s j}</script><h2 id="Intrinsic-mechanism-of-AHE"><a href="#Intrinsic-mechanism-of-AHE" class="headerlink" title="Intrinsic mechanism of AHE"></a>Intrinsic mechanism of AHE</h2><p>In 1954, Karplus and Luttinger proposed a theory for the AHE<a href="#refer"><sup>4<sup></a>, which is recently referred as the intrinsic contribution to the AHE. By research the effect of SOI, they found that electrons have an additional contribution to their group velocity, when an external electric field is applied. And we call this velocity as KL’s anomalous velocity.<br>This contribution depends only on the band structure and completely ignores the impurity scattering. Then the intrinsic AHE yields</p><script type="math/tex; mode=display">\sigma_{x y}^{A H-i n t} \propto \sigma_{x x}^{0}</script><h2 id="extrinsic-mechanism-of-AHE"><a href="#extrinsic-mechanism-of-AHE" class="headerlink" title="extrinsic mechanism of AHE"></a>extrinsic mechanism of AHE</h2><h3 id="Skew-scattering"><a href="#Skew-scattering" class="headerlink" title="Skew scattering"></a>Skew scattering</h3><p>After Karplus and Luttinger proposed their theory, Smit opposed this theory and took scattering into consideration<a href="#refer"><sup>5<sup></a><a href="#refer"><sup>6<sup></a> He put forwards a mechanism called Skew scattering, which is due to the chirality that appears in the disorder scattering of spin-orbit coupled ferromagnets. </p><p>In this scattering theory, the skew angle is<script type="math/tex">\theta_{H}=\rho_{xy} / \rho</script><a href="#refer"><sup>7<sup></a>. So the Hall conductivity is proportional to the longitudinal conductivity<script type="math/tex">\sigma_{x x}</script>, that is</p><script type="math/tex; mode=display">\sigma_{x y}^{A H-s k e w} \propto \sigma_{x x}</script><h3 id="Side-jump"><a href="#Side-jump" class="headerlink" title="Side jump"></a>Side jump</h3><p>While the debate between the above two theories didn’t have a consensus, Berger came up with another mechanism in 1970<a href="#refer"><sup>8<sup></a>. When the system exists SOI, there is a crosswise jump $\Delta y$ after scattering.This may lead to</p><script type="math/tex; mode=display">\sigma_{x y}^{A H-s j} \propto \sigma_{x x}^{0}</script><p>After introducing these three main contributions in AHE, we need to remember that those contributions only take elastic scattering into account, and the inelastic scattering are not fully understood.<br><img src="/img_AHE/1.png" srcset="/img/loading.gif" alt=""><br>Illustration of the three main mechanisms in AHE <a href="#refer"><sup>9<sup></a></p><h2 id="Recent-Theory"><a href="#Recent-Theory" class="headerlink" title="Recent Theory"></a>Recent Theory</h2><p>In recent years, we find more and more evidence suggest that intrinsic contribution play the most important part in AHE.<br>Now we can review the intrinsic contribution through the aspect of Berry curvature of the Bloch states in momentum space<a href="#refer"><sup>1<sup></a> , which is usually given as </p><script type="math/tex; mode=display">\sigma_{x y}^{\prime}=n \frac{\mathrm{e}^{2}}{\hbar}\langle\Omega\rangle</script><p>where<script type="math/tex">\langle\Omega\rangle \equiv n^{-1} \sum_{\vec{k}} \Omega_{z}(\vec{k}) f_{\vec{k}}^{0}</script>.<br>The Berry curvature<script type="math/tex">\Omega(\vec{k})</script> is given by a perturbation on the Hamiltonian<script type="math/tex">H=V(\vec{R})+\epsilon_{n}(\vec{k})</script>, and<script type="math/tex">f_{\vec{k}}^{0}</script> is distribution function at steady state.<br>Then we can focus on the specific in intrinsic contribution</p><h3 id="Anomalous-Velocity"><a href="#Anomalous-Velocity" class="headerlink" title="Anomalous Velocity"></a>Anomalous Velocity</h3><p>In solid physics The eigenstates of electrons are Bloch states, which is </p><script type="math/tex; mode=display">\psi_{n \vec{k}}(\vec{r})=\frac{1}{\sqrt{N}} \exp (\overrightarrow{\mathrm{i} k} \cdot \vec{r}) u_{n \vec{k}}(\vec{r})=\langle\vec{r} | n \vec{k}\rangle</script><p>Now we add a perturbation to the Hamiltonian<script type="math/tex">H=V(\vec{R})+\epsilon_{n}(\vec{k})</script>, where<script type="math/tex">\vec{R}=\mathrm{i} \nabla_{\vec{k}}</script>.<br>if the potential $V$ is weak, we can obtain the Berry Phase when the state $|\psi\rangle$ varying in parameter space alone $C$.</p><script type="math/tex; mode=display">\chi(\vec{k})=-\int_{C}^{\vec{k}} \mathrm{d} \vec{k}^{\prime} \cdot \vec{X}\left(\vec{k}^{\prime}\right)</script><p>And Berry vector potential:</p><script type="math/tex; mode=display">\vec{X}(\vec{k})=\int_{\mathrm{cell}} \mathrm{d}^{3} \vec{r} u_{n \vec{k}}^{*}(\vec{r}) \mathrm{i} \nabla_{\vec{k}} u_{n \vec{k}}(\vec{r})</script><p>Berry curvature:</p><script type="math/tex; mode=display">\Omega(\vec{k})=\nabla_{\vec{k}} \times \vec{X}(\vec{k})</script><p>Same as the form in electrodynamics, we can call $\Omega(\vec{k})$ as magnetic field, and $\vec{X}(\vec{k})$is vector gauge potential.</p><p>In order to remove the AB phase, we may give a gauge transformation to Hamiltonian, which means:</p><script type="math/tex; mode=display">H^{\prime}=V\left(\mathrm{i} \nabla_{\vec{k}}+\vec{X}\right)+\epsilon_{n}(\vec{k})</script><p>and now the coordinate operator become $\vec{x}=\vec{R}+\vec{X}(\vec{k})$, which lead to non-commutation to itself</p><script type="math/tex; mode=display">\left[x_{i}, x_{j}\right]=\mathrm{i} \epsilon^{i j k} \Omega_{k}</script><p>So we can get the group velocity as  </p><script type="math/tex; mode=display">\hbar \vec{v}=-\mathrm{i}\left[\vec{x}, H^{\prime}\right]=\nabla_{\vec{k}} \epsilon_{n}(\vec{k})+\left(\frac{\partial V}{\partial \vec{x}}\right) \times \vec{\Omega}(\vec{k})</script><p>We call the last term $\left(\frac{\partial V}{\partial \vec{x}}\right) \times \vec{\Omega}(\vec{k})$ as Anomalous velocity</p><p>When we consider a potential $V=-e \vec{E} \cdot \vec{x}$, we can immediately obtain phase velocity and group velocity:</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\hbar \dot{\vec{k}}=e \vec{E}+e \vec{v} \times \vec{B} \\\hbar \vec{v}=\nabla \epsilon_{n}-e \vec{E} \times \vec{\Omega}\end{array}\right.</script><h3 id="Anomalous-Hall-Current"><a href="#Anomalous-Hall-Current" class="headerlink" title="Anomalous Hall Current"></a>Anomalous Hall Current</h3><p>In Boltzmann transport equation, the electric current density is given as when $B=0$</p><script type="math/tex; mode=display">\vec{J}=e \sum_{\vec{k}, s} \vec{v}_{\vec{k}}\left[f_{\vec{k}}^{0}+g_{\vec{k}}\right]</script><p>where $f_{\vec{k}}^{0}$ is distribution function at steady state, and </p><script type="math/tex; mode=display">g_{\vec{k}}=e \vec{v}_{\vec{k}} \tau \cdot \vec{E}\left(-\frac{\partial f^{0}}{\partial \epsilon}\right)</script><p>Where $\tau$ is transport relaxation time.</p><p>In general case,<script type="math/tex">\sum f_{\vec{k}}^{0}=0</script> due to it’s symmetry, and we usually get conductivity $\sigma$ from<script type="math/tex">g_{\vec{k}}</script><br>But, when we consider<script type="math/tex">\hbar \vec{v}=\nabla \epsilon_{n}-e \vec{E} \times \vec{\Omega}</script>, it will lead to a hall current from<script type="math/tex">f_{\vec{k}}^{0}</script></p><script type="math/tex; mode=display">\vec{J}_{H}=\frac{\mathrm{e}^{2}}{\hbar} \vec{E} \times \sum_{\vec{k}, s} \vec{\Omega}(\vec{k}) f_{\vec{k}}^{0}</script><p>Therefore we can obtain Hall conductivity<script type="math/tex">\sigma_{x y}^{\prime}</script></p><script type="math/tex; mode=display">\sigma_{x y}^{\prime}=n \frac{\mathrm{e}^{2}}{\hbar}\langle\Omega\rangle</script><p>where<script type="math/tex">\langle\Omega\rangle \equiv n^{-1} \sum_{\vec{k}} \Omega_{z}(\vec{k}) f_{\vec{k}}^{0}</script><br>Here we can find that<script type="math/tex">\Omega</script> has the same form as magnet field $B$. So AHE can also regard as the monopoles in momentum space.</p><h3 id="Symmetry"><a href="#Symmetry" class="headerlink" title="Symmetry"></a>Symmetry</h3><p>In this case we have two symmetry, which is </p><ul><li>inversion symmetry<script type="math/tex">\vec{\Omega}(\vec{k}) \rightarrow-\vec{\Omega}(-\vec{k})</script></li><li>time-reversal symmetry<script type="math/tex">\vec{\Omega}(\vec{k}) \rightarrow\vec{\Omega}(-\vec{k})</script></li></ul><p>if both symmetry are exist in system, we only have $\vec{\Omega}(\vec{k})=0$, henze $\vec{J}_H=0$, which means there are no Hall effect. So in order to get Hall effect we must break time-reversal symmetry(not only break inversion symmetry).<br>In ordinary Hall effect, external magnetic field $B$ break time-reversal symmetry.<br>In ferromagnetic conductors, $\vec{M}$ break time-reversal symmetry, so they exist Anomalous Hall current.</p><div id="refer"></div><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="">Ye J, Kim Y B, Millis A J, et al. Berry phase theory of the anomalous Hall effect: Application to colossal magnetoresistance manganites[J]. Physical review letters,1999, 83(18): 3737.</a><br>[2] <a href="">Pugh E M. Hall effect and the magnetic properties of some ferromagnetic materials[J]. Physical Review, 1930, 36(9): 1503.</a><br>[3] <a href="">Pugh E M, Lippert T W. Hall emf and intensity of magnetization[J]. Physical Review, 1932, 42(5): 709.</a><br>[4] <a href="">Karplus R, Luttinger J M. Hall effect in ferromagnetics[J]. Physical Review, 1954, 95(5): 1154.</a><br>[5] <a href="">Smit J. The spontaneous Hall effect in ferromagnetics I[J]. Physica, 1955, 21(6-10): 877-887.</a><br>[6] <a href="">Smit J. The spontaneous Hall effect in ferromagnetics II[J]. Physica, 1958, 24(1-5): 39-51.</a><br>[7] <a href="">Bernevig B A, Hughes T L, Zhang S C. Quantum spin Hall effect and topological phase transition in HgTe quantum wells[J]. science, 2006, 314(5806): 1757-1761.</a><br>[8] <a href="">Berger L. Side-jump mechanism for the Hall effect of ferromagnets[J]. Physical Review B, 1970, 2(11): 4559.</a><br>[9] <a href="">Nagaosa N, Sinova J, Onoda S, et al. Anomalous hall effect[J]. Reviews of modern physics, 2010, 82(2): 1539.</a></p>]]></content>
    
    
    <categories>
      
      <category>Literature Review</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hall effect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Brief introduction to Plasmonics</title>
    <link href="/2020/07/03/reviewreed/Plasmonics/"/>
    <url>/2020/07/03/reviewreed/Plasmonics/</url>
    
    <content type="html"><![CDATA[<h1 id="An-introduction-to-Plasmonics"><a href="#An-introduction-to-Plasmonics" class="headerlink" title="An introduction to Plasmonics"></a>An introduction to Plasmonics</h1><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p><strong>Plasmons</strong> are coherent delocalized electron oscillations that exist at the interface between any two materials where the real part of the dielectric function changes sign across the interface.</p><h2 id="classification"><a href="#classification" class="headerlink" title="classification"></a>classification</h2><p>Typically, there are two kinds of Plasmonics:</p><ul><li>localized surface plasmons (LSPs)<br>This usually occurs between the nano-particles and the external field.</li><li>surface plasmon-polaritons (SPPs)<br>This usually occurs in the interface between two materials especially the layers.</li></ul><h2 id="analyzation"><a href="#analyzation" class="headerlink" title="analyzation"></a>analyzation</h2><p>As we have already learned in electrodynamics, we can figure out the </p>]]></content>
    
    
    <categories>
      
      <category>Literature Review</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Quantum Optics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固体物理圣经咏唱——金属电子论</title>
    <link href="/2020/06/29/solid%20physics/solid5/"/>
    <url>/2020/06/29/solid%20physics/solid5/</url>
    
    <content type="html"><![CDATA[<h1 id="特鲁特（Drude）模型"><a href="#特鲁特（Drude）模型" class="headerlink" title="特鲁特（Drude）模型"></a>特鲁特（Drude）模型</h1><p><strong>Core:</strong>故把金属看成是由大量自由电子构成的理想气体。由此电子气只有一个参数，即电子密度<script type="math/tex">n</script>（单位体积的电子数）。<br>电子气<strong>性质</strong>：</p><ul><li>浓度比理想气体高<script type="math/tex">n\sim 10^{23} / cm^3</script></li><li>电子运动是无规则热运动和漂移运动（导电的原因）的叠加，满足牛顿运动方程</li><li>电子等效球半径<script type="math/tex; mode=display">r_{s}=\left(\frac{3}{4 \pi n}\right)^{1 / 3}</script></li><li>电子服从玻尔兹曼统计</li></ul><p><em>一些问题：</em>使用Drude模型得到的自由电子气系统的定容比热为<script type="math/tex">C_{V}^{e}=\frac{3}{2} N k_{B}</script>和实验明显不相符合</p><ul><li>Drude模型预测电子比热和温度无关，而实验上则表明低温下电子比热随温度降低而线性减小。</li><li>Drude模型预测电子比热同晶格比热相当，但实验观察到的电子比热仅为理论值的<script type="math/tex">1 / 200</script></li></ul><h1 id="索末菲模型"><a href="#索末菲模型" class="headerlink" title="索末菲模型"></a>索末菲模型</h1><p><strong>Core：</strong>金属可以看成由在均匀分布在正电荷背景上‘自由’运动的价电子构成的电子气。也称为<strong>金属自由电子气量子理论</strong>。<br>这里有三个<strong>假设</strong>：一是自由电子近似，即忽略电子和离子实之间的相互作用，二是独立电子近似，即忽略了电子-电子之间的相互作用，三是弛豫时间近似<br><strong>性质：</strong></p><ul><li>运动方程满足schrondinger方程</li><li>服从费米-狄拉克统计<script type="math/tex; mode=display">f(\varepsilon)=\frac{1}{e^{(\varepsilon-\mu) / k_{B} T}+1}</script></li></ul><h2 id="金属自由电子气量子理论"><a href="#金属自由电子气量子理论" class="headerlink" title="金属自由电子气量子理论"></a>金属自由电子气量子理论</h2><p>此时假设金属是一个边长为L的立方体，其中含有N个价电子。按照索末菲模型如图所示<br><img src="/img_solid/25.png" srcset="/img/loading.gif" alt=""><br>则电子受到的势场为</p><script type="math/tex; mode=display">U(x, y, z)=\left\{\begin{array}{cc}0 & (0<x, y, z<L) \\\infty & (x, y, z \leq 0 ; x, y, \geq L)\end{array}\right.</script><p>在金属内对于状态<script type="math/tex">\psi(x, y, z)</script>有（若在外则<script type="math/tex">\psi=0</script>）</p><script type="math/tex; mode=display">-\frac{\hbar^{2}}{2 m} \nabla^{2} \psi(x, y, z)=\varepsilon \psi(x, y, z)</script><p>其解（归一化后）为</p><script type="math/tex; mode=display">\psi_{\vec{k}}(\vec{r})=\frac{1}{\sqrt{V}} e^{i \vec{k} \cdot \vec{r}}</script><p>能量为</p><script type="math/tex; mode=display">\varepsilon(\vec{k})=\frac{\hbar^{2} k^{2}}{2 m}=\frac{\hbar^{2}\left(k_{x}^{2}+k_{y}^{2}+k_{z}^{2}\right)}{2 m}</script><p>同时由于玻恩-卡门周期性边条件</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\psi(x+L, y, z)=\psi(x, y, z) \\\psi(x, y+L, z)=\psi(x, y, z) \\ \psi(x, y, z+L)=\psi(x, y, z) \end{array}\right.</script><p>对于<script type="math/tex">k_{i}</script>需满足</p><script type="math/tex; mode=display">\left\{\begin{array}{ll}k_{x}=\frac{2 \pi}{L} n_{x} & \left(n_{x}=0,\pm 1, \pm 2 \ldots\right) \\k_{y}=\frac{2 \pi}{L} n_{y} & \left(n_{y}=0,\pm 1, \pm 2 \ldots\right) \\k_{z}=\frac{2 \pi}{L} n_{z} & \left(n_{z}=0,\pm 1, \pm 2 \ldots\right)\end{array}\right.</script><p>由此得知电子本征能量是量子化的</p><script type="math/tex; mode=display">\varepsilon_{n}=\frac{h^{2}}{2 m L^{2}}\left(n_{x}^{2}+n_{y}^{2}+n_{z}^{2}\right)</script><h3 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h3><p>假如以￥$k<em>{x}, k</em>{y}, k_{z}$￥为坐标轴建立起波矢（状态）空间，简称<script type="math/tex">\vec{k}</script>空间,则每一个电子的本征态可以用<script type="math/tex">\vec{k}</script>空间的一个点来代表，且可以铺满整个空间。如图所示<br><img src="/img_solid/26.png" srcset="/img/loading.gif" alt=""></p><h3 id="状态密度"><a href="#状态密度" class="headerlink" title="状态密度"></a>状态密度</h3><p>在<script type="math/tex">\vec{k}</script>空间每个点所占据的体积为</p><script type="math/tex; mode=display">\Delta \vec{k}=(2 \pi / L)^{3}=8 \pi^{3} / V</script><p>其倒数表示<script type="math/tex">\vec{k}</script>空间中单位体积内许可态的代表点数，由此可以得到状态密度</p><script type="math/tex; mode=display">\frac{1}{\Delta \overrightarrow{\boldsymbol{k}}}=\frac{V}{8 \pi^{3}}</script><h3 id="能态密度"><a href="#能态密度" class="headerlink" title="能态密度"></a>能态密度</h3><p>由于</p><script type="math/tex; mode=display">k_{x}^{2}+k_{y}^{2}+k_{z}^{2}=\frac{2 m \varepsilon}{\hbar^{2}}</script><p>在<script type="math/tex">\vec{k}</script>空间内，球面上的电子具有相同的能量，称之为电子的等能面。如图所示<br><img src="/img_solid/27.png" srcset="/img/loading.gif" alt=""><br>此时我们通过能态密度的定义可以算出</p><script type="math/tex; mode=display">g(\varepsilon)=\frac{d N}{d \varepsilon}=4 \pi V\left(\frac{2 m}{h^{2}}\right)^{3 / 2} \varepsilon^{1 / 2}=C \varepsilon^{1 / 2}</script><h3 id="自由电子气的基态与费米面"><a href="#自由电子气的基态与费米面" class="headerlink" title="自由电子气的基态与费米面"></a>自由电子气的基态与费米面</h3><p>由于电子属于费米子，服从泡利不相容原理，这意味着自由电子气系统中N个电子 不可能都占据在$k=0$这样一个能量最低的态。同时考虑电子的自旋，每个许可态上可以有自旋相上和 自旋向下的两个电子占据。<br>由此我们可以得到电子的填充顺序：从能量最低的$k=0$态开始，每个态上占据两个电子，按能量从低到高，依次占据而得到系统的基态。在$\vec{k}$空间中，电子占据区最后成为一个球。这样一个$\vec{k}$空间中所有态被电子占据形成的球称为<strong>费米球</strong>（Fermi sphere），费米球的表面称为<strong>费米面</strong>（Fermi surface）</p><ul><li>费米球的半径称为<strong>费米波矢<script type="math/tex">k_{F}^{0}</script></strong><script type="math/tex; mode=display">k_{F}^{0}=\left(3 \pi^{2} n\right)^{1 / 3}</script></li><li>费米面上的电子能量，简称<strong>费米能</strong><script type="math/tex; mode=display">\varepsilon_{F}^{0}=\frac{\hbar^{2}\left(k_{F}^{0}\right)^{2}}{2 m}=\frac{\hbar^{2}\left(3 \pi^{2} n\right)^{2 / 3}}{2 m}</script></li><li>由<script type="math/tex">\vec{p}=\hbar \vec{k}</script>，可得<strong>费米动量</strong><script type="math/tex; mode=display">p_{F}^{0}=\hbar k_{F}^{0}=\hbar\left(3 \pi^{2} n\right)^{1 / 3}</script></li><li>同时<script type="math/tex">m \vec{v}=\hbar \vec{k}</script>，可得<strong>费米速度</strong><script type="math/tex; mode=display">v_{F}^{0}=\frac{\hbar k_{F}^{0}}{m}=\frac{\hbar\left(3 \pi^{2} n\right)^{1 / 3}}{m}</script></li><li>由<script type="math/tex">\varepsilon_{F}^{0}=k_{B} T_{F}^{0}</script>，可得到<strong>费米温度</strong><script type="math/tex; mode=display">T_{F}^{0}=\frac{\hbar^{2}\left(3 \pi^{2} n\right)^{2 / 3}}{2 m k_{B}}</script>以上几个量的大体数值<script type="math/tex">k_{F}^{0} \sim 10^{8} \mathrm{cm}^{-1}, \quad \varepsilon_{F}^{0} \sim \text { 几 } \mathrm{eV}, \quad T_{F}^{0} \sim 10^{4} K \text { 和 } v_{F}^{0} \sim 10^{8} \mathrm{cm} / \mathrm{s}</script></li></ul><h3 id="自由电子气的基态能量"><a href="#自由电子气的基态能量" class="headerlink" title="自由电子气的基态能量"></a>自由电子气的基态能量</h3><p>对基态时所有电子能量求和</p><script type="math/tex; mode=display">E_{0}=2 \times \sum_{k<k_{F}^{0}} \frac{\hbar^{2} k^{2}}{2 m}</script><p>这里因子2是由于自旋的简并导致的。带入<script type="math/tex">\Delta \vec{k}=\frac{8 \pi^{3}}{V}</script>，且转为积分，可得</p><script type="math/tex; mode=display">E_{0}=\frac{3}{5} N \varepsilon_{F}^{0}</script><p>对应电子的平均能量</p><script type="math/tex; mode=display">\bar{\varepsilon}_{0}=\frac{E_{0}}{N}=\frac{3}{5} \varepsilon_{F}^{0}</script><p>当$T=0$时，能量不为0。与经典（特鲁特）模型不同。</p><h1 id="金属自由电子气激发态"><a href="#金属自由电子气激发态" class="headerlink" title="金属自由电子气激发态"></a>金属自由电子气激发态</h1><h2 id="费米-狄喇克统计"><a href="#费米-狄喇克统计" class="headerlink" title="费米-狄喇克统计"></a>费米-狄喇克统计</h2><p>在温度T时电子处在能量为<script type="math/tex">\varepsilon</script>的几率</p><script type="math/tex; mode=display">f(\varepsilon)=\frac{1}{e^{(\varepsilon-\mu) / k_{B} T}+1}</script><p>其中<script type="math/tex">\mu</script>为系统的化学势，其意义是在体积不变的条件下系统增加一个电子所需要的能量。<br><img src="/img_solid/28.png" srcset="/img/loading.gif" alt=""><br>由此可以看出$T \rightarrow 0$ 时的 $\mu$ 实际上就是前面所讲的基态费米能<script type="math/tex">\varepsilon_{F}^{0}</script>。所以我们可以将费米-狄喇克统计写为</p><script type="math/tex; mode=display">f(\varepsilon)=\frac{1}{e^{\left(\varepsilon-\varepsilon_{F}\right) / k_{B} T}+1}</script><h2 id="有限温度时量子态上的电子占据"><a href="#有限温度时量子态上的电子占据" class="headerlink" title="有限温度时量子态上的电子占据"></a>有限温度时量子态上的电子占据</h2><p>对与 $T \neq 0$ 时的情况，由于热激发，费米能以下 一些电子被热激发到<script type="math/tex">\varepsilon>\varepsilon_{F}</script>的量子态上，使得费米能以下留下一些没有被电子占据的量子态，而在费米能以上出现一些热激发电子。</p><h2 id="费米能随温度的变化关系"><a href="#费米能随温度的变化关系" class="headerlink" title="费米能随温度的变化关系"></a>费米能随温度的变化关系</h2><p>经过稍微复杂的计算可以得到</p><script type="math/tex; mode=display">\varepsilon_{F}=\frac{\varepsilon_{F}^{0}}{\left[1+\frac{\pi^{2}}{8}\left(\frac{k_{B} T}{\varepsilon_{F}}\right)^{2}\right]^{2 / 3}} \approx \varepsilon_{F}^{0}\left[1-\frac{\pi^{2}}{12}\left(\frac{k_{B} T}{\varepsilon_{F}}\right)^{2}\right] \approx \varepsilon_{F}^{0}\left[1-\frac{\pi^{2}}{12}\left(\frac{k_{B} T}{\varepsilon_{F}^{0}}\right)^{2}\right]</script><p>具体的picture：<strong>温度升高引起费米球的收缩（<script type="math/tex">k_{F}</script>减小）。</strong>费米面以内能量离<script type="math/tex">\varepsilon_{F}</script>约<script type="math/tex">k_B T</script>范围的能级上的电子被激发到<script type="math/tex">\varepsilon_{F}</script>之上约<script type="math/tex">k_{B} T</script>范围的能级</p><h1 id="金属自由电子气电子比热的量子理论"><a href="#金属自由电子气电子比热的量子理论" class="headerlink" title="金属自由电子气电子比热的量子理论"></a>金属自由电子气电子比热的量子理论</h1><p>索末菲金属自由电子气量子理论可以解决Drude模型在电子比热上遇到的问题。我们可以计算出总能量</p><script type="math/tex; mode=display">E \approx \frac{3}{5} N \varepsilon_{F}^{0}+\frac{\pi^{2}}{4} N k_{B} T \times\left(k_{B} T / \varepsilon_{F}^{0}\right)</script><p>由此可得到金属自由电子气的电子比热</p><script type="math/tex; mode=display">C_{V}^{e} \equiv \frac{\partial E}{\partial T}=\frac{\pi^{2}}{2} N k_{B}\left(k_{B} T / \varepsilon_{F}^{0}\right)</script><p>可见，量子理论给出的金属自由电子气的电子比热随温度降低而线性减小。且数量级也与实验数值相符。<br><em>区别：</em>在经典理论中，所有电子参与了对电子比热的贡献，而在量子理论中，只有费米面以下约<script type="math/tex">k_{B} T</script>的能量范围内的电子因热激发而跃迁到费米面以上能量较高的量子态上，只有这些热激发电子参与对系统电子比热的贡献。</p><p>固体的比热是若干个子系统对比热的贡献之和。对非磁性金属，共有晶格和电子两个子系统，因此</p><script type="math/tex; mode=display">c_{V}=\gamma T+\beta T^{3}</script><p>这里第一项为自由电子气贡献，第二项为德拜模型贡献。</p><h1 id="自由电子气顺磁性的量子理论"><a href="#自由电子气顺磁性的量子理论" class="headerlink" title="自由电子气顺磁性的量子理论"></a>自由电子气顺磁性的量子理论</h1><p>金属电子气系统中，每个电子的自旋量子数 $s=\frac{1}{2},$ 相应的磁矩为<script type="math/tex">\vec{\mu}_{s}=-g \vec{s} \mu_{B}</script>，利用 $s=\frac{1}{2}$ 和朗德因子 $g=2,$ 每个电子携带的磁矩大小正好为一个玻尔磁子<script type="math/tex">\left(\mu_{B}\right)</script>，电子磁矩间没有相互作用。<br>经典模型：经典的朗之万顺磁理论预言的磁化率（<script type="math/tex">\chi</script>）随温度的变化具有居里定律的形式</p><script type="math/tex; mode=display">\chi=\frac{N \mu_{B}^{2}}{3 k_{B}} \frac{1}{T}</script><p>遇到的<em>问题：</em></p><ul><li>简单金属中观测到的顺磁磁化率值远小于经典理论值</li><li>简单金属中的顺磁磁化率低温下基本上与温度无关</li></ul><p>金属自由电子气量子理论可以解决上述问题。<br>我们使用<script type="math/tex">g_{+}</script>表示自旋向上的电子的能态密度，<script type="math/tex">g_{-}</script>表示自旋向下的。</p><script type="math/tex; mode=display">g_{+}(\varepsilon)+g_{-}(\varepsilon)=g(\varepsilon)</script><p><img src="/img_solid/29.png" srcset="/img/loading.gif" alt=""><br>如图所示</p><ul><li>（a）未加磁场时，此时<script type="math/tex; mode=display">g_{+}(\varepsilon)=g_{-}(\varepsilon)=\frac{1}{2} g(\varepsilon)</script></li><li>（b）外加强度为$H$的磁场时，自旋向下的电子，由于其自旋取向和磁场方向相反，故每个电子的能量从<script type="math/tex">\varepsilon \text { 提高到 } \varepsilon+\mu_{B} H</script><script type="math/tex; mode=display">g_{-}(\varepsilon)=\frac{1}{2} g\left(\varepsilon+\mu_{B} H\right)</script>自旋向上的电子则相反<script type="math/tex; mode=display">g_{+}(\varepsilon)=\frac{1}{2} g\left(\varepsilon-\mu_{B} H\right)</script></li><li>（c）体系平衡时，右边能量较高的自旋向下的电子可通过自旋翻转而转移到左边未被自旋向上电 子占据的空态上。两种自旋取向的电子有相同的费米能<script type="math/tex">\varepsilon_{F}</script></li></ul><p>由此可以计算外加磁场下金属自由电子气系统的<strong>磁化强度</strong></p><script type="math/tex; mode=display">M=-\mu_{B}\left(N_{+}-N_{-}\right)=-\frac{1}{2} \mu_{B} \int_{0}^{\infty}\left[g\left(\varepsilon-\mu_{B} H\right)-g\left(\varepsilon+\mu_{B} H\right)\right] f(\varepsilon) d \varepsilon</script><p>积分的下限近似取为0是因为仅仅在费米面附近的电子才可能发生翻转，同时<script type="math/tex">\mp \mu_{B} H</script>也很小。一阶展开<script type="math/tex">g\left(\varepsilon \pm \mu_{B} H\right)</script>带入计算可得</p><script type="math/tex; mode=display">M=g\left(\varepsilon_{F}^{0}\right) \mu_{B}^{2} H\left[1-\frac{\pi^{2}}{12}\left(k_{B} T / \varepsilon_{F}^{0}\right)^{2}\right]</script><p>所以金属自由电子气系统的<strong>顺磁磁化率</strong>为</p><script type="math/tex; mode=display">\chi_{p} \equiv \frac{M}{H}=g\left(\varepsilon_{F}^{0}\right) \mu_{B}^{2}\left[1-\frac{\pi^{2}}{12}\left(k_{B} T / \varepsilon_{F}^{0}\right)^{2}\right]</script><h1 id="金属自由电子气的电子输运理论"><a href="#金属自由电子气的电子输运理论" class="headerlink" title="金属自由电子气的电子输运理论"></a>金属自由电子气的电子输运理论</h1><h1 id="电子发射"><a href="#电子发射" class="headerlink" title="电子发射"></a>电子发射</h1><h1 id="金属自由电子气模型的局限性"><a href="#金属自由电子气模型的局限性" class="headerlink" title="金属自由电子气模型的局限性"></a>金属自由电子气模型的局限性</h1><ul><li>无法解释多价金属尽管电子密度大，电导率却比一价金属差。</li><li>预测一价碱金属的霍尔系数很好，但对一价贵金属和二、三价金属理论与实验不相符。</li><li>无法解释磁电阻效应</li><li>无法解释金属、半导体和绝缘体的分类</li></ul><p>尽管金属电子气模型对稍微复杂点的金属明显是不适合的，但对于重金属我们还是使用这个模型，通常定义电子的<strong>有效质量</strong>来描述实际的电子气系统和自由电子气的差别程度</p><script type="math/tex; mode=display">m^{*}=m_{0} \times \frac{\gamma^{\exp }}{\gamma^{\text {theo}}}</script>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固体物理圣经咏唱——固体能带论</title>
    <link href="/2020/06/29/solid%20physics/solid6/"/>
    <url>/2020/06/29/solid%20physics/solid6/</url>
    
    <content type="html"><![CDATA[<h1 id="固体的能带的形成"><a href="#固体的能带的形成" class="headerlink" title="固体的能带的形成"></a>固体的能带的形成</h1><p>原子最外层电子，由于原子核对其束缚很弱，当大量原子结合成晶体时，这些电子易摆脱原子核的束缚而成为共有化电子，这部分电子称为<strong>价电子</strong>，而原子内层电子（芯电子）有较高的结合能，一般脱离不了原子核对其束缚，这些芯电子同原子核一起构成<strong>离子实</strong>，因此，固体中的原子又可分为带正电的离子实和带负电的价电子两部分。当N个原子相互靠近形成晶体时由于电子壳层的交叠，电子不再局限于某一个原子上，可以由一个原子转移到相邻的原子上去， 因而，电子将可以在整个晶体中运动，这种运动称为电子的<strong>公有化运动</strong>。<br>对于N个独立的单个原子，有其自身的能级系统，每个能级都有N个态与之对应，若不考虑原子本身的简并则是N重简并的。但当N个原子相互靠近结合成晶体后，每个原子中的电子除受到自身原子的势场外，还要受到周围其它原子的原子势场的作用，此时每一个N重简并的能级都分裂成彼此相距很近的能级。这N个彼此相距很近的能级就组成一个<strong>能带</strong>，如图所示<br><img src="/img_solid/30.png" srcset="/img/loading.gif" alt=""><br>因为N的数量很大能级的分裂也很小，因此每一个能带中的能级彼此非常靠近，以至于基本上可认为是连续的，我们称这些带为<strong>允带</strong>。相邻的两个能带之间隔以能量不可能为电子所有的范围，称为<strong>禁带</strong>。</p><h1 id="固体能带的理论基础"><a href="#固体能带的理论基础" class="headerlink" title="固体能带的理论基础"></a>固体能带的理论基础</h1><p>固体中带负电荷的价电子是在大量带正电荷、周期性排列的离子实背景中作共有化运动。</p><h2 id="哈密顿算符"><a href="#哈密顿算符" class="headerlink" title="哈密顿算符"></a>哈密顿算符</h2><p>假定体积为<script type="math/tex">V=L^{3}</script>的固体由N个原子周期性排列而成，每个原子有Z个价电子。用<script type="math/tex">\vec{r}_{i}</script>和<script type="math/tex">\vec{R}_{n}</script>分别表示第 $i$ 个价电子和第 $n$ 个离子实的位置矢量,则整个系统的哈密顿算符可表示为</p><script type="math/tex; mode=display">\begin{aligned}\hat{H}=&-\sum_{i=1}^{N Z} \frac{\hbar^{2}}{2 m} \nabla_{i}^{2}+\frac{1}{2} \sum_{i, j}^{\prime} \frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{\left|\vec{r}_{i}-\vec{r}_{j}\right|} \\&-\sum_{n=1}^{N} \frac{\hbar^{2}}{2 M} \nabla_{n}^{2}+\frac{1}{2} \sum_{n, m}^{\prime} \frac{1}{4 \pi \varepsilon_{0}} \frac{(Z e)^{2}}{\left|\vec{R}_{n}-\vec{R}_{m}\right|} \\&-\sum_{i=1}^{N Z} \sum_{n=1}^{N Z} \frac{1}{4 \pi \varepsilon_{0}} \frac{Z e^{2}}{\left|\vec{r}_{i}-\vec{R}_{n}\right|}\end{aligned}</script><p>其中第一部分是$NZ$个价电子的动能和相互间库仑作用能，第二部分是N个离子实的动能和相互间库仑作用能，第三部分是N个离子实和<script type="math/tex">NZ</script>个价电子间的库仑作用能。可以发现这个哈密顿量是极度复杂的，接下来我们就通过近似来简化这个哈密顿量。</p><h2 id="绝热近似"><a href="#绝热近似" class="headerlink" title="绝热近似"></a>绝热近似</h2><p>按照玻恩-奥本海姆绝热近似，电子可近似认为能绝热于离子实的运动，因此，可将电子和离子实的运动进行分开处理。由此我们只关系由NZ个电子构成的电子系统的哈密顿算符</p><script type="math/tex; mode=display">\hat{H}_{e}=-\sum_{i=1}^{N Z} \frac{\hbar^{2}}{2 m} \nabla_{i}^{2}+\frac{1}{2} \sum_{i=1}^{N Z} \sum_{j \neq i} \frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{\left|\vec{r}_{i}-\vec{r}_{j}\right|}-\sum_{i=1}^{N Z} \sum_{n=1}^{N Z} \frac{1}{4 \pi \varepsilon_{0}} \frac{Z e^{2}}{\left|\vec{r}_{i}-\vec{R}_{n}\right|}</script><p>其中<script type="math/tex">\vec{R}_{n}</script>是第$n$个离子实的瞬时位置。在绝对零度的时候，离子实处在平衡位置<script type="math/tex">\vec{R}_{n}^{0}</script>，而在有限温度时，我们可以忽略晶格微小的振动可以认为离子实也在<script type="math/tex">\vec{R}_{n}^{0}</script>。</p><h2 id="平均场近似"><a href="#平均场近似" class="headerlink" title="平均场近似"></a>平均场近似</h2><p>在引入绝热近似后虽然哈密顿量有所简化，但对于库仑关联项还是很复杂。由于库仑关联项的存在，电子的运动彼此是相互关联的。因此我们可以将所有其它电子对位于<script type="math/tex">\vec{r}_{i}</script>处第i个电子的影响用一个平均场<script type="math/tex">v_{e}\left(\vec{r}_{i}\right)</script>来描述，即用平均场近似替代库仑关联项：</p><script type="math/tex; mode=display">v_{e}\left(\vec{r}_{i}\right) \rightarrow V_{e e}\left(\vec{r}_{i}, \vec{r}_{j}\right)=\frac{1}{2} \sum_{j \neq i} \frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{\left|\vec{r}_{i}-\vec{r}_{j}\right|}</script><p>由此哈密顿量可以写为</p><script type="math/tex; mode=display">\hat{H}_{e}=\sum_{i=1}^{N Z}\left[-\frac{\hbar^{2}}{2 m} \nabla_{i}^{2}+v_{e}\left(\vec{r}_{i}\right)-\sum_{R_{n}} \frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{\left|\vec{r}_{i}-\vec{R}_{n}\right|}\right]</script><p>我们可令<script type="math/tex">\hat{H}_{e}=\sum_{i=1}^{N Z} \hat{H}_{e i}</script>，且</p><script type="math/tex; mode=display">\hat{H}_{e i}=-\frac{\hbar^{2}}{2 m} \nabla_{i}^{2}+v_{e}\left(\vec{r}_{i}\right)-\sum_{R_{n}} \frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{\left|\vec{r}_{i}-\vec{R}_{n}\right|}</script><p>这时对于态<script type="math/tex">\psi\left(\vec{r}_{1}, \vec{r}_{2}, \ldots \vec{r}_{N Z}\right)=\psi_{1}\left(\vec{r}_{1}\right) \psi_{2}\left(\vec{r}_{2}\right) \ldots \psi_{N Z}\left(\vec{r}_{N Z}\right)</script>，对于能量<script type="math/tex">\varepsilon=\sum_{i=1}^{N Z} \varepsilon_{i}</script>。</p><p>这样一来，NZ体问题则简化成单电子问题。因此平均场近似又常常称之为<strong>单电子近似</strong>。</p><h2 id="周期性势场"><a href="#周期性势场" class="headerlink" title="周期性势场"></a>周期性势场</h2><p>对于上述的单粒子的哈密顿量，我们可以进一步化为</p><script type="math/tex; mode=display">\hat{H} \psi=\left[-\frac{\hbar^{2}}{2 m} \nabla^{2}+V(\vec{r})\right] \psi=\varepsilon \psi</script><p>其中</p><script type="math/tex; mode=display">V(\vec{r})=v_{e}(\vec{r})-\sum_{R_{n}} \frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{\left|\vec{r}-\vec{R}_{n}\right|}</script><p>为单电子势，源于两部分，一是电子与其它电子的平均库仑作用势，另一是所考虑的电子与离子实间的库仑作用势。</p><p>由于晶体具有周期性，单电子势应具有和晶格相同的周期性</p><script type="math/tex; mode=display">V\left(\vec{r}+\vec{R}_{l}\right)=V(\vec{r})</script><h1 id="布洛赫定理"><a href="#布洛赫定理" class="headerlink" title="布洛赫定理"></a>布洛赫定理</h1>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固体物理圣经咏唱——原子振动及其格波理论</title>
    <link href="/2020/06/27/solid%20physics/solid4/"/>
    <url>/2020/06/27/solid%20physics/solid4/</url>
    
    <content type="html"><![CDATA[<h1 id="一维单原子晶体中的原子振动"><a href="#一维单原子晶体中的原子振动" class="headerlink" title="一维单原子晶体中的原子振动"></a>一维单原子晶体中的原子振动</h1><h2 id="运动方程及其解"><a href="#运动方程及其解" class="headerlink" title="运动方程及其解"></a>运动方程及其解</h2><p><img src="/img_solid/15.png" srcset="/img/loading.gif" alt=""><br>如图单原子链中相邻原子间距 （晶格常数）为$a$，相邻原子间相互作用能为$U(a)$，我们将其展开只保留二阶项</p><script type="math/tex; mode=display">U(a+\delta)=U(a)+\frac{1}{2} \beta \delta^{2} \quad\text{where}\quad \beta=\left(\frac{\partial^{2} U}{\partial r^{2}}\right)_{a}</script><p>第$n$个原子的<strong>运动方程</strong>为</p><script type="math/tex; mode=display">m \frac{d^{2} x_{n}}{d t^{2}}=\beta\left(x_{n+1}+x_{n-1}-2 x_{n}\right) \quad(n=1,2, \ldots N)</script><p>其中<script type="math/tex">\omega=\sqrt{\frac{2 \beta}{m}}</script><br>其通解为</p><script type="math/tex; mode=display">x_{n}=A e^{-i(\omega t-q n a)}</script><p>这里的$x_n$表示原子的位移，反映的是晶体中因原子集体振动而产生的晶格振动波。描述原子集体以角频率$\omega$的平面波称为晶格振动波，简称<strong>格波</strong>。<br>可以看出晶格中各原子间振动相互间都存在着固定的相位关系，说明原子链中原子振动彼此间是关联的，呈现一种集体振动。</p><ul><li><strong>格波的波矢</strong><script type="math/tex; mode=display">\vec{q}=\frac{2 \pi}{\lambda} \vec{e}_{n}</script></li><li><strong>格波的波长</strong><script type="math/tex; mode=display">\lambda=\frac{2 \pi}{q}</script></li><li><strong>格波的相速度</strong><script type="math/tex; mode=display">v_{p}=\frac{\omega}{q}</script><h2 id="色散关系"><a href="#色散关系" class="headerlink" title="色散关系"></a>色散关系</h2>将通解带入原方程可以得到频率$\omega$和波数$q$间的关系<script type="math/tex; mode=display">\omega^{2}=\frac{2 \beta}{m}[1-\cos (q a)]</script>因为$\beta&gt;0$，故<script type="math/tex; mode=display">\omega=2 \sqrt{\frac{\beta}{m}}\left|\sin \frac{q a}{2}\right|</script>即为一维原子链或一维布喇菲格子中格波的<strong>色散关系</strong>（dispersion relation）。格波的相速度<script type="math/tex">v_{p}=\frac{2}{q} \sqrt{\frac{\beta}{m}}\left|\sin \frac{q a}{2}\right|</script>。群速度<script type="math/tex">v_{g}=a \sqrt{\frac{\beta}{m}}\left|\cos \frac{q a}{2}\right|</script><br><img src="/img_solid/16.png" srcset="/img/loading.gif" alt=""><br><strong>一种色散关系对应一支格波</strong>，因此一维单原子链中只有一种格波，其最大频率<script type="math/tex">\omega_{\max }=2 \sqrt{\frac{\beta}{m}}</script>。由于<script type="math/tex">\omega_{\max }</script>~超声波，我们称其为<strong>声学波</strong>。<br>令<script type="math/tex">K_{h}=h \frac{2 \pi}{a}</script>为倒格矢，我们有<script type="math/tex">\omega\left(q+K_{h}\right)=\omega\left(q\right)</script>，所以<script type="math/tex">\omega\left(q\right)</script>以$\frac{2\pi}{a}$为周期<h3 id="长波极限"><a href="#长波极限" class="headerlink" title="长波极限"></a>长波极限</h3>当波长$\lambda$趋向于无限长的时候，$q \rightarrow 0$，因此<script type="math/tex">\sin \left(\frac{q a}{2}\right) \approx \frac{q a}{2}</script>。可得频率和相速分别为<script type="math/tex; mode=display">\begin{array}{l}\omega \approx q a \sqrt{\frac{\beta}{m}}\quad \quad \omega \propto q\\v_{p}=a \sqrt{\frac{\beta}{m}}\quad\quad \text{constant}v_{p}=v_{g}\end{array}</script><img src="/img_solid/17.png" srcset="/img/loading.gif" alt=""><br>此时格波接近于连续介质中的弹性波。<h3 id="短波极限"><a href="#短波极限" class="headerlink" title="短波极限"></a>短波极限</h3>此时波矢接近布里渊区边界，即<script type="math/tex">q \rightarrow \pm \pi / a</script><script type="math/tex; mode=display">\begin{array}{l}\omega = a \sqrt{\frac{\beta}{m}}\quad \quad \omega_{max}\\v_{p}=\frac{2}{q} \sqrt{\frac{\beta}{m}}\quad\quad v_{g}=0 \end{array}</script><img src="/img_solid/18.png" srcset="/img/loading.gif" alt=""><br>此时格波是一种驻波，不能在晶体中传播。<h2 id="波矢q的取值"><a href="#波矢q的取值" class="headerlink" title="波矢q的取值"></a>波矢q的取值</h2>为了保证 $\omega$ 与 $q$ 之间有一一对应的关系，把 $q$ 限制在第一布里洲区，即<script type="math/tex">-\frac{\pi}{a}<q \leq \frac{\pi}{a}</script>。此时$q$只能取一些分立的值。<br><strong>玻恩－卡门周期性边界条件</strong></li><li>在一个长度为 的有限晶 体外仍然有无限多个相同的晶体，且各块晶体内相对应的原子的运动情况相同</li><li><img src="/img_solid/19.png" srcset="/img/loading.gif" alt=""><br>由此我们可以得到$q$的取值<script type="math/tex; mode=display">q=\frac{2 \pi l}{N a}</script>其中$l$为0或任何正、负整数。在第一布里渊区（<script type="math/tex">-\frac{\pi}{a}<q \leq \frac{\pi}{a}</script>）内，$l$有N个不同的值<script type="math/tex; mode=display">l=-\frac{N}{2}+1,-\frac{N}{2}+2, \ldots . \frac{N}{2}-1, \frac{N}{2}</script></li></ul><h1 id="一维双原子晶体中的原子振动"><a href="#一维双原子晶体中的原子振动" class="headerlink" title="一维双原子晶体中的原子振动"></a>一维双原子晶体中的原子振动</h1><h2 id="运动方程及其解-1"><a href="#运动方程及其解-1" class="headerlink" title="运动方程及其解"></a>运动方程及其解</h2><p><img src="/img_solid/20.png" srcset="/img/loading.gif" alt=""><br><strong>运动方程</strong></p><script type="math/tex; mode=display">\left\{\begin{array}{c}m \frac{d^{2} x_{2 n+1}}{d t^{2}}=\beta\left(x_{2 n+2}+x_{2 n}-2 x_{2 n+1}\right) \\M \frac{d^{2} x_{2 n+2}}{d t^{2}}=\beta\left(x_{2 n+3}+x_{2 n+1}-2 x_{2 n+2}\right)\end{array}\right.</script><p>通解</p><script type="math/tex; mode=display">\left\{\begin{array}{l}x_{2 n+1}=A e^{i[q(2 n+1) a-\omega t]} \\x_{2 n+2}=B e^{i[q(2 n+2) a-\omega t]}\end{array}\right.</script><h2 id="色散关系-1"><a href="#色散关系-1" class="headerlink" title="色散关系"></a>色散关系</h2><p>将通解带入原方程可以得到两支独立的格波</p><script type="math/tex; mode=display">\begin{array}{l}\omega_{+}^{2}=\frac{\beta}{M m}\left\{(m+M)+\left[m^{2}+M^{2}+2 m M \cos (2 q a)\right]^{\frac{1}{2}}\right\} \\\omega_{-}^{2}=\frac{\beta}{M m}\left\{(m+M)-\left[m^{2}+M^{2}+2 m M \cos (2 q a)\right]^{\frac{1}{2}}\right\}\end{array}</script><p><img src="/img_solid/21.png" srcset="/img/loading.gif" alt=""><br>他们的周期都为$\frac{\pi}{a}$，第一布里渊区为<script type="math/tex">-\frac{\pi}{2 a}<q \leq \frac{\pi}{2 a}</script></p><h3 id="色散关系中的一些特殊值"><a href="#色散关系中的一些特殊值" class="headerlink" title="色散关系中的一些特殊值"></a>色散关系中的一些特殊值</h3><ul><li>光学波<script type="math/tex">\omega_{+}</script><ul><li><script type="math/tex; mode=display">\left(\omega_{+}\right)_{\max }=\sqrt{\frac{2 \beta}{\mu}}</script></li><li><script type="math/tex; mode=display">\left(\omega_{+}\right)_{\min }=\sqrt{\frac{2 \beta}{m}}</script></li></ul></li><li>声学波<script type="math/tex">\omega_{-}</script><ul><li><script type="math/tex; mode=display">\left(\omega_{-}\right)_{\max }=\sqrt{\frac{2 \beta}{M}}</script></li><li><script type="math/tex; mode=display">\left(\omega_{-}\right)_{\min }=0</script></li></ul></li></ul><p>在布里渊区边界存在频率<strong>禁带宽度</strong></p><script type="math/tex; mode=display">\Delta \omega=\left(\omega_{+}\right)_{\min }-\left(\omega_{-}\right)_{\max }=\sqrt{2 \beta}(\sqrt{\frac{1}{m}}-\sqrt{\frac{1}{M}})</script><h3 id="声学波"><a href="#声学波" class="headerlink" title="声学波"></a>声学波</h3><p>若令<script type="math/tex">\mu=\frac{m M}{m+M}</script>，由于<script type="math/tex">\frac{4 \mu}{m+M} \sin ^{2}(q a) \ll 1</script>，声学波的频率近似表示为</p><script type="math/tex; mode=display">\omega_{-}=\sqrt{\frac{2 \beta}{m+M}}|\sin (q a)|</script><p><img src="/img_solid/22.png" srcset="/img/loading.gif" alt=""><br><strong>声学波的长波极限</strong>（<script type="math/tex">q \rightarrow 0</script>）</p><script type="math/tex; mode=display">\omega_{-} \approx \sqrt{\frac{2 \beta}{m+M}} a|q|</script><script type="math/tex; mode=display">v_{p}=v_{g}=\sqrt{\frac{2 \beta}{m+M}} a</script><p><strong>声学波的振幅特征</strong></p><script type="math/tex; mode=display">\frac{A_{-}}{B_{-}}=\frac{2 \beta \cos q a}{2 \beta-m \omega_{-}^{2}}> 0</script><p>这意味着相邻原子都是沿着同一方向振动。<br><strong>声学波实际上代表原胞质心的运动</strong></p><h3 id="光学波"><a href="#光学波" class="headerlink" title="光学波"></a>光学波</h3><script type="math/tex; mode=display">\omega_{+}^{2} \approx \frac{2 \beta}{m M}(m+M)\left\{1-\frac{m M}{(m+M)^{2}} \sin ^{2} q a\right\}</script><p><img src="/img_solid/23.png" srcset="/img/loading.gif" alt=""><br><strong>光学波的振幅特征</strong></p><script type="math/tex; mode=display">\frac{A_{+}}{B_{+}}=\frac{2 \beta-M \omega_{+}^{2}}{2 \beta \cos q a}<0</script><p><strong>光学波实际上代表原胞中原子的相对的运动</strong></p><h2 id="波矢q的取值-1"><a href="#波矢q的取值-1" class="headerlink" title="波矢q的取值"></a>波矢q的取值</h2><script type="math/tex; mode=display">q=\frac{\pi l}{N a}</script><p>其中$l$为0或任何正、负整数。在第一布里渊区（<script type="math/tex">-\frac{\pi}{2 a}<q \leq \frac{\pi}{2 a}</script>）内，$l$有N个不同的值</p><script type="math/tex; mode=display">l=-\frac{N}{2}+1,-\frac{N}{2}+2, \ldots . \frac{N}{2}-1, \frac{N}{2}</script><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p><strong>一个布里渊区里，晶格振动频率的数目和晶体的总自由度数相等。</strong>即在一个布里渊区内</p><ul><li>晶体原胞数=波矢$q$取值的个数</li><li>原子种类的个数=色散关系的个数<h2 id="三维多原子晶体中的原子振动"><a href="#三维多原子晶体中的原子振动" class="headerlink" title="三维多原子晶体中的原子振动"></a>三维多原子晶体中的原子振动</h2><img src="/img_solid/24.png" srcset="/img/loading.gif" alt=""><br>对纵波，原子振动方向与波的传播方向一致，而对横 波，原子振动与波传播方向垂直。</li></ul><h1 id="原子振动的量子理论"><a href="#原子振动的量子理论" class="headerlink" title="原子振动的量子理论"></a>原子振动的量子理论</h1><p>哈密顿算符：</p><script type="math/tex; mode=display">\hat{H}=\hat{T}+\hat{U}=\sum_{n} \frac{\hat{p}_{n}^{2}}{2 m}+\frac{1}{2} \beta \sum_{n}\left(x_{n-1}-x_{n}\right)^{2}</script><p>可以看到交叉项很麻烦，为此我们经行表象变化</p><script type="math/tex; mode=display">x_{n, q}=A e^{-i(\omega t-q n a)}=\sum_{q} x_{n, q}=\sum_{q} w_{q} \frac{1}{\sqrt{N}} e^{i n q a}</script><p>其中<script type="math/tex">w_{q}(t)=\sqrt{N} A e^{-i \omega t}</script>。可以证明<script type="math/tex">\left\{\frac{1}{\sqrt{N}} e^{i n q a}\right\}</script>是完备且正交归一的<br>则变化后的哈密顿量为</p><script type="math/tex; mode=display">\hat{H}=\sum_{q}\left(\frac{\hat{p}_{q}^{2}}{2 m}+\frac{1}{2} m \omega_{q}^{2} w_{q}^{2}\right)</script><p>对单一$q$解为</p><script type="math/tex; mode=display">\varepsilon_{q}=\left(n_{q}+\frac{1}{2}\right) \hbar \omega_{q} \quad\left(n_{q}=0,1,2 \ldots .\right)</script><h1 id="声子"><a href="#声子" class="headerlink" title="声子"></a>声子</h1><p>对于晶体中的格波，其能量是量子化的，且格波最小的能量单元（能量量子）是<script type="math/tex">\hbar \omega_{s}(\vec{q})</script>。格波能量的增减必须是<script type="math/tex">\hbar \omega_{s}(\vec{q})</script>的整数倍，这种激发我们可以将其看成‘粒子’，称之为<strong>声子</strong>（phonon）。<br>当我们忽略掉零点能</p><script type="math/tex; mode=display">\varepsilon_{q s}=n_{q s} \hbar \omega_{s}(\vec{q})</script><p>这里<script type="math/tex">n_{q s}</script>可以理解为能量为<script type="math/tex">\hbar \omega_{s}(\vec{q})</script>的声子能级上的声子数。在温度为T时，声子能级<script type="math/tex">\hbar \omega_{s}(\vec{q})</script>上有<script type="math/tex">n_{q s}</script>个声子的<strong>几率</strong>为</p><script type="math/tex; mode=display">P_{n_{q s}}=\frac{e^{-n_{q s} \hbar \omega_{s}(\vec{q}) / k_{B} T}}{\sum_{n_{q s}} e^{-n_{q s} \hbar \omega_{s}(\vec{q}) / k_{B} T}}</script><p>由此<strong>平均声子占据数</strong></p><script type="math/tex; mode=display">n_{q s}(T)=\frac{1}{e^{h \omega_{s}(\bar{q}) / k_{B} T}-1}</script><p>由此可见<strong>声子是玻色子，服从玻色统计分布。</strong><br>频率为<script type="math/tex">\omega_{s}(\vec{q})</script>的格波的<strong>平均能量</strong></p><script type="math/tex; mode=display">\overline{\varepsilon_{q s}(T)}=n_{q s}(T) \hbar \omega_{s}(\vec{q})=\frac{\hbar \omega_{s}(\vec{q})}{e^{\hbar \omega_{s}(\bar{q}) / k_{B} T}-1}</script><p>由此可知声子对<strong>比热</strong>的贡献</p><script type="math/tex; mode=display">C_{V}^{q s} \equiv \frac{\partial \varepsilon_{q s}(T)}{\partial T}=k_{B}\left[\frac{\hbar \omega_{s}(\vec{q})}{k_{B} T}\right]^{2} \frac{e^{\hbar \omega_{s}(\vec{q}) / k_{B} T}}{\left[e^{\hbar \omega_{s}(\vec{q}) / k_{B} T}-1\right]^{2}}</script><p>则总比热为</p><script type="math/tex; mode=display">C_{V}=\sum_{q, s}^{3 n N} C_{V}^{q}</script><ul><li>高温极限<script type="math/tex">k_{B} T>>\hbar \omega_{s}(\vec{q})</script>，我们展开exp指数可以得到<script type="math/tex; mode=display">C_{V}=\sum_{q, s}^{3 n N} C_{V}^{q s}=3 n N k_{B}</script>这正是杜隆-珀替理论所给出的结果。</li><li>低温极限<script type="math/tex">k_{B} T<<\hbar \omega_{s}(\vec{q})</script>，此时有<script type="math/tex">e^{\hbar \omega_{s}(\vec{q}) / k_{B} T}>>1</script><script type="math/tex; mode=display">C_{V} \approx \sum_{q, s}^{3 n N} k_{B}\left[\frac{\hbar \omega_{s}(\vec{q})}{k_{B} T}\right]^{2} e^{-\hbar \omega_{s}(\bar{q}) / k_{B} T}</script>可见，在低温极限下，晶格比热随温度降低按指数规律快速趋向于0，与实验相符。</li></ul><h1 id="声子谱"><a href="#声子谱" class="headerlink" title="声子谱"></a>声子谱</h1><p>对由N个原胞、每个原胞中有n个原子组成的三 维多原子晶体，总的晶格振动能在<script type="math/tex">V \rightarrow \infty</script>时可以写为积分形式</p><script type="math/tex; mode=display">E(T)=\frac{V}{(2 \pi)^{3}} \sum_{s} \int_{\Omega^{\prime}} \varepsilon_{q s}(T) d \vec{q}</script><p>其中<script type="math/tex">\varepsilon_{q s}(T)=\frac{\hbar \omega_{s}(\vec{q})}{e^{\hbar \omega_{s}(\vec{q}) / k_{B} T}-1}, \quad \Omega^{*}=\frac{(2 \pi)^{3}}{\Omega}, \quad \Omega</script>为正格子空间原胞的体积。我们可以将其写为</p><script type="math/tex; mode=display">E(T)=\int_{0}^{\infty} \varepsilon(\omega, T) {g}(\omega) {d} \omega</script><p>其中<script type="math/tex">g(w)</script>即为声子频率的分布函数，简称<strong>声子谱</strong>。<script type="math/tex">{g}(\omega)</script>可以由色散关系推出<br>我们可以将<script type="math/tex">g(\omega)</script>定义为</p><script type="math/tex; mode=display">g(\omega)=\lim _{ \Delta \omega \rightarrow 0} \frac{\Delta n}{\Delta \omega }</script><p>即在<script type="math/tex">\omega \sim \omega+\Delta \omega</script>频率间隔内的振动模式数<script type="math/tex">\Delta n</script></p><script type="math/tex; mode=display">\left\{\begin{array}{l}\Delta n=\frac{V}{(2 \pi)^{2}} \iint d S_{\omega} d q \quad\quad d S_{\omega}\text{为等频面上的面积元}\\\Delta \omega=d q\left|\nabla_{q} \omega(q)\right| \quad \quad dq \text{为等频面内的垂直距离}\end{array}\right.</script><p>由此可以推出</p><script type="math/tex; mode=display">g_{3 D}(\omega)=\frac{V}{(2 \pi)^{3}} \sum_{s} \int_{S_{\omega}} \frac{d s}{\left|\nabla_{\bar{q}} \omega_{s}(\vec{q})\right|}</script><script type="math/tex; mode=display">g_{2 D}(\omega)=\frac{S}{(2 \pi)^{2}} \sum_{s} \int_{l_{o}} \frac{d l}{\left|\nabla_{\bar{q}} \omega_{s}(\vec{q})\right|}</script><script type="math/tex; mode=display">g_{1 D}(\omega)=\frac{L}{2 \pi} \sum_{s} \frac{2}{\left|\nabla_{\bar{q}} \omega_{s}(\vec{q})\right|}</script><p>通过$g(w)$我们可以计算</p><ul><li>平均晶格振动能<script type="math/tex; mode=display">\bar{E} (T)=\int_{0}^{\infty} E(T,\omega)  g(\omega) d \omega</script></li><li>晶格比热<script type="math/tex; mode=display">C_{V}=\frac{\partial \bar{E}}{\partial T}=\int_{0}^{\infty} \frac{\partial E(T, \omega)}{\partial T} g(\omega) d \omega</script>其中<script type="math/tex">E(T, \omega)=\frac{\hbar \omega}{e^{\hbar \omega / k_{B} T}-1}</script></li></ul><h1 id="晶格比热的模型"><a href="#晶格比热的模型" class="headerlink" title="晶格比热的模型"></a>晶格比热的模型</h1><h2 id="经典比热理论"><a href="#经典比热理论" class="headerlink" title="经典比热理论"></a>经典比热理论</h2><p>$N$个原子，每个原子有3个自由度，且每个自由度的平均热能为<script type="math/tex">k_{B}T</script>，则平均内能为<script type="math/tex">\bar{E}=3k_{B}T</script>。则原子定容比热为</p><script type="math/tex; mode=display">C_{V}=3 N k_{B}</script><p>这即为杜隆-珀替定律</p><h2 id="爱因斯坦模型"><a href="#爱因斯坦模型" class="headerlink" title="爱因斯坦模型"></a>爱因斯坦模型</h2><p>晶体中每个原子都以同一<script type="math/tex">\omega_{E}</script>频率振动，且振动的能量量子<script type="math/tex">\hbar \omega_{E}</script>。则平均能量为</p><script type="math/tex; mode=display">\bar{E}(T)=\frac{\sum_{j=1}^{3 N} \hbar \omega_{j} e^{-\hbar \omega_{j} / k_{B} T}}{\sum_{j=1}^{3 N} e^{-\hbar \omega_{j} k_{B} T}}=\sum_{j=1}^{3 N} \frac{\hbar \omega_{j}}{e^{\hbar \omega_{j} / k_{B} T}-1}=\frac{3 N \hbar \omega_{E}}{e^{\hbar \omega_{E} / k_{B} T}-1}</script><p>则<strong>晶格比热</strong>为</p><script type="math/tex; mode=display">C_{V}=3 N k_{B}\left(\frac{\hbar \omega_{E}}{k_{B} T}\right)^{2} \frac{e^{\hbar \omega_{E} / k_{B} T}}{\left(e^{\hbar \omega_{E} / k_{B} T}-1\right)^{2}}</script><p>若我们令<strong>爱因斯坦温度</strong><script type="math/tex">\theta_{E}=\hbar \omega_{E} / k_{B}</script>，且<strong>爱因斯坦比热函数</strong><script type="math/tex">f_{E}\left(\frac{\theta_{E}}{T}\right)=\left(\frac{\theta_{E}}{T}\right)^{2} \frac{e^{\frac{\theta_{E}}{T}}}{\left(e^{\frac{\theta_{E}}{T}}-1\right)^{2}}</script>。则我们有</p><script type="math/tex; mode=display">C_{V}=3 N k_{B} f_{E}\left(\frac{\theta_{E}}{T}\right)</script><ul><li>高温极限<script type="math/tex">T \gg \theta_{E}</script>，我们展开爱因斯坦比热函数<script type="math/tex">f_{E}\approx 1</script><script type="math/tex; mode=display">C_{V} \approx 3 N k_{B}</script>与杜隆-珀替理论结果相同。这是因为在高温区，量子化效应可以忽略</li><li>低温极限<script type="math/tex">T \ll \theta_{E}</script><script type="math/tex; mode=display">C_{V}=3 N k_{B}\left(\frac{\Theta_{E}}{T}\right)^{2} e^{-\Theta_{E} / T}</script>随温度降低按温度的指数形式趋于0</li></ul><p>由此爱因斯坦的模型可以解释在低温时，比热趋于0的问题。但实验中测得晶格比热在低温下是按照<script type="math/tex">C_{V} \propto T^{3}</script>规律趋于 0 的。与爱因斯坦模型不符。原因是因为其忽略了每个原子和它的近邻原子的联系，而这在低温下其很大作用。</p><h2 id="德拜模型"><a href="#德拜模型" class="headerlink" title="德拜模型"></a>德拜模型</h2><p>德拜模型中将布喇菲格子看作是各向同性的连续介质，而将格波看成是弹性波。<strong>本质：</strong>考虑的是声学波中的长波极限对比热的贡献。<br>长波极限下，纵波和横波的色散关系分别为：</p><script type="math/tex; mode=display">\begin{array}{ll}\text { 纵波 }: & \omega=v_{l} q \\\text { 横波 }: & \omega=v_{l} q\end{array}</script><p>带入<script type="math/tex">g_{3 D}(\omega)=\frac{V}{(2 \pi)^{3}} \int_{S_{\omega}} \frac{d s}{\left|\nabla_{\bar{q}} \omega(\vec{q})\right|}</script>。其中<script type="math/tex">\nabla_{\vec{q}} \omega(\vec{q})=v_{l}, \quad \int_{S_{\omega}} d s=4 \pi q^{2}=4 \pi\left(\frac{\omega^{2}}{v_{l}^{2}}\right)</script>（横波同理）因此有</p><script type="math/tex; mode=display">g_{3 D}(\omega)=\frac{V}{(2 \pi)^{3}}\left[\frac{4 \pi \omega^{2}}{v_{l}^{3}}+2 \times \frac{4 \pi \omega^{2}}{v_{t}^{3}}\right]=\frac{3 V}{2 \pi^{3} \bar{v}^{3}} \omega^{2}</script><p>定义格波的平均波速为<script type="math/tex">\frac{3}{\bar{v}^{3}}=\left(\frac{1}{v_{l}^{3}}+\frac{2}{v_{t}^{3}}\right)</script><br>此时对<script type="math/tex">g_{3 D}</script>的积分发散，为解决这个问题，德拜假设存在一个频率上限<script type="math/tex">\omega_{m}</script>，称之为德拜频率。大于<script type="math/tex">\omega_{m}</script>的波是不存在的，即</p><script type="math/tex; mode=display">\int_{0}^{\omega_{m}} g_{3 D}(\omega) d \omega=3 N</script><p>计算可得<strong>德拜频率</strong></p><script type="math/tex; mode=display">\omega_{m}=\bar{v}\left[6 \pi^{2}\left(\frac{N}{V}\right)\right]^{\frac{1}{3}}.</script><p>则晶格比热为</p><script type="math/tex; mode=display">C_{V}=\frac{3 V}{2 \pi^{2} \bar{v}^{3}} \int_{0}^{\omega_{m}} k_{B}\left(\frac{\hbar \omega}{k_{B} T}\right)^{2} \frac{e^{\hbar \omega / k_{B} T}}{\left(e^{\hbar \omega / k_{B} T}-1\right)^{2}} \omega^{2} d \omega=3 N k_{B} f_{D}\left(\frac{T}{\theta_{D}}\right)</script><p><strong>德拜温度</strong></p><script type="math/tex; mode=display">\theta_{D}=\frac{\hbar \omega_{m}}{k_{B}}</script><p><strong>德拜比热函数</strong></p><script type="math/tex; mode=display">f_{D}\left(T / \theta_{D}\right)=3 \left[\frac{T}{\theta_{D}}\right]^3 \int_{0}^{\theta_{D} / T} \frac{\xi^{4} e^{\xi}}{\left(e^{\xi}-1\right)^{2}} d \xi</script><p>其中<script type="math/tex">\xi=\frac{\hbar \omega}{k_{B} T}</script></p><ul><li>高温极限<script type="math/tex">T \gg \theta_{D}</script>，<script type="math/tex">\xi=\frac{\hbar \omega}{k_{B} T} \ll 1</script>，即<script type="math/tex">f_{D}\left(T / \theta_{D}\right) \approx 1</script><script type="math/tex; mode=display">C_{V} \approx 3 N k_{B}</script></li><li>低温极限<script type="math/tex">T \ll \theta_{D}</script>，此时积分上限可取为<script type="math/tex">\infty</script>。即<script type="math/tex">\int_{0}^{\theta_{0} / T}  \rightarrow \int_{0}^{\infty} =\frac{4 \pi^{4}}{15}</script><script type="math/tex; mode=display">C_{V}=\frac{12 \pi^{4} N k_{B}}{5}\left(\frac{T}{\theta_{D}}\right)^{3}</script>低温下晶格比热和温度$T^3$成比例，称为<strong>德拜定律</strong>。</li></ul><p>德拜模型可以很好的解释低温与高温的晶体比热情况，尤其是低温情况，这时因为低温下晶格振动以长波为主。在德拜模型中德拜温度是一个与温度无关的常数，但事实上是温度有关的函数。这是因为德拜模型过于简单，特别是德拜模型实际上只考虑了长声学波对比热的贡献，在中间温度或高温时，其它波长的声学波激发也是可能的。</p><h1 id="非谐效应"><a href="#非谐效应" class="headerlink" title="非谐效应"></a>非谐效应</h1>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热力学与统计物理圣经咏唱——热力学第零定理、态函数、温度</title>
    <link href="/2020/06/24/Thermal/temperature/"/>
    <url>/2020/06/24/Thermal/temperature/</url>
    
    <content type="html"><![CDATA[<h1 id="热力学中的名词"><a href="#热力学中的名词" class="headerlink" title="热力学中的名词"></a>热力学中的名词</h1><ul><li><strong>系统：</strong>宇宙中我们研究的对象。而其他部分称为<strong>环境</strong>。</li><li>系统的<strong>分类：</strong><ul><li><strong>孤立系统 (isolated system):</strong>系统与环境之间既没有能量交换，也没有物质交换。</li><li><strong>封闭系统 (closed system):</strong>系统与环境之间有能量交换，但没有物质交换。</li><li><strong>开放系统 (open system):</strong>系统与环境之间既有能量交换，也有物质交换。</li></ul></li><li><strong>平衡态：</strong>对于孤立系统，当一段时间后，我们去测量宏观参量其平均值不会发生变化即达到平衡态。平衡态是一个动态的平衡。</li><li><strong>宏观参量：</strong>也称为热力学量。</li><li><strong>微观参量：</strong>描述系统粒子状态的量。</li><li><strong>广延量：</strong>其大小随系统的大小改变的量，如体积，粒子数熵，能量等。</li><li><strong>强度量：</strong>不随系统的大小改变而变化的量。如温度，化学势，粒子数密度等。</li><li><strong>热力学极限：</strong>在粒子数保持不变，粒子数 $N \rightarrow \infty,$ 体积 $V \rightarrow \infty$ 的极限状态。</li><li><strong>状态参量：</strong>对于一个处于平衡态的系统，我们往往只需要少数几个相互独立的宏观参量来描述其状态，而这些态就为状态参量。状态参量与过程无关。如体积$V$，压强$P$，温度$T$等。</li><li><strong>过程量：</strong>只有指定了具体过程后才能确定下来的量，一般来说过程不同过程量也不同，</li><li><strong>状态函数：</strong>在平衡态中选定一个状态参量，其他的状态参量即为其的函数。写程方程就为<strong>状态方程</strong></li></ul><h1 id="热容"><a href="#热容" class="headerlink" title="热容"></a>热容</h1><p><strong>热量</strong>表示的是两个系统在达到热平衡过程中进行的能量传递或转移，为过程量。<br><strong>热容</strong>描述的是一个物体存储能量的能力，定义为</p><script type="math/tex; mode=display">C \equiv \frac{d Q}{d T}</script><p>即使物体温度升高单位温度需要传递给它的热量。热容是一个广延量，而比热容 (specific heat capacity)（表示单位质量的物质的热容）则为强度量。</p><ul><li><strong>定容热容</strong><script type="math/tex; mode=display">C_{V} \equiv\left(\frac{d Q}{d T}\right)_{V}</script></li><li><strong>定压热容</strong>‘<script type="math/tex; mode=display">C_{P} \equiv\left(\frac{d Q}{d T}\right)_{P}</script></li></ul><h1 id="第零定律"><a href="#第零定律" class="headerlink" title="第零定律"></a>第零定律</h1><p><strong>热力学第零定律：</strong>如果两个系统中每一个都和第三个系统单独处于热平衡， 那么这两个系统之间也处于热平衡。<br>第零定律反映了热平衡的可传递性。</p><h1 id="温度"><a href="#温度" class="headerlink" title="温度"></a>温度</h1><p>我们把系统 1（$P_1, V_1$ ）与系统3 $\left(P_3, V_3\right)$ 进行热接触。当达到热平衡时，调整其中一个量其他量也变化，这意味着这四个变量间应该存在一定的关系：</p><script type="math/tex; mode=display">P_{3}=f_{31}\left(V_{3}, P_{1}, V_{1}\right)</script><p>当系统 2 和系统 3 达到热平衡</p><script type="math/tex; mode=display">P_{3}=f_{32}\left(V_{3}, P_{2}, V_{2}\right)</script><p>我们有</p><script type="math/tex; mode=display">f_{32}\left(V_{3}, P_{2}, V_{2}\right)=f_{31}\left(V_{3}, P_{1}, V_{1}\right)</script><p>使用热力学第零定律，我们有系统 1 和 2 也处于热平衡状态，</p><script type="math/tex; mode=display">F_{21}\left(P_{2}, V_{2}, P_{1}, V_{1}\right)=0</script><p>也就是说上面两个式子等价，可以发现$V_3$只出现在一个式子中，这意味着我们可以在$f$中提取出$V_3$</p><script type="math/tex; mode=display">\begin{array}{l}f_{31}\left(V_{3}, P_{1}, V_{1}\right)=a\left(V_{3}\right) f_{1}\left(P_{1}, V_{1}\right)+b\left(V_{3}\right) \\f_{32}\left(V_{3}, P_{2}, V_{2}\right)=a\left(V_{3}\right) f_{2}\left(P_{2}, V_{2}\right)+b\left(V_{3}\right)\end{array}</script><p>这时我们有</p><script type="math/tex; mode=display">f_{2}\left(P_{2}, V_{2}\right)=f_{1}\left(P_{1}, V_{1}\right)</script><p>同理就可以得到</p><script type="math/tex; mode=display">f_{1}\left(P_{1}, V_{1}\right)=f_{2}\left(P_{2}, V_{2}\right)=f_{3}\left(P_{3}, V_{3}\right)</script><p>这说明，每个系统都存在一个态函数<script type="math/tex">f_{i}\left(P_{i}, V_{i}\right)</script>, 当系统相互处于热平衡时, 该态函数彼此相等。于是我们定义一个状态参量“温度”$T$：</p><script type="math/tex; mode=display">g\left(T_{i}\right)=f_{i}\left(P_{i}, V_{i}\right)</script><p>这样，当两个系统达到热平衡后，<script type="math/tex">g\left(T_{1}\right)=g\left(T_{2}\right)</script>。函数 $g$ 可以选取不同的形式。最为简单的选取就是<script type="math/tex">g(T)=T</script><br>这样当热平衡时我们就可以说是温度相同了。</p><p>在前面讨论中的T与其他状态参量的函数关系我们称为<strong>状态方程</strong>。对理想气体来说<script type="math/tex">P V=N k_{B} T</script>。</p><h2 id="温标"><a href="#温标" class="headerlink" title="温标"></a>温标</h2><ul><li>摄氏温标 (‘C)：把一个标准大气压下，水的沸点定位 100 度，水的冰点定 位 0 度。</li><li>华氏温标 (‘PF)：它与摄氏温标换算关系： $F=32+\frac{9}{5} C$</li><li>理想气体温标 (K)：利用理想气体状态方程 PV = ルRT 定义温度，这样的 话，水的三相点温度为 273.16 K。与摄氏度换算关系为： $K=C-273.15$</li><li>热力学温标 (K): 利用卡诺循环来定义。</li></ul>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A review about The Quantum Hall Effect</title>
    <link href="/2020/06/23/reviewreed/qeh/"/>
    <url>/2020/06/23/reviewreed/qeh/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h1><h2 id="The-Classical-Hall-Effect"><a href="#The-Classical-Hall-Effect" class="headerlink" title="The Classical Hall Effect"></a>The Classical Hall Effect</h2><p>As we can see in the following figure, the magnetic field B point in the z-direction, and the electrons are restricted to move only in the $(x, y)$ plane.<br><img src="/img_qhe/1.png" srcset="/img/loading.gif" alt=""><br>If there is a constant current $I$ flowing in the x-direction, The Hall effect may appear which means that a voltage $V_H$ will appear in the y-direction.</p><h3 id="Classical-Motion-in-Classical-Hall-Effect"><a href="#Classical-Motion-in-Classical-Hall-Effect" class="headerlink" title="Classical Motion in Classical Hall Effect"></a>Classical Motion in Classical Hall Effect</h3><p>In classical Hall Effect the particles in materials move in circles due to the Lorentz Force. Which is </p><script type="math/tex; mode=display">m \frac{d \mathbf{v}}{d t}=-e \mathbf{v} \times \mathbf{B}</script><p>where we set a particle of mass $m$ and charge $−e$ in a magnetic field $B=(0,0, B)$.<br>So $v=(\dot{x}, \dot{y}, 0)$, and the equations of motion are </p><script type="math/tex; mode=display">m \ddot{x}=-e B \dot{y} \quad \text { and } \quad m \ddot{y}=e B \dot{x}</script><p>The solution is </p><script type="math/tex; mode=display">x(t)=X-R \sin \left(\omega_{B} t+\phi\right) \quad \text { and } \quad y(t)=Y+R \cos \left(\omega_{B} t+\phi\right)</script><p>This indicate the particle moves in circles. Moreover, the frequency with which the particle goes around the circle is</p><script type="math/tex; mode=display">\omega_{B}=\frac{e B}{m}</script><p>We call it as <strong>cyclotron frequency</strong></p><h3 id="The-Drude-Model"><a href="#The-Drude-Model" class="headerlink" title="The Drude Model"></a>The Drude Model</h3><p>Now we take the electric field $E$ and scattering into consideration.</p><script type="math/tex; mode=display">m \frac{d \mathbf{v}}{d t}=-e \mathbf{E}-e \mathbf{v} \times \mathbf{B}-\frac{m \mathbf{v}}{\tau}</script><p>Where the coefficient $\tau$ is called the scattering time which can be regard as the average time between collisions. This equation of motion lead to The Drude Model.<br>If we set $d \mathbf{v} / d t=0$ and use cyclotron frequency to represent the result, we obtain </p><script type="math/tex; mode=display">\left(\begin{array}{cc}1 & \omega_{B} \tau \\-\omega_{B} \tau & 1\end{array}\right) \mathbf{J}=\frac{e^{2} n \tau}{m} \mathbf{E}</script><p>Where the current density $\mathbf{J}=-ne\mathbf{v}$.<br>By using Ohm’s law $\mathbf{J}=\sigma \mathbf{E}$, where<script type="math/tex">\sigma=\left(\begin{array}{cc}\sigma_{x x} & \sigma_{x y} \\ -\sigma_{x y} & \sigma_{x x}\end{array}\right)</script>, we can obtain the <strong>conductivity</strong> tensor from the Drude model.</p><script type="math/tex; mode=display">\sigma=\frac{\sigma_{D C}}{1+\omega_{B}^{2} \tau^{2}}\left(\begin{array}{cc}1 & -\omega_{B} \tau \\\omega_{B} \tau & 1\end{array}\right) \quad \text { with } \quad \sigma_{D C}=\frac{n e^{2} \tau}{m}</script><p>The off-diagonal terms in the matrix are responsible for the Hall effect</p><h3 id="Resistivity-vs-Resistance"><a href="#Resistivity-vs-Resistance" class="headerlink" title="Resistivity vs Resistance"></a>Resistivity vs Resistance</h3><p>The <strong>resistivity</strong> is defined as</p><script type="math/tex; mode=display">\rho=\sigma^{-1}=\left(\begin{array}{cc}\rho_{x x} & \rho_{x y} \\-\rho_{x y} & \rho_{y y}\end{array}\right)</script><p>In Drude model we have </p><script type="math/tex; mode=display">\rho=\frac{1}{\sigma_{D C}}\left(\begin{array}{cc}1 & \omega_{B} \tau \\-\omega_{B} \tau & 1\end{array}\right)</script><p>We can calculate that<script type="math/tex">\rho_{x y}=\omega_{B} \tau / \sigma_{D C}</script>. It’s interesting to find that<script type="math/tex">\rho_{x y}</script> are independent of the scattering time. Moreover, when we we measure the <strong>resistance</strong> $R$</p><script type="math/tex; mode=display">R_{x y}=\frac{V_{y}}{I_{x}}=\frac{L E_{y}}{L J_{x}}=\frac{E_{y}}{J_{x}}=-\rho_{x y}</script><p>Which has nothing about geometric factors.<br>And the Hall coefficient is</p><script type="math/tex; mode=display">R_{H}=-\frac{E_{y}}{J_{x} B}=\frac{\rho_{x y}}{B}</script><p>In the Drude model, we have</p><script type="math/tex; mode=display">R_{H}=\frac{\omega_{B}}{B \sigma_{D C}}=\frac{1}{n e}</script><p>Which means The Hall effect depends only on microscopic information about the material.<br>What’s more, we calculate the two resistivities</p><script type="math/tex; mode=display">\rho_{x x}=\frac{m}{n e^{2} \tau} \quad \text { and } \quad \rho_{x y}=\frac{B}{n e}</script><p>And plot them as a function of the magnetic field<br><img src="/img_qhe/2.png" srcset="/img/loading.gif" alt=""></p><h2 id="Quantum-Hall-Effects"><a href="#Quantum-Hall-Effects" class="headerlink" title="Quantum Hall Effects"></a>Quantum Hall Effects</h2><h3 id="Integer-Quantum-Hall-Effect-IQHE"><a href="#Integer-Quantum-Hall-Effect-IQHE" class="headerlink" title="Integer Quantum Hall Effect (IQHE)"></a>Integer Quantum Hall Effect (IQHE)</h3><p><img src="/img_qhe/3.png" srcset="/img/loading.gif" alt=""><br>In 1980， von Klitzing found Integer Quantum Hall Effect. He found there exist a plateau in the plot of Hall resistivity<script type="math/tex">\rho_{x y}</script>-$B$.On these plateau, the resistivity takes the value</p><script type="math/tex; mode=display">\rho_{x y}=\frac{2 \pi \hbar}{e^{2}} \frac{1}{\nu}</script><p>$\nu$is measured to be an integer, the quantity<script type="math/tex">\frac{2 \pi \hbar}{e^{2}}</script>is called the <strong>quantum of resistivity</strong>. The centre of each of these plateaux occurs when the magnetic field takes the value</p><script type="math/tex; mode=display">B=\frac{2 \pi \hbar n}{\nu e}=\frac{n}{\nu} \Phi_{0}</script><p>Where<script type="math/tex">\Phi_{0}=2 \pi \hbar / e</script> is known as the <strong>flux quantum</strong></p><p>There some interesting things in this experiments. In the quantum Hall effect, as you increase the amount of disorder (impurities) the plateaux become more prominent. Moreover, in the absence of disorder, the plateaux are expected to vanish completely.</p><p>Besides, the longitudinal resistivity<script type="math/tex">\rho_{x x}</script> also exhibits a surprise. As we can see in the figure above, When<script type="math/tex">\rho_{x y}</script> sits on a plateau,<br>the longitudinal resistivity vanishes:<script type="math/tex">\rho_{x x}=0</script>. It spikes only when<script type="math/tex">\rho_{x y}</script> jumps to the next plateau.</p><p>In the definition of conductivity and resistivity we have </p><script type="math/tex; mode=display">\sigma_{x x}=\frac{\rho_{x x}}{\rho_{x x}^{2}+\rho_{x y}^{2}} \quad \text { and } \quad \sigma_{x y}=\frac{-\rho_{x y}}{\rho_{x x}^{2}+\rho_{x y}^{2}}</script><p>When<script type="math/tex">\rho_{x x}=0</script>and<script type="math/tex">\rho_{x y} \neq 0</script>, we obtain<script type="math/tex">\sigma_{x x}=0</script>.</p><h3 id="Fractional-Quantum-Hall-Effect-FQHE"><a href="#Fractional-Quantum-Hall-Effect-FQHE" class="headerlink" title="Fractional Quantum Hall Effect (FQHE)"></a>Fractional Quantum Hall Effect (FQHE)</h3><p>In 1982, Tsui and Stormer found as the disorder is decreased, the integer Hall plateaux become less prominent, but other plateaux emerge at fractional values.<br><img src="/img_qhe/4.png" srcset="/img/loading.gif" alt=""><br>In Fractional Quantum Hall Effect, the Hall resistivity is the same as Integer Quantum Hall Effect, but with $\nu$ a fractional number (rational number).<br>Not all fractions appear ($\nu=1 / 3,1 / 5, 2 / 5$), a clear plateaux has been observed at $\nu=5 / 2$. Particularly, as the disorder is decreased,we can get infinite number of plateaux which means a straight line in classical situation.</p><h2 id="Landau-Levels"><a href="#Landau-Levels" class="headerlink" title="Landau Levels"></a>Landau Levels</h2><p>When the free particles move in a background magnetic field, the resulting phenomenon is Landau levels.<br>The Hamiltonian is given by canonical momentum<script type="math/tex">\mathbf{p}=\frac{\partial L}{\partial \dot{\mathbf{x}}}=m \dot{\mathbf{x}}-e \mathbf{A}</script></p><script type="math/tex; mode=display">H=\frac{1}{2 m}(\mathbf{p}+e \mathbf{A})^{2}</script><p>Where the gauge potential<script type="math/tex">\mathbf{B}=\nabla \times \mathbf{A}</script></p><h3 id="Quantisation"><a href="#Quantisation" class="headerlink" title="Quantisation"></a>Quantisation</h3><p>We can set </p><script type="math/tex; mode=display">\boldsymbol{\pi}=\mathbf{p}+e \mathbf{A}=m \dot{\mathbf{x}}</script><p>Then the commutation relations following from the Poisson bracket</p><script type="math/tex; mode=display">\left\{m \dot{x}_{i}, m \dot{x}_{j}\right\}=\left\{p_{i}+e A_{i}, p_{j}+e A_{j}\right\}=-e\left(\frac{\partial A_{j}}{\partial x^{i}}-\frac{\partial A_{i}}{\partial x^{j}}\right)=-e \epsilon_{i j k} B_{k}</script><p>Which means </p><script type="math/tex; mode=display">\left[\pi_{x}, \pi_{y}\right]=-i e \hbar B</script><p>So we can define the raising and lowering operators as </p><script type="math/tex; mode=display">a=\frac{1}{\sqrt{2 e \hbar B}}\left(\pi_{x}-i \pi_{y}\right) \quad \text { and } \quad a^{\dagger}=\frac{1}{\sqrt{2 e \hbar B}}\left(\pi_{x}+i \pi_{y}\right)</script><p>By using commutation relations of $\boldsymbol{\pi}$ we obtain </p><script type="math/tex; mode=display">\left[a, a^{\dagger}\right]=1</script><p>Now we rewrite the Hamiltonian as </p><script type="math/tex; mode=display">H=\frac{1}{2 m} \boldsymbol{\pi} \cdot \boldsymbol{\pi}=\hbar \omega_{B}\left(a^{\dagger} a+\frac{1}{2}\right)</script><p>Where $\omega_B=e B / m$ is still named as <em>cyclotron frequency</em>.<br>This form is the same the harmonic oscillator. We now define the state $|n\rangle$ and it’s energy</p><script type="math/tex; mode=display">E_{n}=\hbar \omega_{B}\left(n+\frac{1}{2}\right) \quad n \in \mathbf{N}</script><p>This energy levels are called <strong>Landau levels</strong>.</p><h3 id="The-role-of-spin"><a href="#The-role-of-spin" class="headerlink" title="The role of spin"></a>The role of spin</h3><p>There is one thing we need to consider in this section, that is Spin. The reason is that in the presence of a magnetic field B there is a Zeeman splitting between the energies of the up and down spins given by<script type="math/tex">\Delta=g \mu_{B} B</script>, where $\mu_B=e \hbar / 2 m$ is the Bohr magneton, and typically, $g=2$. It looks as if the splitting of Zeeman effect is the same as cyclotron energy in Landau levels.<br>But it’s just our wishful thinking, and the reason is twofold.</p><ul><li>The true value of the cyclotron frequency is<script type="math/tex">\omega_{B}=e B / m_{\mathrm{eff}}</script>, where<script type="math/tex">m_{\mathrm{eff}}</script> is the effective mass of the electron moving in its environment.</li><li>the $g$ factor varies due to effects of band structure. In many materials, $g$ is not equal to $2$.</li></ul><p>Generally, the picture is that the Landau levels split when we consider Zeeman effect, and the value of splitting energy can be calculate in particular band structure.<br>So we usually ignore the spin, and talk it later in Fractional Quantum Hall Effect.</p><h3 id="Landau-Gauge"><a href="#Landau-Gauge" class="headerlink" title="Landau Gauge"></a>Landau Gauge</h3><p>In this section, we choose this gauge</p><script type="math/tex; mode=display">\mathbf{A}=x B \hat{\mathbf{y}}</script><p>This is called <strong>Landau gauge</strong>. This gauge breaks translational symmetry in the x direction (but not in the y direction) and rotational symmetry.<br>Then the Hamiltonian becomes</p><script type="math/tex; mode=display">H=\frac{1}{2 m}\left(p_{x}^{2}+\left(p_{y}+e B x\right)^{2}\right)</script><p>Note that this equation have translational invariance in the $y$ direction. So we set the wavefunctions as<script type="math/tex">\psi_{k}(x, y)=e^{i k y} f_{k}(x)</script>. Then we obtain</p><script type="math/tex; mode=display">H \psi_{k}(x, y)=\frac{1}{2 m}\left(p_{x}^{2}+(\hbar k+e B x)^{2}\right) \psi_{x}(x, y) \equiv H_{k} \psi_{k}(x, y)</script><p>We can rewrite the Hamiltonian which is very familiar with a harmonic oscillator in the x direction.</p><script type="math/tex; mode=display">H_{k}=\frac{1}{2 m} p_{x}^{2}+\frac{m \omega_{B}^{2}}{2}\left(x+k l_{B}^{2}\right)^{2}</script><p>Where cyloctron frequency is<script type="math/tex">\omega_{B}=e B / m</script>, and <strong>magnetic length</strong> is<script type="math/tex">l_{B}=\sqrt{\frac{\hbar}{e B}}</script>(for $B=1T$,<script type="math/tex">l_{B} \approx 2.5 \times 10^{-8} m</script>).</p><p>The solution: the energy eigenvalues are</p><script type="math/tex; mode=display">E_{n}=\hbar \omega_{B}\left(n+\frac{1}{2}\right)</script><p>wavefunctions are </p><script type="math/tex; mode=display">\psi_{n, k}(x, y) \sim e^{i k y} H_{n}\left(x+k l_{B}^{2}\right) e^{-\left(x+k l_{B}^{2}\right)^{2} / 2 l_{B}^{2}}</script><p>Where $H_n$ is Hermite polynomial</p><h3 id="Degeneracy"><a href="#Degeneracy" class="headerlink" title="Degeneracy"></a>Degeneracy</h3><p>Now we restrict system to a finite region of the (x, y)-plane which is a rectangle with sides of lengths<script type="math/tex">L_x</script> and<script type="math/tex">L_y</script>.<br>As the wavefunctions are localised around<script type="math/tex">x=-k l_{B}^{2}</script> for a finite sample restricted to<script type="math/tex">0 \leq x \leq L_{x}</script> we would expect the allowed $k$ values to range between<script type="math/tex">-L_{x} / l_{B}^{2} \leq k \leq 0</script>. And the number of the state is </p><script type="math/tex; mode=display">\mathcal{N}=\frac{L_{y}}{2 \pi} \int_{-L_{x} / l_{B}^{2}}^{0} d k=\frac{L_{x} L_{y}}{2 \pi l_{B}^{2}}=\frac{e B A}{2 \pi \hbar}=\frac{A B}{\Phi_{0}} \quad \text { with } \quad \Phi_{0}=\frac{2 \pi \hbar}{e}</script><p>Where<script type="math/tex">A = L_x L_y</script> is the area of the sample,<script type="math/tex">\Phi_{0}</script> is called the <strong>quantum of flux</strong><br><img src="/img_qhe/5.png" srcset="/img/loading.gif" alt=""><br>The degeneracy is very very large.</p><h3 id="Electric-Field-involved"><a href="#Electric-Field-involved" class="headerlink" title="Electric Field involved"></a>Electric Field involved</h3><p>When we add an electric field E in the x direction to the rectangular geometries of Landau levels, we just add an electric potential $\phi=-E x$ in the Hamiltonian.</p><script type="math/tex; mode=display">H=\frac{1}{2 m}\left(p_{x}^{2}+\left(p_{y}+e B x\right)^{2}\right)+e E x</script><p>By using the method in a harmonic oscillator, we can find the electric field only contribute a shift, which means wavefunctions are </p><script type="math/tex; mode=display">\psi(x, y)=\psi_{n, k}\left(x+m E / e B^{2}, y\right)</script><p>the energy eigenvalues are</p><script type="math/tex; mode=display">E_{n, k}=\hbar \omega_{B}\left(n+\frac{1}{2}\right)-e E\left(k l_{B}^{2}+\frac{e E}{m \omega_{B}^{2}}\right)+\frac{m}{2} \frac{E^{2}}{B^{2}}</script><p>Here we plot the figure of $E$ and $k$ as follow<br><img src="/img_qhe/6.png" srcset="/img/loading.gif" alt=""><br>We can find the degeneracy in each Landau level has now been lifted.</p><p>Because the energy now depends on the momentum, it means that states now drift in the y direction. The <strong>group velocity</strong> is</p><script type="math/tex; mode=display">v_{y}=\frac{1}{\hbar} \frac{\partial E_{n, k}}{\partial k}=-\frac{e}{\hbar} E l_{B}^{2}=-\frac{E}{B}</script><h3 id="Symmetric-Gauge"><a href="#Symmetric-Gauge" class="headerlink" title="Symmetric Gauge"></a>Symmetric Gauge</h3><p>This time we choose <strong>symmetric gauge</strong>, which is</p><script type="math/tex; mode=display">\mathbf{A}=-\frac{1}{2} \mathbf{r} \times \mathbf{B}=-\frac{y B}{2} \hat{\mathbf{x}}+\frac{x B}{2} \hat{\mathbf{y}}</script><p>This gauge breaks translational symmetry in both the x and the y directions, but preserves rotational symmetry, which means that angular momentum is a good quantum number. Furthermore, this gauge plays an important part in FQHE</p><p>We recall the algebraic approach at the beginning of this section, we define a mechanical momenta as<script type="math/tex">\boldsymbol{\pi}=\mathbf{p}+e \mathbf{A}</script>. In this section we set </p><script type="math/tex; mode=display">\tilde{\pi}=\mathbf{p}-e \mathbf{A}</script><p>The commutators of this new momenta is</p><script type="math/tex; mode=display">\left[\tilde{\pi}_{x}, \tilde{\pi}_{y}\right]=i e \hbar B</script><script type="math/tex; mode=display">\left[\pi_{x}, \tilde{\pi}_{x}\right]=2 i e \hbar \frac{\partial A_{x}}{\partial x} \quad, \quad\left[\pi_{y}, \tilde{\pi}_{y}\right]=2 i e \hbar \frac{\partial A_{y}}{\partial y} \quad, \quad\left[\pi_{x}, \tilde{\pi}_{y}\right]=\left[\pi_{y}, \tilde{\pi}_{x}\right]=i e \hbar\left(\frac{\partial A_{x}}{\partial y}+\frac{\partial A_{y}}{\partial x}\right)</script><p>Fortunately, if we use symmetric gauge, all these commutators vanish, that is</p><script type="math/tex; mode=display">\left[\pi_{i}, \tilde{\pi}_{j}\right]=0</script><p>So we may define a second pair of raising and lowering operators,</p><script type="math/tex; mode=display">b=\frac{1}{\sqrt{2 e \hbar B}}\left(\tilde{\pi}_{x}+i \tilde{\pi}_{y}\right) \quad \text { and } \quad b^{\dagger}=\frac{1}{\sqrt{2 e \hbar B}}\left(\tilde{\pi}_{x}-i \tilde{\pi}_{y}\right)</script><p>These too obey</p><script type="math/tex; mode=display">\left[b, b^{\dagger}\right]=1</script><p>It is this second pair of creation operators that provide the degeneracy of the Landau levels. Then the general state in the Hilbert space is<script type="math/tex">|n, m\rangle</script> defined by</p><script type="math/tex; mode=display">|n, m\rangle=\frac{a^{\dagger n} b^{\dagger m}}{\sqrt{n ! m !}}|0,0\rangle</script><p>Here $n$ depends energy, and $m$ depends degeneracy.</p><h3 id="The-Lowest-Landau-Level"><a href="#The-Lowest-Landau-Level" class="headerlink" title="The Lowest Landau Level"></a>The Lowest Landau Level</h3><p>Now we will construct the wavefunctions in the symmetric gauge. And we focus attention on the lowest Landau level $n = 0$.<br>Here the lowering operator is</p><script type="math/tex; mode=display">\begin{aligned}a &=\frac{1}{\sqrt{2 e \hbar B}}\left(\pi_{x}-i \pi_{y}\right) \\&=\frac{1}{\sqrt{2 e \hbar B}}\left(p_{x}-i p_{y}+e\left(A_{x}-i A_{y}\right)\right) \\&=\frac{1}{\sqrt{2 e \hbar B}}\left(-i \hbar\left(\frac{\partial}{\partial x}-i \frac{\partial}{\partial y}\right)+\frac{e B}{2}(-y-i x)\right)\end{aligned}</script><p>We work in complex coordinates on the plane, which is </p><script type="math/tex; mode=display">z=x-i y \quad \text { and } \quad \bar{z}=x+i y</script><p>And we also introduce the corresponding holomorphic and anti-holomorphic derivatives</p><script type="math/tex; mode=display">\partial=\frac{1}{2}\left(\frac{\partial}{\partial x}+i \frac{\partial}{\partial y}\right) \quad \text { and } \quad \bar{\partial}=\frac{1}{2}\left(\frac{\partial}{\partial x}-i \frac{\partial}{\partial y}\right)</script><p>Then we can rewrite $a$ and $a^{\dagger}$ as</p><script type="math/tex; mode=display">\begin{array}{l}a=-i \sqrt{2}\left(l_{B} \bar{\partial}+\frac{z}{4 l_{B}}\right) \\a^{\dagger}=-i \sqrt{2}\left(l_{B} \partial-\frac{\bar{z}}{4 l_{B}}\right)\end{array}</script><p>And $b$ and $b^{\dagger}$ as</p><script type="math/tex; mode=display">b=-i \sqrt{2}\left(l_{B} \partial+\frac{\bar{z}}{4 l_{B}}\right) \quad \text { and } \quad b^{\dagger}=-i \sqrt{2}\left(l_{B} \bar{\partial}-\frac{z}{4 l_{B}}\right)</script><p>Then we can obtain the lowest Landau level wavefunctions in terms of holomorphic monomials.</p><script type="math/tex; mode=display">\psi_{L L L, m} \sim\left(\frac{z}{l_{B}}\right)^{m} e^{-|z|^{2} / 4 l_{B}^{2}}</script><p>As we talk above the angular momentum is a good quantum number when we use symmetric gauge, we define angular momentum operator</p><script type="math/tex; mode=display">J=i \hbar\left(x \frac{\partial}{\partial y}-y \frac{\partial}{\partial x}\right)=\hbar(z \partial-\bar{z} \bar{\partial})</script><p>acting on these lowest Landau level states we have</p><script type="math/tex; mode=display">J \psi_{L L L, m}=\hbar m \psi_{L L L, m}</script><p>We can find the calculation in lowest Landau level states and angular momentum are coherent.</p><p>When it come to high Landau levels, it’s easy of us to act the raising operator<script type="math/tex">a^{\dagger}=-i \sqrt{2}\left(l_{B} \partial-\frac{\bar{z}}{4 l_{B}}\right)</script> on the lowest Landau level.</p><h3 id="Degeneracy-Revisited"><a href="#Degeneracy-Revisited" class="headerlink" title="Degeneracy Revisited"></a>Degeneracy Revisited</h3><p>We have two way to find the degeneracy of states in symmetric gauge.</p><ul><li>In symmetric gauge, the profiles of the wavefunctions form concentric rings around the origin.<br>By using this physical profile, we find the wavefunction with angular momentum $m$ is peaked on a ring of radius<script type="math/tex">r=\sqrt{2 m l_{B}}</script>.In a disc shaped region of area $A=\pi R^2$ ,the number of states is<script type="math/tex; mode=display">\mathcal{N}=R^{2} / 2 l_{B}^{2}=A / 2 \pi l_{B}^{2}=\frac{e B A}{2 \pi \hbar}</script></li><li>we review the classical motion of particles in a magnetic field. And it’s solution is <script type="math/tex; mode=display">x(t)=X-R \sin \left(\omega_{B} t+\phi\right) \quad \text { and } \quad y(t)=Y+R \cos \left(\omega_{B} t+\phi\right)</script>Now we rewrite them in the coordinates labelling the centre of the orbit as quantum operators, which is <script type="math/tex; mode=display">\begin{array}{l}X=x(t)+R \sin \left(\omega_{B} t+\phi\right)=x-\frac{\dot{y}}{\omega_{B}}=x-\frac{\pi_{y}}{m \omega_{B}} \\Y=y(t)-R \cos \left(\omega_{B} t+\phi\right)=y+\frac{\dot{x}}{\omega_{B}}=y+\frac{\pi_{x}}{m \omega_{B}}\end{array}</script>This definition holds in any gauge. When come into symmetric gauge we have <script type="math/tex; mode=display">X=\frac{1}{e B}\left(2 e A_{y}-\pi_{y}\right)=-\frac{\tilde{\pi}_{y}}{e B} \quad \text { and } \quad Y=\frac{1}{e B}\left(-2 e A_{x}+\pi_{x}\right)=\frac{\tilde{\pi}_{x}}{e B}</script>Then using the commutation relation of $\tilde{\pi}$ we obtain that the positions of the orbit in the $(X, Y)$ plane fail to commute with each other,<script type="math/tex; mode=display">[X, Y]=i l_{B}^{2}</script>By using The Heisenberg uncertainty principle, the uncertainty is given by<script type="math/tex; mode=display">\Delta X \Delta Y=\frac{l_{B}^{2}}{2}</script>Using Bohr-Sommerfeld semi-classical count of the states, we have<script type="math/tex; mode=display">\mathcal{N}=\frac{A}{\Delta X \Delta Y}=\frac{A}{2 \pi l_{B}^{2}}=\frac{e B A}{2 \pi \hbar}</script></li></ul><h2 id="Berry-Phase"><a href="#Berry-Phase" class="headerlink" title="Berry Phase"></a>Berry Phase</h2><p>We have already talk about Berry Phase in previous note <a href="https://zijunwei.top/2020/05/30/1/">Berry Phase note</a>, So we will talk about it when we define some mathematical form about Berry Phase.</p><h1 id="The-Integer-Quantum-Hall-Effect"><a href="#The-Integer-Quantum-Hall-Effect" class="headerlink" title="The Integer Quantum Hall Effect"></a>The Integer Quantum Hall Effect</h1><p>In the integer quantum Hall effect we do not need to take the interactions between electrons into account. Thing may be different in FQHE.</p><h2 id="Conductivity-in-Filled-Landau-Levels"><a href="#Conductivity-in-Filled-Landau-Levels" class="headerlink" title="Conductivity in Filled Landau Levels"></a>Conductivity in Filled Landau Levels</h2><p>In IQHE, we obtain the Hall resistivity from experiments, which is</p><script type="math/tex; mode=display">\rho_{x y}=\frac{2 \pi \hbar}{e^{2}} \frac{1}{\nu}</script><p>And we also get<script type="math/tex">\rho_{x y}</script> in the Drude model, which is</p><script type="math/tex; mode=display">\rho_{x y}=\frac{B}{n e}</script><p>Where $n$ is the density of electrons. Comparing these two expressions, we find the density need to satisfy</p><script type="math/tex; mode=display">n=\frac{B}{\Phi_{0}} \nu</script><p>With<script type="math/tex">\Phi_{0}=2 \pi \hbar / e</script>.<br>Now we have a figure of IQHE, which is the integer in IQHE represent the density of electrons filling ν Landau levels. When $\nu$ Landau levels are filled there is a gap in the energy spectrum. The gap is<script type="math/tex">\hbar \omega_B</script> (where<script type="math/tex">\omega_B=e B / m</script> is the <em>cyclotron frequency</em>). When we add a electric field, the electrons couldn’t move, as long as we’re at temperature<script type="math/tex">k_{B} T \ll \hbar \omega_{B}</script>. This can account for<script type="math/tex">\rho_{x x}=0</script>.</p><h3 id="Conductivity-for-a-single-free-particle"><a href="#Conductivity-for-a-single-free-particle" class="headerlink" title="Conductivity for a single free particle"></a>Conductivity for a single free particle</h3><p>The velocity of the particle is given by</p><script type="math/tex; mode=display">m \dot{\mathbf{x}}=\mathbf{p}+e \mathbf{A}</script><p>where $p_i$ is the canonical momentum.<br>In the quantum mechanics, the total current is given by</p><script type="math/tex; mode=display">\mathbf{I}=-\frac{e}{m} \sum_{\text {filled states }}\langle\psi|-i \hbar \nabla+e \mathbf{A}| \psi\rangle</script><p>Then we use Landau gauge<script type="math/tex">\mathbf{A}=x B \hat{\mathbf{y}}</script>, and introduce an electric field E in the x-direction. By using the Hamiltonian and state we have already talked in the previous section (Landau Levels), we can calculate the current in x-direction and y-direction.</p><script type="math/tex; mode=display">I_{x}=-\frac{e}{m} \sum_{n=1}^{\nu} \sum_{k}\left\langle\psi_{n, k}\left|-i \hbar \frac{\partial}{\partial x}\right| \psi_{n, k}\right\rangle=0</script><script type="math/tex; mode=display">I_{y}=-\frac{e}{m} \sum_{n=1}^{\nu} \sum_{k}\left\langle\psi_{n, k}\left|-i \hbar \frac{\partial}{\partial y}+e x B\right| \psi_{n, k}\right\rangle=-\frac{e}{m} \sum_{n=1}^{\nu} \sum_{k}\left\langle\psi_{n, k}|\hbar k+e B x| \psi_{n, k}\right\rangle</script><p>We find<script type="math/tex">I_x</script> is vanished, and<script type="math/tex">I_y</script> is just related to the position expectation value<script type="math/tex">\langle x\rangle</script> of the eigenstates which is<script type="math/tex">\left\langle\psi_{n, k}|x| \psi_{n, k}\right\rangle=-\hbar k / e B-m E / e B^{2}</script>. Then we have</p><script type="math/tex; mode=display">I_{y}=e \nu \sum_{k} \frac{E}{B}</script><p>The sum over $k$ just gives the degeneracy<script type="math/tex">N=A B / \Phi_{0}</script>. Then we obtain the current density in a electric field</p><script type="math/tex; mode=display">\mathbf{E}=\left(\begin{array}{c}E \\0\end{array}\right) \quad \Rightarrow \quad \mathbf{J}=\left(\begin{array}{c}0 \\e \nu E / \Phi_{0}\end{array}\right)</script><p>Finally we can get the conductivity and the resistivity.</p><script type="math/tex; mode=display">\sigma_{x x}=0 \quad \text { and } \quad \sigma_{x y}=\frac{e \nu}{\Phi_{0}} \quad \Rightarrow \quad \rho_{x x}=0 \quad \text { and } \quad \rho_{x y}=-\frac{\Phi_{0}}{e \nu}=-\frac{2 \pi \hbar}{e^{2} \nu}</script><h3 id="Edge-Modes"><a href="#Edge-Modes" class="headerlink" title="Edge Modes"></a>Edge Modes</h3><p>There are two things which the simple description above does not capture.</p><ul><li>the role played by disorder</li><li>edge modes</li></ul><p>The picture of edge modes is as follows<br><img src="/img_qhe/7.png" srcset="/img/loading.gif" alt=""><br>We find boundary particles move only in a single direction. which is called as <strong>chiral</strong>. Then the particles move in opposite direction on the two sides of the sample, we say that the particles have opposite <strong>chirality</strong> on the two sides.</p><p>We can account the edge modes in the quantum theory.<br>We’ll work in Landau gauge and consider a rectangular geometry which is finite only in the x-direction, which we model by $V(x)$.<br><img src="/img_qhe/8.png" srcset="/img/loading.gif" alt=""><br>The Hamiltonian is</p><script type="math/tex; mode=display">H=\frac{1}{2 m}\left(p_{x}^{2}+\left(p_{y}+e B x\right)^{2}\right)+V(x)</script><p>If the potential is smooth over distance scales $l_B$, we can Taylor expand the potential around its location $X$ (<script type="math/tex">V(x) \approx V(X)+(\partial V / \partial x)(x-X)+\ldots</script>), and drop quadratic terms. Then we obtain a linear potential which we have already talked at Landau Levels. The result is a group velocity in the y-direction, now is given by</p><script type="math/tex; mode=display">v_{y}=-\frac{1}{e B} \frac{\partial V}{\partial x}</script><p>We can find that the modes at each edge are both <strong>chiral</strong>:<script type="math/tex">v_{y}>0</script> on the left, and<script type="math/tex">v_{y}<0</script> on the right.</p><p>Now we look what happen when all states are filled.<br><img src="/img_qhe/9.png" srcset="/img/loading.gif" alt=""><br>The bulk of the material is an insulator because all the states are filled. But the edge of the material is a metal.<br>when we add a potential $\Delta \mu$ on the two sides of the sample, the picture become<br><img src="/img_qhe/10.png" srcset="/img/loading.gif" alt=""><br>To obtain the current we need to sum over all filled states, which is approximately the same as integrating over $x$ </p><script type="math/tex; mode=display">I_{y}=-e \int \frac{d k}{2 \pi} v_{y}(k)=\frac{e}{2 \pi l_{B}^{2}} \int d x \frac{1}{e B} \frac{\partial V}{\partial x}=\frac{e}{2 \pi \hbar} \Delta \mu</script><p>Where Hall voltage<script type="math/tex">e V_{H}=\Delta \mu</script>, then we can obtain the Hall conductivity</p><script type="math/tex; mode=display">\sigma_{x y}=\frac{I_{y}}{V_{H}}=\frac{e^{2}}{2 \pi \hbar}</script><p>Which is the same as the expected conductivity for a single Landau level.This picture of states shows that the current is carried entirely by the edge states. Fortunately, we can find that the sum over all states result in the independence of the shape of states, which means we can still get the same Hall conductivity as long as<script type="math/tex">V(x)<E_F</script>.</p><p>Now we have the Hall conductivity in a single Landau level, if there are more than one level, the Hall conductivity become<script type="math/tex">\sigma_{x y}=n \frac{I_{y}}{V_{H}}=\frac{e^{2}}{2 \pi \hbar}</script></p>]]></content>
    
    
    <categories>
      
      <category>Literature Review</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hall effect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固体物理圣经咏唱——晶体衍射及其倒格子空间</title>
    <link href="/2020/06/22/solid%20physics/solid3/"/>
    <url>/2020/06/22/solid%20physics/solid3/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体衍射"><a href="#晶体衍射" class="headerlink" title="晶体衍射"></a>晶体衍射</h1><p>当我们需要研究晶体内部的结构时，由于X射线的波长与原子间间距的匹配，X射线是确定晶体结构的重要工具。<br>当然我们也可以使用中子束来探测晶体结构，由于中子携有磁矩，利用磁矩与晶体中电 子自旋的相互作用，还可获得其中的磁性离子的磁矩的排列信息，使得中子衍射 成为探测晶体磁有序结构的独特的手段。</p><h2 id="晶体衍射的四种表示"><a href="#晶体衍射的四种表示" class="headerlink" title="晶体衍射的四种表示"></a>晶体衍射的四种表示</h2><h3 id="劳厄衍射方程"><a href="#劳厄衍射方程" class="headerlink" title="劳厄衍射方程"></a>劳厄衍射方程</h3><p><img src="/img_solid/7.png" srcset="/img/loading.gif" alt=""></p><script type="math/tex; mode=display">\vec{R}_{l} \bullet\left(\vec{k}-\vec{k}_{0}\right)=2 \pi n</script><p>其中n为整数，<script type="math/tex">\vec{k},\vec{k}_{0}</script>为入射波和散射波的波矢,<script type="math/tex">\vec{R}_{l}</script>为格点 A 的格矢。</p><h3 id="布拉格衍射方程"><a href="#布拉格衍射方程" class="headerlink" title="布拉格衍射方程"></a>布拉格衍射方程</h3><p><img src="/img_solid/8.png" srcset="/img/loading.gif" alt=""></p><script type="math/tex; mode=display">2 d_{h_{1} h_{2} h_{3}} \sin \theta=n \lambda</script><p>其中<script type="math/tex">d h_{1}h_{2}h_{3}</script>为晶面指数为<script type="math/tex">(h_{1} h_{2} h_{3})</script>的一族平行的晶面的间距，<script type="math/tex">\lambda</script>为波长。</p><h3 id="倒格子空间中"><a href="#倒格子空间中" class="headerlink" title="倒格子空间中"></a>倒格子空间中</h3><p><img src="/img_solid/9.png" srcset="/img/loading.gif" alt=""></p><script type="math/tex; mode=display">\vec{k}-\vec{k}_{0}=n \vec{K}_{h}</script><p>$\vec{k}$ 和<script type="math/tex">\vec{k}_{0}</script> 为入射波和散射波的波矢<script type="math/tex">\vec{R}_{l}</script>是晶面指数为<script type="math/tex">(h_{1} h_{2} h_{3})</script>的晶面族法线方向上最短的倒格矢</p><h3 id="布里渊区内"><a href="#布里渊区内" class="headerlink" title="布里渊区内"></a>布里渊区内</h3><script type="math/tex; mode=display">2 \vec{k} \bullet \vec{G}+G^{2}=0</script><p>或者</p><script type="math/tex; mode=display">\vec{G} \bullet\left(\vec{k}+\frac{\vec{G}}{2}\right)=0</script><p>其中<script type="math/tex">\vec{G}=n \vec{K}_{h}</script></p><h1 id="倒格子"><a href="#倒格子" class="headerlink" title="倒格子"></a>倒格子</h1><p>晶格具有平移周期性，如果以<script type="math/tex">\Gamma(\vec{r})</script> 代表晶体的某一物理量，则有：</p><script type="math/tex; mode=display">\Gamma(\vec{r})=\Gamma\left(\vec{r}+\vec{R}_{l}\right)</script><p>其中$\vec{R}_l$为正格子空间的格矢。这时对<script type="math/tex">\Gamma(\vec{r})</script>进行傅里叶级数展开</p><script type="math/tex; mode=display">\Gamma(\vec{r})=\sum_{h} \Gamma\left(\vec{K}_{h}\right) e^{i \vec{K}_{h} \cdot \vec{r}}</script><p>我们得到一组量纲为$m^{-1}$的矢量<script type="math/tex">\vec{K}_{h}</script>,</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>由正格矢<script type="math/tex">\vec{R}_{l}=l_{1} \vec{a}_{1}+l_{2} \vec{a}_{2}+l_{3} \vec{a}_{3}</script> 确定的空间格子为正格子。 现在我们来构架新的空间</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\vec{b}_{1}=\frac{2 \pi}{\Omega}\left(\vec{a}_{2} \times \vec{a}_{3}\right) \\\vec{b}_{2}=\frac{2 \pi}{\Omega}\left(\vec{a}_{3} \times \vec{a}_{1}\right) \\\vec{b}_{3}=\frac{2 \pi}{\Omega}\left(\vec{a}_{1} \times \vec{a}_{2}\right)\end{array}\right.</script><p>其中<script type="math/tex">\Omega=\vec{a}_{1} \bullet\left(\vec{a}_{2} \times \vec{a}_{3}\right)</script>为正格子空间原胞的体积。由上式定义的矢量为基矢所构成的格子我们称之为<strong>倒格子</strong>。<script type="math/tex">\vec{b}_1</script>、<script type="math/tex">\vec{b}_2</script>、<script type="math/tex">\vec{b}_3</script>称为<strong>倒易格子空间的基矢</strong>。<br><strong>倒格矢：</strong></p><script type="math/tex; mode=display">\vec{K}_{h}=h_{1} \vec{b}_{1}+h_{2} \vec{b}_{2}+h_{3} \vec{b}_{3}</script><p><strong>倒格子空间原胞的体积：</strong>（一个倒格点在倒格 子空间所占的体积）</p><script type="math/tex; mode=display">\Omega^{*}=\vec{b}_{1} \cdot\left(\vec{b}_{2} \times \vec{b}_{3}\right)</script><p>每一个布喇菲点阵都有一个与之相对应的倒易点阵，或者说，每个晶体结构都有两套晶格与之相联系，一套为正晶格（即正格子），另一套为倒晶格（即倒格子）。</p><h2 id="倒格子与正格子间的关系"><a href="#倒格子与正格子间的关系" class="headerlink" title="倒格子与正格子间的关系"></a>倒格子与正格子间的关系</h2><ul><li><strong>正、倒格子基矢间的关系</strong><br>带入即可证得<script type="math/tex; mode=display">\vec{a}_{i} \bullet \vec{b}_{j}=2 \pi \delta_{i j} \quad(i, j=1,2,3)</script></li><li><strong>原胞体积关系</strong><br>使用公式<script type="math/tex">\vec{a} \times(\vec{b} \times \vec{c})=(\vec{c} \bullet \vec{a}) \vec{b}-(\vec{b} \bullet \vec{a}) \vec{c}</script>展开计算得<script type="math/tex; mode=display">\Omega^{*}=\frac{(2 \pi)^{3}}{\Omega}</script></li><li><strong>晶面族和倒格矢关系</strong><br><img src="/img_solid/10.png" srcset="/img/loading.gif" alt=""><br>倒格矢<script type="math/tex">(h1, h2, h3)</script> 和晶面指数<script type="math/tex">(h1h2h3)</script> 的晶面法线方向平行。可以用晶面指数为<script type="math/tex">(h1h2h3)</script> 的晶面的法线方向上的最短倒格矢来表示该晶面族的法线方向。</li><li><strong>晶面距与倒格矢关系</strong><script type="math/tex; mode=display">d_{h_{1} h_{2} h_{3}}=\frac{2 \pi}{\left|\vec{K}_{h}\right|}</script></li><li><strong>正倒格矢关系</strong><script type="math/tex; mode=display">\vec{R}_{l} \bullet \vec{K}_{h}=2 \pi \mu \quad(\mu=0,\pm 1, \pm 2 \dots)</script><em>推论：</em>如果两个矢量满足这个方程所示的关系，若其中一个为正格矢，则另一个必为倒格矢。</li></ul><h1 id="布里渊区"><a href="#布里渊区" class="headerlink" title="布里渊区"></a>布里渊区</h1><p><strong>定义：</strong><br>布里渊区（Brillouin zone）是按照既是最小的重复单元又能反映倒格子空间点阵对称性的方式将倒格子空间分割成无限多个体积相等的结构单元<br><strong>布里渊区的划分：</strong><br>在倒格子空间中，以某一倒格点为原点，一般称原点为<script type="math/tex">\Gamma</script>点，<script type="math/tex">\vec{G}</script>为自<script type="math/tex">\Gamma</script>点到任一倒格点的倒格矢，作所有倒格矢<script type="math/tex">\vec{G}</script>的垂直平分面，这些平面把倒格子空间分割成许多包围原点的多面体。我们按照这些多面体离<script type="math/tex">\Gamma</script>的距离的远近称其为第一、第二……布里渊区。</p><h2 id="一维晶格的布里渊区"><a href="#一维晶格的布里渊区" class="headerlink" title="一维晶格的布里渊区"></a>一维晶格的布里渊区</h2><p><img src="/img_solid/11.png" srcset="/img/loading.gif" alt=""><br><strong>正格子：</strong><script type="math/tex">\vec{a}_{1}=a \vec{i}, \vec{a}_{2}=0, \vec{a}_{3}=0</script><br><strong>倒格子：</strong><script type="math/tex">\vec{b}_{1}=\frac{2 \pi}{a} \vec{i}, \vec{b}_{2}=0, \vec{b}_{3}=0</script><br><strong>第一布里渊区：</strong><script type="math/tex">-\frac{\pi}{a}<k_{x} \leq \frac{\pi}{a}</script><br><strong>第二布里渊区：</strong><script type="math/tex">-\frac{2 \pi}{a}<k_{x} \leq-\frac{\pi}{a} \text { and } \frac{\pi}{a}<k_{x} \leq \frac{2 \pi}{a}</script></p><h2 id="二维正方晶格的布里渊区"><a href="#二维正方晶格的布里渊区" class="headerlink" title="二维正方晶格的布里渊区"></a>二维正方晶格的布里渊区</h2><p><img src="/img_solid/12.png" srcset="/img/loading.gif" alt=""><br><strong>正格子：</strong><script type="math/tex">\vec{a}_{1}=a \vec{i}, \vec{a}_{2}=a \vec{j}, \vec{a}_{3}=0</script><br><strong>倒格子：</strong><script type="math/tex">\vec{b}_{1}=\frac{2 \pi}{a} \vec{i}, \vec{b}_{2}=\frac{2 \pi}{a} \vec{j}, \vec{b}_{3}=0</script></p><h2 id="体心立方晶格"><a href="#体心立方晶格" class="headerlink" title="体心立方晶格"></a>体心立方晶格</h2><p><img src="/img_solid/13.png" srcset="/img/loading.gif" alt=""><br><strong>正格子：</strong><script type="math/tex">\vec{a}_{1}=\frac{a}{2}(-\vec{i}+\vec{j}+\vec{k}), \vec{a}_{2}=\frac{a}{2}(\vec{i}-\vec{j}+\vec{k}), \vec{a}_{3}=\frac{a}{2}(\vec{i}-\vec{j}+\vec{k})</script><br><strong>倒格子：</strong><script type="math/tex">\vec{b}_{1}=\frac{2 \pi}{a}(\vec{j}+\vec{k}), \vec{b}_{2}=\frac{2 \pi}{a}(\vec{i}+\vec{k}), \vec{b}_{3}=\frac{2 \pi}{a}(\vec{i}+\vec{j})</script><br><strong>与体心立方格子对应的倒格子为面心立方格子</strong><br><em>说明：</em>三个特殊的方向</p><ul><li><script type="math/tex">\Delta</script>：<script type="math/tex">[100]</script>方向</li><li><script type="math/tex">\Sigma</script>：<script type="math/tex">[110]</script>方向</li><li>$\Lambda$：<script type="math/tex">[111]</script>方向</li></ul><h2 id="面心立方晶格"><a href="#面心立方晶格" class="headerlink" title="面心立方晶格"></a>面心立方晶格</h2><p><img src="/img_solid/14.png" srcset="/img/loading.gif" alt=""><br><strong>正格子：</strong><script type="math/tex">\vec{a}_{1}=\frac{a}{2}(\vec{j}+\vec{k}), \vec{a}_{2}=\frac{a}{2}(\vec{i}+\vec{k}), \vec{a}_{3}=\frac{a}{2}(\vec{i}+\vec{j})</script><br><strong>倒格子：</strong><script type="math/tex">\vec{b}_{1}=\frac{2 \pi}{a}(-\vec{i}+\vec{j}+\vec{k}), \vec{b}_{2}=\frac{2 \pi}{a}(\vec{i}-\vec{j}+\vec{k}), \vec{b}_{3}=\frac{2 \pi}{a}(\vec{i}+\vec{j}-\vec{k})</script><br><strong>与面心立方格子对应的倒格子为体心立方格子</strong><br><em>说明：</em>在计算面心立方格子的布里渊区的时候若只考虑最邻近的倒格点，所计算出来的不是最小单位，因此我们还需考虑次邻近的点。</p><h1 id="原子散射因子"><a href="#原子散射因子" class="headerlink" title="原子散射因子"></a>原子散射因子</h1><h1 id="几何结构因子"><a href="#几何结构因子" class="headerlink" title="几何结构因子"></a>几何结构因子</h1><h1 id="典型晶体结构衍射峰消失的条件"><a href="#典型晶体结构衍射峰消失的条件" class="headerlink" title="典型晶体结构衍射峰消失的条件"></a>典型晶体结构衍射峰消失的条件</h1>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固体物理圣经咏唱——晶体结构及其描述</title>
    <link href="/2020/06/21/solid%20physics/solid2/"/>
    <url>/2020/06/21/solid%20physics/solid2/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体特征"><a href="#晶体特征" class="headerlink" title="晶体特征"></a>晶体特征</h1><h2 id="宏观特征"><a href="#宏观特征" class="headerlink" title="宏观特征"></a>宏观特征</h2><ul><li>晶面规则的对称配置是晶体的宏观特征之一</li><li>恒定不变的晶面间夹角</li><li>存在由若干个晶面组合成的晶带</li><li>晶体具有沿某些特定方位的晶面劈裂的性质</li></ul><p>在上述的特性中，只有特征夹角可以判断所及晶体属于何种类型的晶体。</p><h2 id="微观结构特征"><a href="#微观结构特征" class="headerlink" title="微观结构特征"></a>微观结构特征</h2><p>在微观上，</p><ul><li>晶体是指既具有平移对称性又具有旋转对称性的固体。</li><li>准晶体不具有平移对称性而只具有旋转对称性。</li><li>非晶体既不具有平移对称性也不具有旋转对称性，长程无序。</li></ul><p>晶体具有固定的熔点，当加热晶体到熔点温度时，晶体开始熔化，即长程有序开始解体，非晶体没有长程有序，所以没有固定的熔点。</p><h1 id="空间点阵"><a href="#空间点阵" class="headerlink" title="空间点阵"></a>空间点阵</h1><h2 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h2><ul><li><strong>基元：</strong>晶体中最基本的重复单元。<em>说明：</em>任意两个基元中华的相应的原子周围的情况是相同的。</li><li><strong>格点：</strong>用原子振动的平衡位置的几何点替代每一个原子。</li><li><strong>结点：</strong>晶体内部的结构是由一些相同 的格点在空间中规则的作周期性分布构成的系统。</li><li><strong>点阵：</strong>结点在空间中的周期性排列。<strong>晶体结构=点阵+基元</strong></li><li><strong>晶格：</strong>将结点全部包括在内的网格。<ul><li><strong>布喇菲格子：</strong>如果晶体由完全相同的一种原子组成，则称为布喇菲格子。</li><li><strong>复式格子：</strong>基元中包含两种或两种以上的原子，则不同的原子各自构成自身的布喇菲格子。</li></ul></li><li><strong>格矢：</strong><script type="math/tex">\vec{R}_l=l_1 \vec{a}_1+l_2 \vec{a}_2+l_3 \vec{a}_3</script>其中<script type="math/tex">l_i =0,\pm 1,\pm 2</script><br>为了描述晶格的周期性，我们引入</li><li><strong>原胞:</strong>晶格中最小的周期性重复单元。<em>说明：</em>原胞中均只含有一个原子</li><li><strong>基矢：</strong>原胞的边矢量<script type="math/tex">(\vec{a}_{1}, \vec{a}_{2},\vec{a}_{3})</script>。其中<script type="math/tex">\Omega=\vec{a}_{1} \bullet\left(\vec{a}_{2} \times \vec{a}_{3}\right)</script>表示原胞的体积或一个原子所占的体积</li></ul><p>当我们同时考虑晶格的周期性与特殊的对称性时，我们有</p><ul><li><strong>晶胞：</strong>最小单元的一倍或几倍的重复单元，反映晶格的周期性与晶体对称性。<em>说明：</em>晶胞中可以含有不止一个原子</li><li><strong>基矢：</strong>原胞的边矢量<script type="math/tex">(\vec{a}, \vec{b},\vec{c})</script></li></ul><h1 id="典型的晶体结构即其原胞晶胞"><a href="#典型的晶体结构即其原胞晶胞" class="headerlink" title="典型的晶体结构即其原胞晶胞"></a>典型的晶体结构即其原胞晶胞</h1><p>晶体中原子排列的具体形式一般称为晶体格子，简称<strong>晶格</strong></p><h2 id="单原子晶体"><a href="#单原子晶体" class="headerlink" title="单原子晶体"></a>单原子晶体</h2><h3 id="简单立方"><a href="#简单立方" class="headerlink" title="简单立方"></a>简单立方</h3><p><img src="/img_solid/3.png" srcset="/img/loading.gif" alt="">配位数：6<br>原胞：</p><script type="math/tex; mode=display">\left\{\begin{array}{l} \vec{a}_{1}={a}\vec{i} \\ \vec{a}_{2}={a}\vec{j} \\ \vec{a}_{3}={a}\vec{k} \end{array}\right.</script><p>晶胞=原胞</p><h3 id="体心立方结构"><a href="#体心立方结构" class="headerlink" title="体心立方结构"></a>体心立方结构</h3><p><img src="/img_solid/4.png" srcset="/img/loading.gif" alt="">配位数：8<br>原胞：</p><script type="math/tex; mode=display">\left\{\begin{array}{l} \vec{a}_{1}=\frac{a}{2}(-\vec{i}+\vec{j}+\vec{k}) \\\vec{a}_{2}=\frac{a}{2}(\vec{i}-\vec{j}+\vec{k}) \\\vec{a}_{3}=\frac{a}{2}(\vec{i}-\vec{j}+\vec{k})\end{array}\right.</script><p>体积<script type="math/tex">\Omega=\vec{a}_{1} \bullet\left(\vec{a}_{2} \times \vec{a}_{3}\right)=\frac{1}{2} a^{3}</script></p><p>晶胞</p><script type="math/tex; mode=display">\left\{\begin{array}{l} \vec{a}={a}\vec{i} \\ \vec{b}={a}\vec{j} \\ \vec{c}={a}\vec{k} \end{array}\right.</script><p>体积<script type="math/tex">V=a^3</script>。晶胞中所含原子数：3</p><h3 id="面心立方结构"><a href="#面心立方结构" class="headerlink" title="面心立方结构"></a>面心立方结构</h3><p><img src="/img_solid/5.png" srcset="/img/loading.gif" alt="">配位数：12</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\vec{a}_{1}=\frac{a}{2}(\vec{j}+\vec{k}) \\\vec{a}_{2}=\frac{a}{2}(\vec{i}+\vec{k}) \\\vec{a}_{3}=\frac{a}{2}(\vec{i}+\vec{j})\end{array}\right.</script><p>体积<script type="math/tex">\Omega=\frac{1}{4}a^3</script></p><p>晶胞</p><script type="math/tex; mode=display">\left\{\begin{array}{l} \vec{a}={a}\vec{i} \\ \vec{b}={a}\vec{j} \\ \vec{c}={a}\vec{k} \end{array}\right.</script><p>体积<script type="math/tex">V=a^3</script>。晶胞中所含原子数：4</p><h3 id="六角密积结构"><a href="#六角密积结构" class="headerlink" title="六角密积结构"></a>六角密积结构</h3><p><img src="/img_solid/6.png" srcset="/img/loading.gif" alt=""><br>原胞</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\vec{a}_{1}=-\frac{a}{2} \vec{i}-\frac{\sqrt{3} a}{2} \vec{j} \\\vec{a}_{2}=a \vec{i} \\\vec{a}_{3}=c \vec{k}\end{array}\right.</script><p>当为最密堆积时</p><script type="math/tex; mode=display">\frac{c}{a}=\sqrt(\frac{8}{3})</script><h3 id="金刚石结构"><a href="#金刚石结构" class="headerlink" title="金刚石结构"></a>金刚石结构</h3><p>为正四面体结构</p><h2 id="化合物晶体"><a href="#化合物晶体" class="headerlink" title="化合物晶体"></a>化合物晶体</h2><h3 id="NaCl-型"><a href="#NaCl-型" class="headerlink" title="NaCl 型"></a>NaCl 型</h3><p>NaCl 型结构的晶体可看成是两套面心立方结 构相互位移套购而形成的。</p><h3 id="CsCl-型"><a href="#CsCl-型" class="headerlink" title="CsCl 型"></a>CsCl 型</h3><p>其基本结构单元是一个立方体，一种元素在立方体顶角上，另一元素在立方体体心，两种元素各自形成简单立方结构。</p><h3 id="CsF2-型"><a href="#CsF2-型" class="headerlink" title="CsF2 型"></a>CsF2 型</h3><p>每个立方体中共有四个 Ca元素和 8 个 F 元素，4 个 Ca 分别占据在立方体顶角和立方体面心处，形成面心 立方格子，8 个 F 占据在立方体的四条空间对角线上，每条空间对角线上有 2 个 F 元素，分别位于对角线两端 1/4 处，这 8 个 F 形成简单立方格子，整个晶体可看成是面心立方格子和简单立方格子套购而成。</p><h1 id="晶列与晶面"><a href="#晶列与晶面" class="headerlink" title="晶列与晶面"></a>晶列与晶面</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>晶列：</strong>任意两个格点的连线，包括无数个格点。</li><li><strong>晶列族：</strong>相互平行的晶列的集合。</li><li><strong>晶向：</strong>晶列的取向。</li><li><strong>晶向指数：</strong>用三个互质整数表示晶列的方向，记为<script type="math/tex">\left[l_{1}, l_{2}, l_{3}\right]</script>。若某一指数为负数则用<script type="math/tex">\overline{l}</script>表示。</li><li><p><strong>晶列指数：</strong>在结晶学中用晶胞表示最小单位，同晶向指数，记为<script type="math/tex">\left[m,n,p\right]</script>。</p></li><li><p><strong>晶面：</strong>晶体中三个非共线格点组成的平面。</p></li><li><strong>晶面族：</strong>一系列平行的晶面。</li><li><strong>密勒指数（晶面指数）：</strong>三个互质的整数<script type="math/tex">\left(h_1, h_2, h_3\right)</script><ul><li>最靠近原点的晶面在3个基矢上的截距分别为<script type="math/tex">\frac{a_1}{h_1},\frac{a_2}{h_2},\frac{a_3}{h_3}</script></li><li>以晶胞基矢为坐标表示晶面指数为<script type="math/tex">\left(h,k.l\right)</script></li><li>与晶列指数相同，使用<script type="math/tex">\overline{h_i}</script>表示负值</li><li>晶面距<script type="math/tex; mode=display">d_{h k l}=\frac{1}{\sqrt{\frac{h^{2}}{a^{2}}+\frac{k^{2}}{b^{2}}+\frac{l^{2}}{c^{2}}}}</script></li><li>不同晶面族的晶面夹角余弦<script type="math/tex; mode=display">\cos \varphi=\frac{h_{1} h_{2}+k_{1} k_{2}+l_{1} l_{2}}{\left(h_{1}^{2}+k_{1}^{2}+l_{1}^{2}\right)^{1 / 2}+\left(h_{2}^{2}+k_{2}^{2}+l_{2}^{2}\right)^{1 / 2}}</script></li></ul></li></ul><h2 id="晶列指数的求法"><a href="#晶列指数的求法" class="headerlink" title="晶列指数的求法"></a>晶列指数的求法</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul><li>找到含原点O的晶列</li><li>在该晶列上找到距离O点最近的格点，其格矢为<script type="math/tex">\vec{R}_l=l_1 \vec{a}_1+l_2 \vec{a}_2+l_3 \vec{a}_3</script></li><li>则晶列指数为<script type="math/tex">\left[l_{1}, l_{2}, l_{3}\right]</script></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul><li>求出晶列所在直线的方向向量</li><li><strong>晶列指数=直线的方向向量</strong></li></ul><h3 id="特殊的方向"><a href="#特殊的方向" class="headerlink" title="特殊的方向"></a>特殊的方向</h3><h2 id="晶面指数的求法"><a href="#晶面指数的求法" class="headerlink" title="晶面指数的求法"></a>晶面指数的求法</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>找截距，<script type="math/tex">\frac{a_1}{h_1},\frac{a_2}{h_2},\frac{a_3}{h_3}</script></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><ul><li>找到面上的两个矢量<script type="math/tex">\vec{X}_1,\vec{X}_2</script></li><li>得到晶面的法线方向<script type="math/tex">\vec{n}=\vec{X}_1-\vec{X}_2</script>，后简化</li><li>**晶面指数=晶面的法线方向<script type="math/tex">\vec{n}</script></li></ul><h1 id="晶体对称操作"><a href="#晶体对称操作" class="headerlink" title="晶体对称操作"></a>晶体对称操作</h1>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固体物理圣经咏唱——原子的凝聚</title>
    <link href="/2020/06/18/solid%20physics/solid1/"/>
    <url>/2020/06/18/solid%20physics/solid1/</url>
    
    <content type="html"><![CDATA[<h1 id="原子结构"><a href="#原子结构" class="headerlink" title="原子结构"></a>原子结构</h1><p>在不同时期人们对原子的认识是不同的，其中出现了一个历史性的模型：</p><ul><li>汤姆孙（Thomson）模型：原子被认为是一个半径在$~10^{-8} cm$量级的球，球内均匀分布着正电荷，因此被人们戏称为葡萄布丁模型。</li><li>卢瑟福模型：汤姆孙提出的原子结构模型很快被$\alpha$粒子散射实验否定，卢瑟福认为原子是由位于原子中心、 尺寸很小（半径$~10^{-13} cm$）的带正电荷的原子核和核外带负电荷的电子组成</li><li>玻尔原子理论：波尔将卢瑟福模型和爱因斯坦光量子理论相结合引入定态假设、跃迁假设与角动量量子化假设提出玻尔原子理论。玻尔理论很好地解释了在 H 原子中观察到的分立光谱，但对稍稍复杂的原 子，观察到的原子光谱和玻尔理论的预言并不相一致。</li><li>德布罗意（Broglie）：粒子均具有波粒二象性。</li></ul><p>我们知道在原子中电子受到带有正电的原子的库伦势的作用</p><script type="math/tex; mode=display">V(\vec{r})=-\frac{Z e^{2}}{4 \pi \varepsilon_{0} r}</script><p>将其带入Schodinger方程可以解出相应的波函数</p><script type="math/tex; mode=display">\psi_{n l m}(r, \theta, \varphi)=R_{n l}(r) Y_{l m}(\theta, \varphi)</script><p>其中：$n=1,2,3,\ldots$为主量子数；$l=1,2,\ldots (n-1)$为角量子数；$m=0,\pm 1, \ldots \pm l$为磁量子数。且电子的能量仅与主量子数n有关</p><script type="math/tex; mode=display">E_{n}=-\frac{\mu Z^{2} e^{4}}{2 \hbar^{2}\left(4 \pi \epsilon_{0}\right)^{2}} \frac{1}{n^{2}}</script><p>这时我们可以发现，这时态是<strong>简并</strong>的：</p><ul><li>电子能级对磁量子数m的简并源于势场为球对称的中心场</li><li>电子能级对角量子数l的简并源于电子受到的势场为库仑场这一特殊的球对称的中心场</li></ul><p>同时我们也需要知道但对实际含有多个电子的原子，每一个电子除了受到原子核势场作用外， 还受到其它电子的作用，导致简并被部分解除，形成一系列能量不同的电子壳层。<br>我们使用角量子数$l$来标示这些壳层，其中$l=1,2,\ldots (n-1)$分别对应s、p、d、f· · · 壳层。</p><p>由此，当我们考虑电子自旋，对每一个给定主量子数 n，简并度为$2n^2$，即每个能级$E_n$可以被$2n^2$个状态不同的电子占据。给定$l$壳层，简并度为$2(2l + 1)$。<br>我们使用电子构型来描述原子核外电子的分布，如Na 原子的电子构型为$1 s^{2} 2 s^{2} 2 p^{6} 3 s^{1}$</p><h1 id="原子电负性"><a href="#原子电负性" class="headerlink" title="原子电负性"></a>原子电负性</h1><p>人们引入原子电负性（Electronegativity）这样一个物理量来科学地比较各种原子得失电子的难易程度，用$\chi$表示。<br>原子束缚电子的能力越强，其电负性越高，在这种情况下，原子趋向于从外界获得电子；反之，电负性越低，原子束缚电子的能力越弱，在这种情况下，原子容易丢失外层电子。</p><p>电负性有很多种定义方式，接下来介绍<strong>密立根定义</strong>：<br>原子束缚电子的能力包含两个方面的内容。一是原子的电离能，用$W_i$表示</p><script type="math/tex; mode=display">A+W_{i} \Rightarrow A^{+}+(-e)</script><p>另一个是原子的亲合能，用$W_a$表示</p><script type="math/tex; mode=display">A+(-e) \Rightarrow A^{-}+W_{a}</script><p>则此时电负性$\chi$，由原子的电离能和原子的亲合能的平均值来量度，即</p><script type="math/tex; mode=display">\chi=\frac{1}{6.3}\left(W_{i}+W_{a}\right)</script><p>其中电离能和亲合能均以eV为单位，系数的选择仅仅是为了使Li的电负性为1</p><p><img src="/img_solid/1.png" srcset="/img/loading.gif" alt=""><br>原子的电负性可以从元素周期表中看出来（元素周期表从某种意义上也是原子对外层电子束缚能力的周期性反映），变化规律可总结如下：</p><ul><li>对同一周期的主族元素，随原子序数Z增加（周期表中自左至右），原子电负性快速增大；</li><li>对同一主族元素，随Z增加（周期表中自上而下），原子电负性逐渐减小；</li><li>对同一周期的过渡族元素，原子电负性随Z增加呈现不规律变化，但电负性均高于同一周期的第一和第二主族元素；</li><li>对稀土元素，原子电负性随Z增加变化很小。</li></ul><p>同时原子电负性可以作为判断元素的金属性和非金属性强弱的尺度，一般电负性小的为金属，电负性较大为非金属</p><h1 id="原子间相互作用及结合力的一般性质"><a href="#原子间相互作用及结合力的一般性质" class="headerlink" title="原子间相互作用及结合力的一般性质"></a>原子间相互作用及结合力的一般性质</h1><p>只有当吸引和排斥两种相互作用力平衡时，大量原子才能凝聚到一起形成稳定结构的固体。电磁力是引起原子凝聚的吸引力的来源。<br>原子凝聚成固体时，原子的外层电子会作重新排布：或者失去，或者得到，或者共享。通常称引起原子结合在一起的力为“键”，典型的键有：金属键、离子键、共价键、氢键、氢键结合和范德瓦斯（Van der Waals）键。<br>经验上，两原子间的相互作用势能常用幂函数来表达，即</p><script type="math/tex; mode=display">u(r)=-\frac{A}{r^{m}}+\frac{B}{r^{n}}</script><p>其中第一项表示吸引能，第二项表示排斥能，A、B、C和D均为大于0的常数，这里规定即相当于原子处在自由状态（孤立原子）时的能量取为能量零点。</p><p>当原子间净的相互作用力为零，即$f\left(r_{0}\right)=0$，以至于固体处在稳定的结构状态。在相互作用势中表示为</p><script type="math/tex; mode=display">\left.\frac{d U(r)}{d r}\right|_{r=r_{0}}=0</script><p>这样我们就可以得到得平衡时相邻原子间距$r_0$。</p><script type="math/tex; mode=display">r_{0}=\sqrt[n-m]{\frac{B n}{A m}}</script><p>N个原子组成的固体其总的相互作用势能</p><script type="math/tex; mode=display">U=\frac{1}{2} \sum_{i=1}^{N} u_{i}=\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} u\left(r_{i j}\right)</script><p>其中 $r_{ ij }$ 为i，j两原子间的间距</p><p>$u( r_{ ij } )$ 为原子间的相互作用势<br>当我们取固体表面层的第一个原子为参考原子时：</p><script type="math/tex; mode=display">U=\frac{N}{2} \sum_{j} u\left(r_{i j}\right) \quad(j=2,3, \cdots, N)</script><p>这即是总相互作用势能实际上就是固体的内能。</p><p>从能量的角度看，N个原子能够凝聚成固体的原因，是因为它们结合起来以后，能够使整个系统的总能量比N个原子处于自由状态时的总能量更低。这一部分能量的差值就叫做结合能，即</p><script type="math/tex; mode=display">W=E_{N}-U\left(r_{0}\right)</script><p>假设固体有N个原胞，原胞的体积为$\Omega$，则固体的体积为$V=N \Omega$。原胞的体积应当正比于$r^3$，即$\Omega=\beta r^3$，$\beta$是与固体的几何结构有关的常数。因此</p><script type="math/tex; mode=display">V=N \beta r^{3}</script><p>平衡时有</p><script type="math/tex; mode=display">V_{0}=N \beta r_{0}^{3}</script><p>由热力学，我们可以定义一个系统的体弹性模量（K）为</p><script type="math/tex; mode=display">K=-V\left(\frac{\partial P}{\partial V}\right)_{T}</script><p>压力P为</p><script type="math/tex; mode=display">P=-\frac{\partial U}{\partial V}=-\frac{\partial U}{\partial r} \frac{\partial r}{\partial V}=-\frac{1}{3 N \beta r^{2}} \frac{\partial U}{\partial r}</script><p>由此我们可得到平衡时固体体弹性模量为</p><script type="math/tex; mode=display">K=\frac{1}{9 N \beta r_{0}}\left(\frac{\partial^{2} U}{\partial r^{2}}\right)_{r=r_{0}}</script><h1 id="金属键"><a href="#金属键" class="headerlink" title="金属键"></a>金属键</h1><p>在原子中那些能脱离原子核束缚的最外层电子称为<strong>价电子</strong>，失去价电子后剩下的内层电子称为<strong>芯电子</strong>。当大量电负性低的原子凝聚成固体时，脱离原子核束缚的价电子不再属于哪一个原子，而是为所有原子所共有，成为共有化电子，而固体中失去价电子后的离子为离子实。这种共有化运动的电子与离子实之间的库仑吸引作用称为<strong>金属键</strong></p><p>由于金属中原子的结合主要是依靠离子实和价电子之间的静电库仑力，另一方面，失去价电子后的离子实具有球对称的闭合电子壳层，因此，这种结合对原子排列没有特殊要求，只要求原子排列尽可能紧密，由于这一原因，多数金属都能形成较高配位数的密堆积结构。</p><h1 id="离子键"><a href="#离子键" class="headerlink" title="离子键"></a>离子键</h1><h2 id="离子键结合的特点"><a href="#离子键结合的特点" class="headerlink" title="离子键结合的特点"></a>离子键结合的特点</h2><p>当电负性相差很大的两类原子相遇时，两原子各得到/失去电子成为具有稳定的满电子壳层结构离子，这种正、负离子因离子间库仑吸引力而结合的键称为离子键，以 离子键结合形成的固体称为离子固体。</p><p>离子键具有如下特点：</p><ul><li>离子键是相当强的，因此一般离子固体具有熔点高、硬度大的特点。</li><li>离子固体的导电性差，一般都是绝缘体。这是由于正、负离子实具有稳定的满电子壳层结构，电子难以脱离开离子实，离子实也不容易离开自身的平衡位置。</li></ul><h2 id="离子固体的相互作用能"><a href="#离子固体的相互作用能" class="headerlink" title="离子固体的相互作用能"></a>离子固体的相互作用能</h2><p>可以得到离子固体中i、j两离子实间的相互作用势为</p><script type="math/tex; mode=display">u\left(r_{i j}\right)=\pm \frac{e^{2}}{4 \pi \varepsilon_{0} r_{i j}}+\frac{b}{r_{i j}^{n}}</script><p>其中第一项为离子实之间的库仑作用能，第二项为当两个离子实相距很近时由于电子云有交叠出现的很强的排斥作用。</p><p>我们设相邻离子间距离为$r$，则第j个离子和第1个离子间的距离可表示为</p><script type="math/tex; mode=display">r_{1 j}=a_{j} r</script><p>于是即可得到离子固体总的相互作用能：</p><script type="math/tex; mode=display">U=-N\left[\frac{e^{2}}{4 \pi \varepsilon_{0} r} \sum_{j \neq 1}^{N}\left(\pm \frac{1}{a_{j}}\right)-\frac{1}{r^{n}} \sum_{j \neq 1}^{N} \frac{b}{a_{j}^{n}}\right]</script><p>我们令</p><script type="math/tex; mode=display">\begin{array}{l}M=\sum_{ j \neq 1}^{N} \pm \frac{1}{a_{j}} \\B=\sum_{ j \neq 1}^{N} \frac{b}{a_{j}^{n}}\end{array}</script><p>可将<strong>离子固体的总相互作用能</strong>写成如下简单的形式</p><script type="math/tex; mode=display">U=-N\left[\frac{M e^{2}}{4 \pi \varepsilon_{0} r}-\frac{B}{r^{n}}\right]</script><p>这其中B和n为常数，可由实验确定。而M称为<strong>马德隆常数</strong>，其值决定于离子固体的具体结构。</p><p><em>例子：</em>一维离子链的马德隆常数M<br>假设正、负离子周期性交替分布构成如图所示的的一维无限长的离子链<br><img src="/img_solid/2.png" srcset="/img/loading.gif" alt=""><br>则对于M我们有</p><script type="math/tex; mode=display">\frac{M}{r}=2\left[\frac{1}{r}-\frac{1}{2 r}+\frac{1}{3 r}-\frac{1}{4 r}+\ldots\right]</script><p>则$M=2\left[1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+\ldots\right]=2 \ln 2$</p><h2 id="平衡时相邻离子间距、体弹性模量和结合能"><a href="#平衡时相邻离子间距、体弹性模量和结合能" class="headerlink" title="平衡时相邻离子间距、体弹性模量和结合能"></a>平衡时相邻离子间距、体弹性模量和结合能</h2><p>当<script type="math/tex">\left.\frac{d U}{d r}\right|_{r=s_{0}}=0</script>时达到平衡距离$r_0$。我们可以计算出</p><script type="math/tex; mode=display">r_{0}=\left(\frac{4 \pi \varepsilon_{0} n B}{M e^{2}}\right)^{\frac{1}{n-1}}</script><p>同时可以得到平衡时体弹性模量有</p><script type="math/tex; mode=display">K=\left.\frac{1}{9 N \beta r_{0}} \frac{d^{2} U}{d r^{2}}\right|_{r=r_{0}}=\frac{M e^{2}}{36 \pi \varepsilon_{0} \beta r_{0}^{4}}(n-1)</script><p>式中的$\beta$是与具体结构有关的常数，对于NaCl型结构，$\beta =2$。</p><p>同上的讨论当我们取$r=r_0$时则得到平衡时离子固体总的相互作用能$U(r_0)$，以及离子固体的结合能$W=-U\left(r_0\right)$，有</p><script type="math/tex; mode=display">W=-U\left(r_{0}\right)=\frac{N M e^{2}}{4 \pi \varepsilon_{0} r_{0}}\left[1-\frac{1}{n}\right]</script><p>其物理意义是表示将离子固体分解为自由原子所需要的能量。一般来说n在8附近，所以离子固体平衡时的能量贡献主要来自库仑吸引能。</p><h1 id="共价键"><a href="#共价键" class="headerlink" title="共价键"></a>共价键</h1><h2 id="共价键结合的特点"><a href="#共价键结合的特点" class="headerlink" title="共价键结合的特点"></a>共价键结合的特点</h2><p>元素周期表中同一周期靠中间的元素相结合时，原子对外层电子束缚比较牢固，同时获取电子的能力也较强，妥协的结果是，两者各自贡献自旋相反的电子配对成共用电子对，这样的结合称为<strong>共价键</strong>。<br>以共价键结合形成的固体称为<strong>共价固体</strong>，又称为<strong>原子固体</strong>。</p><h2 id="共价键的方向性和饱和性"><a href="#共价键的方向性和饱和性" class="headerlink" title="共价键的方向性和饱和性"></a>共价键的方向性和饱和性</h2><ul><li><strong>方向性</strong>：原子只在特定方向上形成共价键，共价键的强弱决定于形成共价键的两个电子轨道波函数的重叠程度</li><li><strong>饱和性</strong>：一个原子只能形成一定数目的共价键<ul><li>价电子壳层不到半满：能够形成的共价键数目与价电子数目相等。 </li><li>价电子壳层超过半满：能够形成的共价键数目少于价电子数目。未配对电子数和能够形成共价键的 数目为 8 −Z，Z 为价电子数。</li></ul></li></ul><h1 id="氢键"><a href="#氢键" class="headerlink" title="氢键"></a>氢键</h1><p>设有两个电负性很大而原子半径较小的原子，分别用X和Y表示，则氢原子与X原子结合得较强，而与Y原子结合得较弱，形象地用“X-H—Y”表示，其中短线和长线表示氢与两原子结合得强与弱，这种特殊的结合称为氢键。<br>典型的氢键中，X 和 Y 是电负性很强的F、N和O原子，虽然 C、S、Cl、P甚至Br和I原子在某些情况下也能形成氢键，但通常键能较低。</p><h1 id="范德瓦斯键"><a href="#范德瓦斯键" class="headerlink" title="范德瓦斯键"></a>范德瓦斯键</h1><h2 id="范德瓦斯键结合的特点"><a href="#范德瓦斯键结合的特点" class="headerlink" title="范德瓦斯键结合的特点"></a>范德瓦斯键结合的特点</h2><p>本质上讲<strong>Van der Walls 键</strong>是通过电偶极矩间的相互作用而结合的键，这类原子因具有球对称的闭合电 子壳层，故又可看作是单原子分子，因此，范德瓦耳斯固体又称为分子固体。我们可以依据分子是否具有固有的电偶极矩而将范德瓦耳斯力分为三种形式的力</p><ul><li>伦敦（London） 力：对于惰性原子，原子的电偶极矩为零，或者说这类原子或分子没有固有的电偶极矩，因此，分子间不存在固有电偶极矩的相互作用，但存在“瞬间”电偶极矩，当“瞬间”电偶极矩的方向趋向于一致时，系统的能量最低。由“瞬间”电偶极矩产生的吸引力，称为<strong>伦敦力</strong>。由于形成的固体是没有极性的，故称为<strong>非极性分子固体</strong>。</li><li>葛生（Keeson）力：对于由两种电负性不等的原子组成的分子，这样的分子总存在一定大小的固有电偶极矩，我们把具有固有电偶极矩的分子称为<strong>极性分子</strong>，将由极性分子凝聚而成的分子固体称为<strong>极性分子固体</strong>。对于极性分子固体，与固有偶极矩间相互作用有关的力称为<strong>葛生力</strong>。</li><li>德拜（Debey）力：对于同时含有极性分子和非极性分子，由于极性分子有固有电偶极矩，而非极性分子没有固有电偶极矩，但非极性分子可以被极性分子的电场极化而产生<em>诱导电偶极矩</em>，故极性分子和非极性分子之间也存在相互作用，与这种相互作用有关的力称为<strong>德拜力</strong>。</li></ul><p>一般来说，葛生力和德拜力比伦敦力 弱，或者说在范德瓦耳斯力中起主要作用的是伦敦力。</p><h2 id="分子固体的相互作用能"><a href="#分子固体的相互作用能" class="headerlink" title="分子固体的相互作用能"></a>分子固体的相互作用能</h2><p>通过在电动力学中对电偶极矩的计算可以得出，一对分子间总的相互作用能可以表示为</p><script type="math/tex; mode=display">u(r)=-\frac{A}{r^{6}}+\frac{B}{r^{12}}</script><p>若我们令$\sigma=\left(\frac{B}{A}\right)^{1 / 6}$和$\varepsilon=\frac{A^2}{4 B}$，我们可以得到</p><script type="math/tex; mode=display">u(r)=4 \varepsilon\left[-\left(\frac{\sigma}{r}\right)^{6}+\left(\frac{\sigma}{r}\right)^{12}\right]</script><p>这就是雷纳德-琼斯（Lennard-Jones）势。<br>由此总能量为</p><script type="math/tex; mode=display">U(r)=\frac{N}{2} \sum_{j, j \neq 1}\left\{4 \varepsilon\left[-\left(\frac{\sigma}{r_{1 j}}\right)^{6}+\left(\frac{\sigma}{r_{1 j}}\right)^{12}\right]\right\}</script><p>若分子间的间距为$r$，有$r<em>{1 j}=a</em>{j} r$。则</p><script type="math/tex; mode=display">U(r)=2 N \varepsilon\left[A_{12}\left(\frac{\sigma}{r}\right)^{12}-A_{6}\left(\frac{\sigma}{r}\right)^{6}\right]</script><p>其中<script type="math/tex">A_{1 2}=\sum_{j, j \neq 1} \frac{1}{a_j^{1 2}}\,A_6=\sum_{j, j \neq 1} \frac{1}{a_j^6}</script>为和晶体结构有关的常数</p><h2 id="平衡时相邻分子间的间距、体弹性模量和结合能"><a href="#平衡时相邻分子间的间距、体弹性模量和结合能" class="headerlink" title="平衡时相邻分子间的间距、体弹性模量和结合能"></a>平衡时相邻分子间的间距、体弹性模量和结合能</h2><p>平衡时相邻分子间的间距</p><script type="math/tex; mode=display">r_{0}=\left(\frac{2 A_{12}}{A_{6}}\right)^{1 / 6} \sigma</script><p>平衡时固体总的相互作用能</p><script type="math/tex; mode=display">U\left(r_{0}\right)=-\frac{N \varepsilon A_{6}^{2}}{2 A_{12}}</script><p>固体的结合能</p><script type="math/tex; mode=display">W=-U\left(r_{0}\right)=\frac{N \varepsilon A_{6}^{2}}{2 A_{12}}</script><p>体弹性模量</p><script type="math/tex; mode=display">K=\left.\frac{1}{9 N \beta r_{0}} \frac{d^{2} U}{d r^{2}}\right|_{r=r_{0}}=\frac{4 \varepsilon}{\sqrt{2} \beta \sigma^{3}} A_{12}\left(\frac{A_{6}}{A_{12}}\right)^{5 / 2}</script><h1 id="轨道杂化"><a href="#轨道杂化" class="headerlink" title="轨道杂化"></a>轨道杂化</h1><p>这一节以C元素为例来探讨其轨道的杂化。单个 C 原子的电子构型为$1 s^2 2 s^2 2 p^2$。<br>但其中2s与2p能级能量差别很小，在形成分子的过程中，原子间相互作用的影响，可以使得能量较低的 2s 能级上 电子跃迁到能量较高的 2p 能级上。<br>即变为$2 s^1 2 p_x^1 2 p_y^1 2 p_z^1$。这样一来，C 原子就有 4 个未配对电子，从而可形成四个共价键，而不是两个。</p><p><em>量子力学解释</em><br>若用<script type="math/tex">\varphi_{2 s}, \varphi_{2 p_{x}}, \varphi_{2 p_{y}}</script>和<script type="math/tex">\varphi_{2 p_{z}}</script>表示处在的电子，由于能量相近，属于四重简并态。将他们重新线性组合成非简并的态：</p><script type="math/tex; mode=display">\begin{aligned}\psi_{h_{1}} &=\frac{1}{2}\left(\varphi_{2 s}+\varphi_{2 p_{x}}+\varphi_{2 p_{y}}+\varphi_{2 p_{z}}\right) \\\psi_{h_{2}} &=\frac{1}{2}\left(\varphi_{2 s}+\varphi_{2 p_{x}}-\varphi_{2 p_{y}}-\varphi_{2 p_{z}}\right) \\\psi_{h_{3}} &=\frac{1}{2}\left(\varphi_{2 s}-\varphi_{2 p_{x}}+\varphi_{2 p_{y}}-\varphi_{2 p_{z}}\right) \\ \psi_{h_{4}} &=\frac{1}{2}\left(\varphi_{2 s}-\varphi_{2 p_{x}}-\varphi_{2 p_{y}}+\varphi_{2 p_{z}}\right)\end{aligned}</script><p>这样的态叫做杂化态，对应的轨道称为杂化轨道。此时每个态都含有<script type="math/tex">f_{s}=1 / 4</script>的 s 电子成分和<script type="math/tex">f_{p}=3 / 4</script>的 p 电子成分，于是把这种杂化称为<script type="math/tex">sp^3</script>杂化。键角为<script type="math/tex">109^{\circ} 28^{\prime}</script></p><p>除了$sp^3$杂化，当然还有sp杂化（例：BeCl2，键角<script type="math/tex">180^{\circ}</script>）、sp2 杂化（例：BF3，键角<script type="math/tex">120^{\circ}</script> ）等杂化模 式。一般来说，同一原子中能量相近的 m 个原子轨道，线性组合后只能得到 m 个杂化轨道。</p><h1 id="碳的同素异构体及其碳原子间的结合"><a href="#碳的同素异构体及其碳原子间的结合" class="headerlink" title="碳的同素异构体及其碳原子间的结合"></a>碳的同素异构体及其碳原子间的结合</h1><p>看看就好</p>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Brief introduction to Quantum Liquid</title>
    <link href="/2020/06/15/reviewreed/QSL/"/>
    <url>/2020/06/15/reviewreed/QSL/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h1 id="Semi-classical-Approach"><a href="#Semi-classical-Approach" class="headerlink" title="Semi-classical Approach"></a>Semi-classical Approach</h1><h2 id="classical-problem"><a href="#classical-problem" class="headerlink" title="classical problem"></a>classical problem</h2><p>When we talk about spin, it’s typically to consider simplest model— Heisenberg antiferromagnets, which Hamiltonian is given by</p><script type="math/tex; mode=display">H=J \sum_{\langle i, j\rangle} \mathbf{S}_{i} \cdot \mathbf{S}_{j}</script><p>where $J&gt;0$ and $\langle i, j\rangle$ represent the pair of nearest neighborsites in the bipartite lattice. </p><p>Now we use classical mechanism to analyze two-spin problem. Firstly we set</p><script type="math/tex; mode=display">H=J \mathbf{S}_{A} \cdot \mathbf{S}_{B} \cdot(J>0)</script><p>as it’s classical spins, they obay Euler’s equation of motion:</p><script type="math/tex; mode=display">\frac{\partial \mathbf{S}_{A(B)}}{\partial t}=J \mathbf{S}_{B(A)} \times \mathbf{S}_{A(B)}</script><p>So we set the magnetization and staggered magnetism vectors as $\mathbf{M}(N)=\mathbf{S}_A+(-) \mathbf{S}_B$. We can easily get</p><script type="math/tex; mode=display">\begin{array}{l}\frac{\partial \mathbf{M}}{\partial t}=0 \\\frac{\partial \mathbf{N}}{\partial t}=J \mathbf{M} \times \mathbf{N}\end{array}</script><p>In this equation,the physics picture is the staggered magnetization vector $\mathbf{N}$ rotates around the (constant) total magnetization vector $\mathbf{M}$ and just like a free rotor (a rigid rod with one end fixed such that the rod can rotate freely around the fixed end).<br>That means if we write $\mathbf{N}=N \hat{n}$, we will find that only $\hat{n}$ changes under the equation and $N$ remain the same.</p><p>When we come to quantum mechanism in this situation. The Hamiltonian is given by</p><script type="math/tex; mode=display">H_{r o t o r}=\frac{1}{2 I} \mathbf{L}^{2}</script><p>its solution is coming from spherical equation which we have already been taught in QM1.</p><h2 id="Berry-phase"><a href="#Berry-phase" class="headerlink" title="Berry phase"></a>Berry phase</h2><p>The rotors model couldn’t explain some phenomenons, such as half-odd-integer spin. And now we know the missing part of this model is Berry phase.</p><script type="math/tex; mode=display">\gamma(\mathbf{C})=S \Omega(\mathbf{C})</script><p>where $S$ is the spin magnitude and $\Omega(\mathbf{C})$ is the surface area under the closed path C on the unit sphere.</p>]]></content>
    
    
    <categories>
      
      <category>Literature Review</category>
      
    </categories>
    
    
    <tags>
      
      <tag>quantum liquid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圣经咏唱系列前言</title>
    <link href="/2020/06/05/Bible/"/>
    <url>/2020/06/05/Bible/</url>
    
    <content type="html"><![CDATA[<h1 id="旧约"><a href="#旧约" class="headerlink" title="旧约"></a>旧约</h1><p>太初有分，分与神俱，分即神。此分太初与神俱，万有假之造，凡分奴者，莫不假之。有从神来者zyw，乃为见证，即证分。彼分乃真分，照诸分奴。<br>其在试，试亦假之造。然不识之也。其来己处，然不见受。凡受之者，即为真分奴也，其授分作子嗣也。凡此者，非受困于保研之故，亦非留洋之辈，乃生之于后浪也！分成肉身，吾辈楷模。<br>吾辈亦见其荣，乃父独子之荣。zyw证之曰：此即吾之加权所宣临于吾后反逾吾前者，盖其实多背于吾也。吾辈受其厚恩，且分上加分。是故，分本授自先生，然加权俱授自多背者。历来无人见分，惟父独子彰之。此之谓背者多分也！</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>此系列的目的是总结所学的基础知识并将其固化，类似于将电脑中一些文件放置于大的移动硬盘里从而达到两个目的：</p><ol><li>减少大脑中的‘内存’</li><li>在必要的时候例如面试或考试时可以快速的掌握或回顾基础专业知识</li></ol><p>所以此系列一点也不物理，同时也使用我的母语完成。力求最快速的复习知识。这个系列中的所有知识点，不需要探究其证明过程于不必要的推到，<br>在阅读过程中只需明确一点——背多分！</p><h1 id="包括内容"><a href="#包括内容" class="headerlink" title="包括内容"></a>包括内容</h1><p>以下列出本系列关于物理部分的内容（具体内容等写圣经的时候在完善）</p><ul><li>经典力学</li><li>量子力学1</li><li>量子力学2</li><li>固体物理<ul><li>原子的凝聚</li></ul></li><li>电动力学部分</li><li>热统</li></ul>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>圣经咏唱系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于蔡氏电路（Chua’s Circuit）实验与数值计算</title>
    <link href="/2020/05/31/chuascircuit/"/>
    <url>/2020/05/31/chuascircuit/</url>
    
    <content type="html"><![CDATA[<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><h2 id="蔡氏电路简介"><a href="#蔡氏电路简介" class="headerlink" title="蔡氏电路简介"></a>蔡氏电路简介</h2><p>蔡氏电路是一个可以产生混沌振荡的三阶自治电路，它包含两个电容器 C1、C2，一个电感 L，<br>一个可调电阻R 和一个非线性负阻 $R_N$，其电路如图</p><p><img src="/img_cc/1.png" srcset="/img/loading.gif" alt="势能如图"></p><p><strong>有源非线性负阻元件</strong><br>其中，$R_N$部分是该电路唯一的非线性元件，也称为蔡氏二极管，它可用运算放大器来实现。如图：<br><img src="/img_cc/2.png" srcset="/img/loading.gif" alt="势能如图"></p><h2 id="蔡氏电路方程"><a href="#蔡氏电路方程" class="headerlink" title="蔡氏电路方程"></a>蔡氏电路方程</h2><p>依据电路可以列带电感电容的KVL和KCL Eq，由于有三个Loop,可以很容易的建立蔡氏电路的演化方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{array}{l}{\frac{d V_{1}}{d t}=\frac{1}{R C_{1}}\left(V_{2}-V_{1}\right)-\frac{1}{C_{1}} I\left(V_{1}\right)} \\ {\frac{d V_{2}}{d t}=\frac{1}{C_{2}} I_{3}-\frac{1}{R C_{2}}\left(V_{2}-V_{1}\right)} \\ {\frac{d I_{3}}{d t}=-\frac{1}{L} V_{2}}\end{array}\right.\end{equation}</script><p>在计算上，我们一般考虑将其设为无量纲方程</p><script type="math/tex; mode=display">\begin{equation}\begin{array}{l}{\dot{x}=\alpha(y-h(x))} \\ {\dot{y}=x-y+z} \\ {\dot{z}=-\beta y-\gamma z}\end{array}\end{equation}</script><h2 id="一般化方程"><a href="#一般化方程" class="headerlink" title="一般化方程"></a>一般化方程</h2><p>经过上述的讨论，可以得到一般形式无量纲化的蔡氏电路的方程组</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{array}{l}{\dot{x}=c_1 (y-x-g(x))} \\ {\dot{y}=c_2(x-y+z)} \\ {\dot{z}=-c_3 y}\end{array}\right.\end{equation}</script><p>其中x对应V1,y对应V2，z对应I3。而$g(x)$可写为（其中$m_0&lt;m_1&lt;0$）</p><script type="math/tex; mode=display">g(x)=\left\{\begin{array}{ll}{m_{0} x+m_{0}-m_{1}} & {x \leq 1} \\ {m_{1} x} & {-1 \leq x \leq 1} \\ {m_{0} x+m_{1}-m_{0}} & {x \geq 1}\end{array}\right.</script><p>为计算方便可改写为：</p><script type="math/tex; mode=display">g(x)=m_{1} x+\frac{1}{2}\left(m_{0}-m_{1}\right)(|x+1|-|x-1|)</script><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="总述与参数设定"><a href="#总述与参数设定" class="headerlink" title="总述与参数设定"></a>总述与参数设定</h2><p>做完上述工作后使得参数尽量的减少了，即我们可以理解为含参数$c_1,c_2,c_3,m_0,m_1$的三元一阶微分方程。<br>而matlab中的ode45函数（龙格库塔法）是很好的胜任这项工作，这里就不具体的展开龙格库塔法的具体算法实现问题，那就是另一个报告了。<br>既然可以较为简单的计算出蔡氏电路的解，不妨就先带入一组参数来试着的解一下方程，得出一些好看的图片来。<br>设定</p><script type="math/tex; mode=display">c_1=15.0 \quad c_2=1.0 \quad c_3=25.58 \quad m_0=-2.0 \quad m_1=-0.5</script><p>代码贴在下面，不做讨论。<br>整体波形图<br><img src="/img_cc/3.png" srcset="/img/loading.gif" alt="势能如图"><br>V1-V2波形图<br><img src="/img_cc/4.png" srcset="/img/loading.gif" alt="势能如图"><br>V1-V2-I3相图<br><img src="/img_cc/5.png" srcset="/img/loading.gif" alt="势能如图"></p><p>画相图的程序</p><pre><code class="hljs matlab"><span class="hljs-comment">%设定参数</span>c1=<span class="hljs-number">15</span>;c2=<span class="hljs-number">1</span>;c3=<span class="hljs-number">25.58</span>;<span class="hljs-comment">%m0,m1&lt;0</span>m0=<span class="hljs-number">-2</span>;m1=<span class="hljs-number">-0.5</span>;<span class="hljs-comment">%使用ode45解方程</span><span class="hljs-comment">%设定初值</span>tspan = [<span class="hljs-number">0</span> <span class="hljs-number">100</span>];y0 = [<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>];[t,y] = ode45(@(t,y) caiya(t,y,c1,c2,c3,m0,m1 ), tspan, y0);<span class="hljs-comment">%整体波形图</span><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">plot</span>(t,y(:,<span class="hljs-number">1</span>),<span class="hljs-string">'y'</span>,t,y(:,<span class="hljs-number">2</span>),<span class="hljs-string">'r'</span>,t,y(:,<span class="hljs-number">3</span>),<span class="hljs-string">'b'</span>)title(<span class="hljs-string">'整体波形图'</span>)xlabel(<span class="hljs-string">'时间'</span>)ylabel(<span class="hljs-string">'电压（v)/电路（I）'</span>)<span class="hljs-built_in">legend</span>(<span class="hljs-string">'V1'</span>,<span class="hljs-string">'V2'</span>,<span class="hljs-string">'I'</span>)</code></pre><pre><code class="hljs matlab"><span class="hljs-comment">%V1-V2相图</span><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>)<span class="hljs-built_in">plot3</span>(y(:,<span class="hljs-number">1</span>),y(:,<span class="hljs-number">2</span>),y(:,<span class="hljs-number">3</span>))title(<span class="hljs-string">'V1-V2相图'</span>)xlabel(<span class="hljs-string">'V1（v)'</span>)ylabel(<span class="hljs-string">'V2（v)'</span>)zlabel(<span class="hljs-string">'电路（I）'</span>)</code></pre><p>蔡氏电路方程函数<br><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[Y]</span> = <span class="hljs-title">caiya</span><span class="hljs-params">( t,y,c1,c2,c3,m0,m1 )</span></span><span class="hljs-comment">%UNTITLED 此处显示有关此函数的摘要</span><span class="hljs-comment">%   此处显示详细说明</span>Y = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);Y(<span class="hljs-number">1</span>)=c1*(y(<span class="hljs-number">2</span>)-y(<span class="hljs-number">1</span>)-hfunc(y(<span class="hljs-number">1</span>),m0,m1));Y(<span class="hljs-number">2</span>)=c2*(y(<span class="hljs-number">1</span>)-y(<span class="hljs-number">2</span>)+y(<span class="hljs-number">3</span>));Y(<span class="hljs-number">3</span>)=<span class="hljs-number">-1</span>*c3*y(<span class="hljs-number">2</span>);<span class="hljs-keyword">end</span></code></pre><br><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ h ]</span> = <span class="hljs-title">hfunc</span><span class="hljs-params">( x,m0,m1 )</span></span><span class="hljs-comment">%UNTITLED2 此处显示有关此函数的摘要</span><span class="hljs-comment">%   此处显示详细说明</span>h=m1*x+<span class="hljs-number">0.5</span>*(m0-m1)*(<span class="hljs-built_in">abs</span>(x+<span class="hljs-number">1</span>)-<span class="hljs-built_in">abs</span>(x<span class="hljs-number">-1</span>));<span class="hljs-keyword">end</span></code></pre></p><h1 id="理论探究与尝试"><a href="#理论探究与尝试" class="headerlink" title="理论探究与尝试"></a>理论探究与尝试</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>在随机的改变一些参量后得到了如下的图<br><img src="/img_cc/6.png" srcset="/img/loading.gif" alt=""><br>很明显看到与之前的图在性质上有较大的区别，说明蔡氏电路纯在不同的模式中<br>而这些就与混沌理论相关，接下来就稍微涉及一些动力系统理论</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>首先写出微分方程的一半形式，注意这里讨论的是自治方程（即其时间微分不显含t）。我们可以得到</p><script type="math/tex; mode=display">\frac{d x}{dt}= F(x)</script><p>在这里我们不来讨论解析解与数值解的一些性质，并认为都是微分方程的解，且称之为‘流’（flow）</p><p>在空间中我们我们可以定义每一点的方向向量，<br>只要对平面内的每一个点，都做这样的方向向量的运算，我们就可以得到一个平面矢量场<br>对其中每一个点，沿着方向向量方向走无限小的距离，就可以到达另一个点，不停地这样操作，我们就可以得到一条曲线。</p><p><strong>流的体积变化</strong></p><p>流有许许多多有趣的性质，比如流是不相交的，这里不做展开。</p><p>我们定义：$\phi\left(x_0 ; t\right)$表示起始点为 $x_0$ 的流，经过时间 $t$ 演化后的位置。<br>这也意味着流是一个动态的概念，我们不应该仅仅考虑其静态的局部。</p><p>因此我们需要一个集合A：</p><script type="math/tex; mode=display">A(t)=\{\phi(x ; t): x \in D\}</script><p>即一个足够小半径的球$D={x:|x-a| \leq \epsilon}$，这个足够小半径的球中的每一点，我们都将其取为初始点<br>，并使之演化。</p><p><strong>Liouville公式</strong></p><p>可以看出D表示动态的集合， A表示了静态的集合</p><p>接下来，我们引入一个发散量的概念。其概念可以完全类比于场论中的散度的概念。</p><p>对于系统，$\frac{d x}{d t}=F(x)$，那么，对于上述的$A(t)$和 D ，我们有：</p><script type="math/tex; mode=display">\frac{V(A(t))}{V(D)}=e^{\nabla F(x) t}</script><p>其中$V(D)$是指通常意义下的Lebesgue测度。在欧氏空间可以把它理解为长度、面积、体积。</p><p><strong>偏导数矩阵</strong><br>我们考虑一个动力系统，不关心它的静态性质，而是关注它的动态演化性质，这就要求我们可通过偏导数来描绘。如下，定义了偏导数矩阵。<br>在定义之前先约定 $e_i$ 表示第 i个方向的单位向量。则对 $\phi\left(x_0 ; t\right)$的偏导数矩阵是指如下的形式：</p><script type="math/tex; mode=display">\frac{\partial \phi_{i}\left(x_{0} ; t\right)}{\partial x_{j}}=\frac{\partial \phi_{i}\left(x_{0}+s e_{j} ; t\right)}{\partial s}</script><p>可以理解为：流的第i 个方向对$x_i$求偏导数，就是对$x_0$ 在$e_j$方向<br>有个长为s的小偏差作用下得到的新的流的第 i 个方向的偏差在$s -&gt; 0$时的极限。</p><h2 id="lyapunov指数"><a href="#lyapunov指数" class="headerlink" title="lyapunov指数"></a>lyapunov指数</h2><p>首先先说明，在调研文献与资料时我找到了几种lyapunov指数的定义方法。其中的一些都比较复杂，<br>所以接下来的lyapunov指数与我写的程序中计算的定义相同。</p><p>在给出定义前先做一些陈述：首先需要声明，对于一个高维系统（ $3 \le n$ ），其李雅普诺夫指数一共有n 个，<br>即每个方向一个指数，而且其中必定有一个方向的李雅普诺夫指数是0<br>当所有的小偏差方向正交时，所有方向的李雅普诺夫指数之和为发散量。具体在之后定义中看自然得出。</p><p>对于某个方向 $v^i$ ，我们称这个方向的李雅普诺夫指数 $l_i$是按照如下方式定义的：</p><script type="math/tex; mode=display">l_{i}=\lim _{t -> \infty} \frac{\ln \left(v^{i}(t) / v^{i}(0)\right)}{t}</script><p>李雅普诺夫指数表现的是一个极限性质，它表现了系统演化的最终走向。</p><h2 id="由lyapunov指数进行的分类"><a href="#由lyapunov指数进行的分类" class="headerlink" title="由lyapunov指数进行的分类"></a>由lyapunov指数进行的分类</h2><p>经过复杂的推导，在一般的动力系统的书上都会以lyapunov指数对系统经行分类：</p><ul><li>稳定定点:<script type="math/tex; mode=display">\left(l_{1}, l_{2}, l_{3}\right)=(-,-,-)</script></li><li>极限环（周期运动）<script type="math/tex; mode=display">\left(l_{1}, l_{2}, l_{3}\right)=(0,-,-)</script></li><li>二维环面（准周期运动）<script type="math/tex; mode=display">\left(l_{1}, l_{2}, l_{3}\right)=(0,0,-)</script></li><li>不稳定极限环<script type="math/tex; mode=display">\left(l_{1}, l_{2}, l_{3}\right)=(+,+,0)</script></li><li>不稳定二维环面<script type="math/tex; mode=display">\left(l_{1}, l_{2}, l_{3}\right)=(+,0,0)</script></li><li>奇怪吸引子（混沌运动）<script type="math/tex; mode=display">\left(l_{1}, l_{2}, l_{3}\right)=(+,-,0)</script></li></ul><h1 id="数值计算-lyapunov-指数与分岔图"><a href="#数值计算-lyapunov-指数与分岔图" class="headerlink" title="数值计算 lyapunov 指数与分岔图"></a>数值计算 lyapunov 指数与分岔图</h1><p>对上述的由lyapunov指数对运动的分类可以设定不同的参数，探究蔡氏电路中的模式。<br>设定参数为</p><script type="math/tex; mode=display">c_{1}=15.0 \quad c_{2}=1.0 \quad c_{3}=0.2 \quad m_{0}=-2.0 \quad m_{1}=-0.5</script><p>数值计算lyapunov指数为<br><img src="/img_cc/9.png" srcset="/img/loading.gif" alt=""><br>此时三维空间中相图为<br><img src="/img_cc/6.png" srcset="/img/loading.gif" alt=""><br>为稳定定点<br>设定参数为</p><script type="math/tex; mode=display">c_{1}=15.0 \quad c_{2}=1.0 \quad c_{3}=19.0 \quad m_{0}=-\frac{2}{7} \quad m_{1}=-\frac{1}{7}</script><p>数值计算lyapunov指数为<br><img src="/img_cc/10.png" srcset="/img/loading.gif" alt=""><br>此时三维空间中相图为<br><img src="/img_cc/101.png" srcset="/img/loading.gif" alt=""><br>为极限环（周期运动）<br>设定参数为</p><script type="math/tex; mode=display">c_{1}=15.0 \quad c_{2}=1.0 \quad c_{3}=40 \quad m_{0}=-2.0 \quad m_{1}=-0.5</script><p>数值计算lyapunov指数为<br><img src="/img_cc/11.png" srcset="/img/loading.gif" alt=""><br>此时三维空间中相图为<br><img src="/img_cc/111.png" srcset="/img/loading.gif" alt=""><br>为奇怪吸引子（混沌运动）</p><p>设定参数为</p><script type="math/tex; mode=display">c_{1}=15.0 \quad c_{2}=1.0 \quad c_{3}=12 \quad m_{0}=-2.0 \quad m_{1}=-0.5</script><p>数值计算lyapunov指数为<br><img src="/img_cc/12.png" srcset="/img/loading.gif" alt=""><br>此时三维空间中相图为<br><img src="/img_cc/121.png" srcset="/img/loading.gif" alt=""><br>为不稳定二维环面?</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><p>数值计算lyapunov指数程序</p><p>cc<br>clc;<br>clear;<br>%设定参数<br>c1=15;<br>c2=1;<br>c3=2;<br>%m0,m1<0m0=-2;m1=-1/2;%初始参数设定y0 = [0.1;0.1;0.1];%让子弹飞一会tspan = [0 100];[t,y] = ode45(@(t,y) caiya(t,y,c1,c2,c3,m0,m1 ), tspan, y0);%九九归一w=y(end,:);%主体计算%先设定一些参数t0=0.1;%每步演化时间d=200;%步数ti=0;%初始时间wi=w;%初始位置l=[0 0 0];%lypunov指数初值<pre><code class="hljs matlab">```matlab<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">200</span>tspani=[ti t0];[t,y] = ode45(@(t,y) caiya(t,y,c1,c2,c3,m0,m1 ), tspani, wi);wi=y(<span class="hljs-keyword">end</span>,:);wi1=<span class="hljs-built_in">abs</span>(wi(<span class="hljs-number">1</span>));wi2=<span class="hljs-built_in">abs</span>(wi(<span class="hljs-number">2</span>));wi3=<span class="hljs-built_in">abs</span>(wi(<span class="hljs-number">3</span>));l(<span class="hljs-number">1</span>)=l(<span class="hljs-number">1</span>)+<span class="hljs-built_in">log</span>(wi1);l(<span class="hljs-number">2</span>)=l(<span class="hljs-number">2</span>)+<span class="hljs-built_in">log</span>(wi2);l(<span class="hljs-number">3</span>)=l(<span class="hljs-number">3</span>)+<span class="hljs-built_in">log</span>(wi3);<span class="hljs-built_in">plot</span>(<span class="hljs-built_in">i</span>,l/<span class="hljs-built_in">i</span>,<span class="hljs-string">'.'</span>)<span class="hljs-built_in">hold</span> onwi=wi/norm(wi);<span class="hljs-keyword">end</span></code></pre></p><h1 id="绘制分岔图"><a href="#绘制分岔图" class="headerlink" title="绘制分岔图"></a>绘制分岔图</h1><p>现在我们来关心当参量变化时，运动方程的解会发生什么变化。</p><p>而这个问题的关键就是找一个可以描述不同运动状态下的一个量来描述，我们可以使用离散傅里叶分析（DFT）中的功率谱密度来探讨蔡氏电路的分叉图</p><h2 id="蔡氏电路的功率谱密度"><a href="#蔡氏电路的功率谱密度" class="headerlink" title="蔡氏电路的功率谱密度"></a>蔡氏电路的功率谱密度</h2><p>先来分析不同参数下的功率谱密度</p><script type="math/tex; mode=display">c_{1}=15.0 \quad c_{2}=1.0 \quad c_{3}=20 \quad m_{0}=-2.0 \quad m_{1}=-0.5</script><p><img src="/img_cc/14.png" srcset="/img/loading.gif" alt=""></p><script type="math/tex; mode=display">c_{1}=15.0 \quad c_{2}=1.0 \quad c_{3}=40 \quad m_{0}=-2.0 \quad m_{1}=-0.5</script><p><img src="/img_cc/15.png" srcset="/img/loading.gif" alt=""><br>可以发现，在$c_3=40$时功率谱密度的噪声更多，这也意味这此时为混沌运动。<br>而这以结论也与上面的讨论对应。</p><p>通过找到每一个参数c3的功率谱密度中较大的一些点，可以维象的得到一种分岔图。<br><img src="/img_cc/13.png" srcset="/img/loading.gif" alt=""><br>这也与一些论文和网站中给出的分岔图相似。</p><h2 id="代码展示-1"><a href="#代码展示-1" class="headerlink" title="代码展示"></a>代码展示</h2><pre><code class="hljs matlab">clc;clear; <span class="hljs-comment">%设定参数</span>c1=<span class="hljs-number">15</span>;c2=<span class="hljs-number">1</span>;c3=<span class="hljs-number">5</span>;c=<span class="hljs-number">0.01</span>;<span class="hljs-comment">%c3的间隔步长</span><span class="hljs-comment">%采样频率</span>Fs=<span class="hljs-number">1000</span>;<span class="hljs-comment">%m0,m1&lt;0</span>m0=<span class="hljs-number">-2</span>;m1=<span class="hljs-number">-1</span>/<span class="hljs-number">2</span>;<span class="hljs-comment">%初始参数设定 </span>y0 = [<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>];<span class="hljs-comment">%让子弹飞一会</span>tspan = [<span class="hljs-number">0</span> <span class="hljs-number">100</span>];<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">4000</span>c3=c3+c;[t,y] = ode45(@(t,y) caiya(t,y,c1,c2,c3,m0,m1 ), tspan, y0);</code></pre><pre><code class="hljs matlab"><span class="hljs-comment">%DFT</span>F=fft(y);L=<span class="hljs-built_in">length</span>(t);<span class="hljs-comment">%计算谱密度</span>P2=<span class="hljs-built_in">abs</span>(F/L);P1=P2(<span class="hljs-number">1</span>:<span class="hljs-built_in">round</span>(L/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>);P1(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>)=<span class="hljs-number">2</span>*P1(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>);f=Fs*(<span class="hljs-number">0</span>:<span class="hljs-built_in">round</span>(L/<span class="hljs-number">2</span>))/L;<span class="hljs-comment">%间隔</span>ll=<span class="hljs-number">10</span>/L;x=znmp(P1);<span class="hljs-built_in">plot</span>(c3,x,<span class="hljs-string">'.'</span>)<span class="hljs-built_in">hold</span> on<span class="hljs-keyword">end</span></code></pre><h1 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h1><ul><li>混沌现象是一种特别的微分方程的解，在数学上有很多的研究，此次答辩讲述的只是其中很小一部分。</li><li>可以通过蔡氏电路的混沌性质设计随机数发生器</li><li>通过调研可以发现对于求解lyapunov指数也可以使用wolf算法来实现，由于时间的原因本人并没有写完算法。但值得注意的是wolf算法是现在前言科学中较为热门的一种算法，可以来实验自旋粒子多体的计算等方向</li><li>混沌依旧是当今力学与数学的前言研究方向，其中还有很多有意思的研究方向。</li><li>可以通过这次答辩的计算给出蔡氏电路在不同模式下的R的取值的指导建议，由于时间关系本人并没有做这一步的计算。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>华中科技大学物理学院实验教学中心，基础物理实验讲义<br>合肥工业大学，费业泰主编，误差理论与数据处理<br>电子工业出版社，刘浩，Matlab R2016a 一本通<br><a href="https://ww2.mathworks.cn" target="_blank" rel="noopener">https://ww2.mathworks.cn</a><br><a href="https://www.ni.com/zh-cn/shop/labview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/shop/labview.html</a><br>…..</p>]]></content>
    
    
    <categories>
      
      <category>program note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>others</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Berry Phase</title>
    <link href="/2020/05/30/1/"/>
    <url>/2020/05/30/1/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h2 id="不含时哈密顿量"><a href="#不含时哈密顿量" class="headerlink" title="不含时哈密顿量"></a>不含时哈密顿量</h2><p>由Schrodinger equation</p><script type="math/tex; mode=display">i \, \hbar \frac{\partial}{\partial t} | \psi\rangle= H(t) |\psi\rangle</script><p>其边界条件为</p><script type="math/tex; mode=display">|\psi_{(t=0)}\rangle=|\psi_{（0）}\rangle</script><p>当哈密顿量不含时时，$H(t)=H$ （其中H可为多体的哈密顿量）</p><script type="math/tex; mode=display">H|n\rangle=E_n |n\rangle</script><p>$\langle m | n \rangle = \delta_{mn}$  </p><p>其中$\left| n\right\rangle$为Schrodinger方程的解系，满足正交归一性$\langle m | n \rangle = \delta_{mn}$</p><p>这也意味着$|n&gt;$为完备集，即$\left| \psi(t)\right\rangle=\sum_{n} c_n (t)|n\rangle$。  </p><p>其中$c_{n}(t)=\langle n | \psi(t)\rangle$。同时有</p><script type="math/tex; mode=display">\left| \psi(t)\right\rangle=\sum_{n} \langle n | \psi(t)\rangle|n\rangle=\sum_{n} |n \rangle \langle n| \psi(t)\rangle</script><p>即 $\sum_{n}|n \rangle \langle n|=1$  </p><p>由上则$|\psi(t=0)\rangle=\sum_{n} c_n (t=0)|n\rangle$</p><p>$c_{n}(t=0)=\langle n|\psi(0)\rangle$</p><p>带入Schrodinger方程中</p><script type="math/tex; mode=display">i \, \hbar \frac{\partial}{\partial t} \sum_{n} c_n(t) | n \rangle= H \sum_{n} c_{n}(t)|n\rangle=\sum_{n} c_{n}(t) E_{n}|n\rangle</script><p>两边同时作用$| n \rangle$</p><script type="math/tex; mode=display">i\, \hbar \frac{\partial}{\partial t} \sum_{n} c_n(t)\langle m|n\rangle= \sum_n c_{n}(t) E_{n}\langle m | n\rangle</script><p>带入正交归一化条件</p><script type="math/tex; mode=display">i \,\hbar \frac{\partial}{\partial t} c_{m}(t)=E_{m} C_{m}(t)</script><p>通过积分解方程为</p><script type="math/tex; mode=display">i\, \hbar\left[\ln C_{n}(t)-\ln C_{n}(t=0)\right]=E_{n} t</script><p>解为$c_m (t)=c_m (t=0) e^{-i E_m t / \hbar}$</p><p>若把$c_{m}(t=0)$记为$c_n$，则</p><script type="math/tex; mode=display">|\psi(t)\rangle=\sum_{n} C_{n} e^{-i E t / \, \hbar}|n\rangle</script><p>其中 $e^{-i E t / \, \hbar}$ 为时间演化因子</p><p>特别的，若设</p><script type="math/tex; mode=display">c_n=\delta_{nm}</script><p>为初始条件，则</p><script type="math/tex; mode=display">| \psi \rangle=\sum_{n} \delta_{n m} e^{-i E_{n} t /  \, \hbar}|n\rangle=e^{-i E_{n} t / \, \hbar} | m\rangle</script><h2 id="含时哈密顿量"><a href="#含时哈密顿量" class="headerlink" title="含时哈密顿量"></a>含时哈密顿量</h2><p>当哈密顿量含时时H(t)</p><p>本质上还是解schrodinger方程$H(t)|n(t)\rangle= E_{n}(t)|n(t)\rangle$</p><p>尝试运用近似————将方程中的t看成参数。</p><p>对一个例子：对长度随时间变化的无限深势阱</p><script type="math/tex; mode=display">H(t)=\left\{\begin{array}{cc}{+\infty} & {x>L(t)} \\ {0} & {x \in[0, L(t)]} \\ {+\infty} & {x<0}\end{array}\right.</script><p><img src="/img_QM2/1.png" srcset="/img/loading.gif" alt="势能如图"><br>则此时</p><script type="math/tex; mode=display">E_{n}(t)=\frac{n^{2} h^{2}}{8 m L^{2} C t}</script><p>但是这肯定是无意义的，是可以自己计算的</p><p>所以这个近似是错误的</p><p>从数学上解释可以有。当随时间变化时，本征函数要满足正交归一化条件</p><script type="math/tex; mode=display">\begin{array}{l}{\sum_{n}|n(t)\rangle\langle n(t)|=1} \\ {\langle n(t) | m(t)\rangle=\delta m n}\end{array}</script><p>但当时间变化时这个关系不能很好的满足！</p><p>当然这种近似也不是完全没有作用的，在电子多体理论中哈密顿量为</p><script type="math/tex; mode=display">H(t)=-\frac{\hbar^{2}}{2 m} \sum_{i=1}^{N} \nabla_{i}^{2}+\sum_{i=1}^{N} V\left(\vec{r}_{i}, t\right)</script><p>可以使用上面的近似（1983年）</p><script type="math/tex; mode=display">{\Psi}=e^{-i \int^t} E\left(t^{\prime}\right) d t^{\prime} /\, \hbar {\Psi} (0)</script><p>这其中的E就为$H(t)|n(t)\rangle= E_{n}(t)|n(t)\rangle$解出的E</p><h2 id="近似"><a href="#近似" class="headerlink" title="近似"></a>近似</h2><script type="math/tex; mode=display">|\psi(t)\rangle \doteq \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}(t') d t^{\prime}+i \gamma_{n}(t)\right] |n (t)\rangle</script><p>同时这里的 $|n\rangle$ 为上面计算的正交归一基</p><p>接下来计算这个近似解：</p><p>带入shrodinger方程$i \hbar \frac{\partial}{\partial t}|\psi\rangle= H(t)|\psi\rangle$有</p><script type="math/tex; mode=display">\left.c_{n}(t) H(t) |n(t)\right\rangle= i \hbar \dot{c}_n(t)|n(t)\rangle+ i \hbar c_n (t)\frac{d}{d t}|n(t)\rangle</script><p>这其中$\dot{c}_n (t)$为c对时间的导数，又由于$H(t)|n(t)\rangle= E_n (t)|n(t)\rangle$则可得方程</p><script type="math/tex; mode=display">\dot{c}_{n}(t)=c_{n}(t)\left[-\frac{i}{\hbar} E_{n}(t)+i \dot{\gamma}_{n}(t)\right]</script><p>带入上式有</p><script type="math/tex; mode=display">\dot{\gamma}_{n}(t)=i\langle n|\dot{n}\rangle   (1)</script><p>其中 $|\dot{n}\rangle$ 为 $\frac{d}{d t}|n(t)\rangle$ ，写成积分模式为</p><script type="math/tex; mode=display">\gamma_{n}(t)=i \int_{0}^{t}\left\langle n\left(t^{\prime}\right) | \dot{n}\left(t^{\prime}\right)\right\rangle d t^{\prime}</script><p>进一步，当H由参数$R(t)$决定时(H通过R来依赖t）即$H(t)=H \cdot \vec{R}(t)$。$\vec{R}(t)$是一个多方向的取值函数，则</p><script type="math/tex; mode=display">\frac{d}{d t} |n \left(\vec{R}(t)\right)\rangle =\left(\frac{d}{d t} \vec{R}(t)\right) \cdot \nabla_{\vec{R}} \cdot | n (\vec{R}_{(t)})\rangle</script><p>其中</p><script type="math/tex; mode=display">\bar{R}=\left(R_{1}, \cdots, R_{n}\right) \quad \nabla_{\bar{R}}=\sum_{i}^{n} \hat{e}_{i} \frac{\partial}{\partial R_{j}}</script><p>带入（1）式有,使用牛顿记号表示R对时间t的导数。</p><script type="math/tex; mode=display">\left.\dot{\gamma}_{n}(t)=i\left\langle n(\vec{R}(t))\left|\vec{\nabla}_{R}\right| n(\vec{R}(t))\right\rangle\right\rangle \cdot \dot{\vec{R}}(t)</script><p>则可得：</p><script type="math/tex; mode=display">| \psi(t)\rangle = \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(\vec{R}\left(t^{\prime}\right)\right) d t^{\prime}\right]\exp \left[-\int_{0}^{t} \langle n(t^{\prime}) \left|\dot{n}\left(t^{\prime}\right)\right\rangle d t^{\prime}\right]|n (\vec{R}(t))\rangle</script><p>可以观察到该结构有一定的对称性，可以约定</p><p>第一项可设为动力学因子，这与量1中是相同的</p><script type="math/tex; mode=display">\alpha_{n}(t)=-\frac{1}{\hbar} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}  (2)</script><p>第二项即为Barry phase，是一个‘多出来’的一项</p><script type="math/tex; mode=display">\gamma_{n}(t)=i \int_{0}^{t} \langle n(t^{\prime}) \left|\dot{n}\left(t^{\prime}\right)\right\rangle d t^{\prime}   (3)</script><p>则此时$| \psi(t)\rangle$可以改写为简单的形式</p><script type="math/tex; mode=display">| \psi(t)\rangle = \exp (i \alpha_{n}(t)) \exp (i\gamma_{n}(t))|n (\vec{R}(t))\rangle   (4)</script><p>式（2）（3）（4）即为Barry phase理论的核心！</p><p><strong>specially:</strong>$\vec{R}_{(t=0)}=\vec{R}(t=T)$即R(t)可以周期回归，则</p><script type="math/tex; mode=display">\gamma_{n}(t=T)=i \oint_{c} \langle n (\vec{R}) | \nabla_{R} n(\vec{R}) \rangle \cdot d \vec{R}</script><h1 id="引入——绝热条件"><a href="#引入——绝热条件" class="headerlink" title="引入——绝热条件"></a>引入——绝热条件</h1><p>现在不妨重新严格的解一遍。此时参考H不含时$|\psi(t)\rangle=\sum_{n}c_n(t)|n(t)\rangle$<br>对于$c_n (t)$可以将其设为,可以看出这种设法相当于是将$c_n (t)$以不同能量组成的时间演化算子展开。咕这种展开是不失一般性的。</p><script type="math/tex; mode=display">c_n(t)=a_n (t) \exp [-\frac{i}{n} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}]</script><p>带入Schrodinger方程中$i \hbar \frac{\partial}{\partial t} | \psi \rangle= H(t)|\psi\rangle$<br>则</p><script type="math/tex; mode=display">i \hbar \sum_{n}\left\{\dot{a}_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t\right]|n(t)\rangle\right.-\frac{i}{\hbar} a_{n}(t) E_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right] |n(t)\rangle</script><script type="math/tex; mode=display">\left.+a_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right] \frac{\partial}{\partial t}|n(t)\rangle\right\}=\sum_{n} a_n (t) E_{n}(t) \exp [-\frac{i}{\hbar} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}] |n(t)\rangle</script><p>化简后即为</p><script type="math/tex; mode=display">i \hbar \sum_{n}\left\{\dot{a}_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t\right]|n(t)\rangle\right.\left.+a_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right] \frac{\partial}{\partial t}|n(t)\rangle\right\}=0</script><p>操作：同时左乘$\langle l(t) |$，其中l为n中的一个本征态（即$\langle l(t) | n \rangle = \delta_{l n}$）。有</p><script type="math/tex; mode=display">i \hbar \left\{\dot{a}_{l} (t) \exp \left(-\frac{i}{\hbar} \int_{0}^{t} E_{l} (t^{\prime}) d t^{\prime}\right)\right\}+\sum_{n} a_{n}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}\right]\left\langle l(t)\left|\frac{\partial}{\partial t}\right| n(t)\right\rangle=0</script><p>则有</p><script type="math/tex; mode=display">\dot{a}_{n}(t)=-\sum_{i \neq n} a_{l}(t) \exp \left(\frac{i}{\hbar} \int_{0}^{t}\left[E_{n}\left(t^{\prime}\right)-E_{l}\left(t^{\prime}\right)\right] d t^{\prime}\right)\langle n | \dot{l} \rangle -a_{n}(t)\langle n / \dot{l}\rangle</script><p>此时若令出态为$|\psi_0\rangle=|m_0\rangle$。则可以单独提出 $l=m$ 的一项，为</p><script type="math/tex; mode=display">\dot{a}_{n}(t)= -a_{n}(t)\langle n / \dot{l}\rangle</script><script type="math/tex; mode=display">-a_{m}(t) \exp \left(\frac{i}{\hbar} \int_{0}^{t}\left[E_{n}\left(t^{\prime}\right)-E_{m}\left(t^{\prime}\right)\right] d t^{\prime}\right)\langle n | \dot{m} \rangle</script><script type="math/tex; mode=display">-\sum_{i \neq n or m} a_{l}(t) \exp \left(\frac{i}{\hbar} \int_{0}^{t}\left[E_{n}\left(t^{\prime}\right)-E_{l}\left(t^{\prime}\right)\right] d t^{\prime}\right)\langle n | \dot{l} \rangle</script><p>接下来做近似：对于这个近似我们希望可以使$\dot{a}_{n}(t)$很小，同时由$\sum_n \left|a_n (t)\right|^2 =1$<br>可知a（t）的图像为<br><img src="/img_QM2/2.png" srcset="/img/loading.gif" alt="势能如图"><br>我们可知，只需使$\langle n | \dot{m} \rangle$较小，既可以使a（t）小。具体逻辑链如图</p><p><img src="/img_QM2/3.png" srcset="/img/loading.gif" alt="势能如图"><br>其中箭头代表可以推出，而1、2、3则为$\dot{a}_{n}(t)$中的分项。<br>对$\langle n | \dot{m} \rangle$做无量纲化，则可以得到大名鼎鼎的绝热近似。</p><script type="math/tex; mode=display">\left |\frac{\langle n | \dot{m}\rangle}{\left(E_{m}-E_{n}\right)\hbar}\right | <<1</script><p>对于任意$n \neq m$都成立<br>接下来会给出绝热近似的另一种表述以及更深一步的讨论：</p><p>绝热近似也可以理解为$\dot{H}(t)$为小量，即：</p><script type="math/tex; mode=display">\left|\frac{\hbar \langle m|\dot{n}\rangle}{E_{n}-E_{m}}\right|=\frac{\hbar\langle m|\dot{H}| n\rangle}{\left(E_{n}-E_{m}\right)^{2}}<<1</script><p>证明如下：</p><p>由$H(t)|n(t)\rangle= E_{n}(t)|n(t)\rangle$，两边同时对t求导</p><script type="math/tex; mode=display">\left(\frac{\partial}{\partial t} H(t)\right)|n(t)\rangle+ H \frac{\partial}{\partial t}|n\rangle=\dot{E}_{n}(t)|n(t)\rangle+ E_{n}|\dot{n}(t)\rangle</script><p>内积：</p><script type="math/tex; mode=display">\left\langle m\left|\left(\frac{\partial}{\partial t} H(t)\right)\right| n(t)\right\rangle + {\langle m|H| \dot{n}\rangle}={\left\langle m\left|\dot{E}_{n}(t)\right| n\right\rangle}+\left\langle m\left|E_{n}\right| \dot{n}\right\rangle</script><p>其中${\langle m|H| \dot{n}\rangle}= E_m \langle m|\dot{n}\rangle$，由于$m \neq n$</p><p>${\left\langle m\left|\dot{E}_n (t)\right| n\right\rangle}=0$。<br>则有</p><script type="math/tex; mode=display">\langle m (t) |  \dot{n}(t) \rangle=\frac{\langle m(t)|\dot{H} (t) n(t)\rangle}{E_{n}(t)-E_{m} (t)}</script><p>Q.E.D</p><p>则由绝热近似可得：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{\dot{a}_{m}(t)=-a_{m}(t)\langle m|\dot{m}\rangle} \\ {\dot{a}_{n}(t)=0 \quad(n \neq m)}\end{array}\right.</script><p>咕</p><script type="math/tex; mode=display">a_{m}(t)=a_{m}(0) \exp \left[-\int_{0}^{t}\langle m (t')|\dot{m}(t')\rangle d t' \right]</script><p>若令</p><script type="math/tex; mode=display">i \gamma_m (t)= \left[-\int_{0}^{t}\langle m (t')|\dot{m} (t') \rangle d t' \right]</script><p>则$a_m (t)=a_m (0) \exp [i \gamma_m (t)]$</p><script type="math/tex; mode=display">|\psi(t)\rangle = \sum_{n} a_n (t) \exp [-\frac{i}{n} \int_{0}^{t} E_{n}(t^{\prime}) d t^{\prime}]|n(t)\rangle</script><script type="math/tex; mode=display">=a_{m}(t) \exp \left[-\frac{i}{\hbar} \int_{0}^{t} E_{m}\left(t^{\prime}\right) d t^{\prime}\right]|m(t)\rangle</script><script type="math/tex; mode=display">=e^{i[\alpha_{m}(t)+\gamma_{m}(t)]} |m(t)\rangle</script><p>其中</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{\alpha_{n}(t)=-\frac{1}{\hbar} \int_{0}^{t} E_{n}\left(t^{\prime}\right) d t^{\prime}} \\ {\gamma_{m}(t)=i \int_{0}^{t}\langle n | n\rangle d t'}\end{array}\right.</script><p>其中$\gamma_{m}(t)$为Barry phase</p><p>以上即为绝热近似与Barry phase的关系。接下来带入到一个例子中来看看具体的计算</p><h2 id="Example-spin-in-maginatic-fields"><a href="#Example-spin-in-maginatic-fields" class="headerlink" title="Example: spin in maginatic fields"></a>Example: spin in maginatic fields</h2><p>对于一个自旋系统，其哈密顿量为：</p><script type="math/tex; mode=display">H(\vec{B}(t))=  -\vec{\mu} \cdot \vec{B}(t)=-\vec{\mu} \vec{\sigma} \cdot \vec{B}(t)</script><script type="math/tex; mode=display">=-\vec{\mu} \left[\sigma_{x} B_{x}+\sigma_{y} B_{y}+\sigma_{z} B_{z}\right]</script><p>其中：$\vec{\sigma}$为Pauli矩阵；且set周期性磁场为$\vec{B}(t)=\left(B_1 \cos 2 w_0 t, B_1 \sin 2 w_1 t, B_0 \right)$<br>即当$t=T=\frac{\pi}{w_0}$时回归。</p><p>解方程:</p><script type="math/tex; mode=display">H(t)\left|\psi_{\pm}(t)\right\rangle= E_{1}(t)\left|\psi_{\pm}(t)\right\rangle</script><p>即解H的本征问题，其中</p><script type="math/tex; mode=display">H(t)= -\mu_{B}\left(B_x \left[\begin{array}{ll}{0} & {1} \\ {1} & {0}\end{array}\right] + B_y \left[\begin{array}{ll}{0} & {-i} \\ {i} & {0}\end{array}\right] +B_z \left[\begin{array}{ll}{1} & {0} \\ {0} & {-1}\end{array}\right]\right)</script><script type="math/tex; mode=display">=-\vec{\mu}_B \left[\begin{array}{cc}{B_{0}} & {B_{1} e^{-i 2 k t}} \\ {B_{1} e^{i 2 k_{k} t}} & {-B_{0}}\end{array}\right]</script><p>本征函数</p><script type="math/tex; mode=display">\left|\psi_{-}(t)\right\rangle=\left[\begin{array}{l}{\cos \frac{\theta}{2}} \\ {\sin \frac{\theta}{2} e^{-2 i w_{0} t}}\end{array}\right]</script><script type="math/tex; mode=display">\left|\psi_{+}(t)\right\rangle=\left[\begin{array}{l}{-\sin \frac{\theta}{2}} \\ {\cos \frac{\theta}{2} e^{\sin \alpha \cdot t}}\end{array}\right]</script><p>其中$\theta=\tan ^-1\left(\frac{B_1}{B_0}\right)$<br>其对应的本征值为</p><script type="math/tex; mode=display">E_{-}(t)=-\mu_{B} \sqrt{B_{0}^{2}+B_{1}^{2}}</script><script type="math/tex; mode=display">E_{+}(t)=\mu_{B} \sqrt{B_{0}^{2}+B_{1}^{2}}</script><p>现在来计算这个问题中的Barry phase<br>首先我们设</p><script type="math/tex; mode=display">|\psi(t)\rangle= e^{i\left[\alpha_n (t)+\gamma_n (t)\right]} |m(t)\rangle</script><p>其中设<script type="math/tex">|\psi(0)\rangle=\left|\psi_- (t=0)\right\rangle</script>为初始值</p><script type="math/tex; mode=display">\gamma_{n}(t)= i \int_{0}^{t}\left\langle\psi\left(t^{\prime}\right) | \dot{\psi} \left(t^{\prime}\right)\right\rangle d t^{\prime}</script><script type="math/tex; mode=display">= i \int_{0}^{t}\left[\cos \frac{\theta}{2}, \sin \frac{\theta}{2} e^{-2 i w_{0} t^{\prime}}\right]\left[\begin{array}{c}{0} \\ {-2 i w_{0} \sin \frac{\theta}{2} e^{-2 i w_{0} t^{\prime}}}\end{array}\right] \quad d t^{\prime}</script><script type="math/tex; mode=display">=-2 i \int_{0}^{t} i w_{0} \sin \frac{\theta}{2} d t^{\prime}</script><script type="math/tex; mode=display">=2 w_{0} t \sin ^{2}\left(\frac{\theta}{2}\right)</script><p>则态函数可表示为</p><script type="math/tex; mode=display">|\psi(t)\rangle= \exp [i \gamma(t)] \exp \left[-\frac{i}{\hbar} \int_{0}^{t} d t^{\prime} E_{-}\left(t^{\prime}\right)\right] |\psi_{-} (t)\rangle</script><script type="math/tex; mode=display">= \exp \left[i 2 w_{0} t \sin ^{2} \frac{\theta}{2}\right]\exp \left[-\frac{i}{\pi} \mu_{B} \sqrt{B_{0}^{2}+B_{1}^{2}} T\right] |\psi_{-} (t)\rangle</script><p>其中$T=\frac{\pi}{w_{0}}$为周期。</p><h1 id="Effective-fields-near-degenenacy（简并）-point"><a href="#Effective-fields-near-degenenacy（简并）-point" class="headerlink" title="Effective fields near degenenacy（简并） point"></a>Effective fields near degenenacy（简并） point</h1><p>我们可以考虑另一种Barry phase的表示形式：</p><script type="math/tex; mode=display">\gamma_{n}(c)=\oint_{c}  i\left\langle n\left(\vec{R}\right) | \nabla_{\vec{R}} n_{(\vec{R})}\right\rangle \cdot d \vec{R}</script><p><img src="/img_QM2/4.png" srcset="/img/loading.gif" alt="势能如图"><br>接下来先证明$\gamma_n (c)$为实数。<br>即，</p><script type="math/tex; mode=display">\langle n(\vec{R}) | \nabla_{\vec{R}} n_{(\vec{R})}\rangle</script><p>为虚数<br>$\Longrightarrow$  由$\nabla_R \cdot\langle n(\vec{R}) | n(\vec{R})\rangle= 0$，其中$\langle n(\vec{R}) | n(\vec{R})\rangle=1$<br>展开有$0=\langle\nabla_R n(\vec{R}) | n(\vec{R})\rangle + \langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle=(\langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle)^*+\langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle$</p><p>由此可知$\langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle$为虚数，则$\gamma_n (c)$为实数。</p><p>接下来我们将$\gamma_n (c)$改写$\Longrightarrow$ $\gamma_n (c)=-{Im}\left[\oint_c \left\langle n(\vec{R}) | \nabla_R  n(\vec{k})\right\rangle \cdot d \vec{R}\right]$<br>我们令$-{A_n}(\vec{R})   = i \langle n(\vec{R}) | \nabla_R n(\vec{R})\rangle$则有</p><script type="math/tex; mode=display">\gamma_n (c)=-\oint_c {A_n }(\vec{R}) \cdot d \vec{R}=-\iint_S [\vec{\nabla}_R  \times \vec{A}_n (\vec{R})] \cdot d \vec{S}</script><p>其中$-{A_n }(\vec{R})$称为磁矢势，所以我们有：$\gamma_n (c)=-\iint_S \vec{B}_n (\vec{R}) \cdot d \vec{S}$。我们可以称$\vec{B}_n (\vec{R})$为磁场也可以称为有效场，由此 $\gamma_n (c)$即为磁通量</p><p>我们来接着讨论这个磁场$\vec{B}_n$,首先可以写出磁场$\vec{B}_n$，这里第二给等号是因为对易</p><script type="math/tex; mode=display">\vec{B}_{n}(\vec{R})=\nabla_{R} \times {Im} \langle n(\vec{R}) | \nabla_{R} n(\vec{R})\rangle=Im \nabla_{\vec{R}} \times\langle n(\vec{R}) | \nabla_{R} n(\vec{R})\rangle</script><p>由此我们将$\vec{B}_{n}$写为</p><script type="math/tex; mode=display">\vec{B}_{n}(\vec{R})=I m \sum_{m \neq n} \frac{\langle n(\vec{R})|\nabla_{R} H| m(\vec{R})\rangle \times \langle m(\vec{R})|\nabla_{\vec{R}} H| n(R)\rangle.}{[E_{n}(\vec{R})-E_{m}(\vec{R})]^{2}}</script><p>在证明这个式子之前我们先来谈一谈这个式子的‘好处’：这个式子使原来对$| n(\vec{R})\rangle$的$\nabla_{R}$转化为对哈密顿量H（通常已知）的作用，这可以极大的简化计算\<br>$\Longrightarrow$  由</p><script type="math/tex; mode=display">\begin{aligned}\vec{B}_{n}(\vec{R}) &={Im}\left[\langle  \nabla_{R} n(\vec{R})|\times | \nabla_{R} n(\vec{R}) \rangle+\langle n(\vec{R}) |\nabla_{R} \times \nabla_{R} n(\vec{R}) \rangle\right]\\&=I m \left[\sum_{m \neq n}\langle\nabla_{R} n(\vec{R}) | m(\vec{R})\rangle \times \langle m(\vec{R})| \nabla_{R} n(\vec{R})\rangle +\langle\nabla_{R} n(\vec{R}) | n(\vec{R})\rangle \times \langle n(\vec{R})| \nabla_{R} n(\vec{R})\rangle\right]\end{aligned}</script><p>因为$\langle n(\vec{R}) | \nabla_{R} n(\vec{R})\rangle$为虚数故最后一项$=0$，由此B可改写为</p><script type="math/tex; mode=display">\begin{aligned}\left(B_{n}\right)_{i}&=I m\left[\varepsilon_{i j k}\left\langle\partial_{j} n | \partial_{k} n\right\rangle\right] =I m\left[\varepsilon_{i j k} \sum_{m}\langle \partial_{j} n | m\rangle\left\langle m | \partial_{k} n\right\rangle\right]\\&=I m\left[\varepsilon_{i j k} \sum_{m \neq n}\langle\partial_{j} n | m\rangle\langle m | \partial_{k} n\rangle+\langle\partial_{j} n | n\rangle\langle n | \partial_{k} n\rangle\right]\end{aligned}</script><p>最后一项</p><script type="math/tex; mode=display">=\epsilon_{ijk} \left\langle n | \partial_j  n\right\rangle\left\langle\partial_k n | n\right\rangle=\epsilon_{ijk} \left\langle n | \partial_k n\right\rangle\left\langle\partial_j n | n\right\rangle=0</script><p>则有</p><script type="math/tex; mode=display">\vec{B}_n (\vec{R})=I m \left[\sum_{m \neq n}\langle\nabla_R n(\vec{R}) | m(\vec{R})\rangle \times \langle m(\vec{R})| \nabla_R n(\vec{R})\rangle \right]</script><p>接下来我们只需证明：<script type="math/tex">\left\langle m | \nabla_{\vec{R}} n\right\rangle=\frac{\left\langle m| \nabla_{\vec{R}} H | n\right\rangle}{E_n -E_m }</script>即可</p><p>$\Longrightarrow$  由哈密顿量H的本征值$H|n\rangle=E_n |n\rangle$</p><p>两边同时作用$\nabla_R$，有$\left.\left(\nabla_R H\right)|n\rangle+H \nabla_R |n\rangle=\left(\nabla_R E_n \right)\left|n\rangle+E_n \nabla_R \right| n\right\rangle$</p><p>在同时乘上$\langle m|$，有</p><script type="math/tex; mode=display">\left\langle m\left|\nabla_R H\right| n\right\rangle+\left\langle m\left|H \nabla_{R}^{}\right| n\right\rangle=\left\langle m\left|\nabla_R E_n \right| n\right\rangle+\left\langle m\left|E_n \nabla_R \right| n\right\rangle</script><p>其中</p><script type="math/tex; mode=display">\left\langle m\left|H \nabla_{R}\right| n\right\rangle=E_{n}\left\langle m\left|\nabla_{\vec{R}}\right| n\right\rangle</script><p>而</p><script type="math/tex; mode=display">\langle m|\nabla_R E_n| n\rangle=\nabla_{\vec{R}} E_n \langle m | n\rangle=0</script><p>由此可以证明</p><p>接着我们来讨论一下这个问题下的能级问题，即当$E_n$与$E_m$相邻很近时，如图所示<br><img src="/img_QM2/5.png" srcset="/img/loading.gif" alt="势能如图"><br>其中$*$点代表我们讨论的点，$\cdot$代表$E_n=E_m$时的简并点</p><p>此时我们有：$E_n=E_m$</p><script type="math/tex; mode=display">\begin{aligned}&H(\vec{R}^*)|m(\vec{R}^{*})\rangle=E_{m}(\vec{R}^{*})|m(\vec{R}^{*})\rangle\\&H(\vec{R}^{*})|n(\vec{R}^{*})\rangle=E_{n}(\vec{R}^{*})|n(\vec{R}^{*})\rangle\end{aligned}</script><p>我们简化符号：$|n\rangle-&gt; |+\rangle\quad| m\rangle -&gt; |-\rangle$。则磁场B为</p><script type="math/tex; mode=display">\vec{B}_{n}(\vec{R})=I m  \frac{\langle +(\vec{R})|\nabla_{R} H| -(\vec{R})\rangle \times \langle -(\vec{R})|\nabla_{\vec{R}} H| +(R)\rangle.}{[E_{+}(\vec{R})-E_{-}(\vec{R})]^{2}}</script><p>哈密顿量的本征值也简并为</p><script type="math/tex; mode=display">\begin{aligned}H(\vec{R}^{*})|\pm(\vec{R}^{*})\rangle &=E_{\pm}\left|\pm\left(\vec{R}^{*}\right)\right\rangle \\&=E\left|\pm\left(\vec{R}^{*}\right)\right\rangle\end{aligned}</script><p>使用$|\pm\rangle$为基展开H，有</p><script type="math/tex; mode=display">H(\vec{R})=\left[\begin{array}{ll}H_{11}(\vec{R}) & H_{12}(\vec{R}) \\H_{21}(\vec{R}) & H_{22}(\vec{R})\end{array}\right]</script><p>特殊的</p><script type="math/tex; mode=display">H(\vec{R}^{*})=\left[\begin{array}{ll}E(\vec{R}^{*}) & 0 \\0 & E(\vec{R}^{*})\end{array}\right]</script><p>其中$E(\vec{R}^*)$为常数，经过适当调整可使其为</p><script type="math/tex; mode=display">H\left(\vec{R}^* \right)=0</script><p>同时我们也可以使用泡利矩阵$\sigma$展开：</p><script type="math/tex; mode=display">H(\vec{R})=\vec{\sigma} \cdot \vec{R} \pm \vec{\sigma}_0 \cdot \vec{R^* }</script><p>其中$\sigma_0$为常数使得</p><script type="math/tex; mode=display">H\left(\vec{R}^* \right)=0</script><p>当我们令$R=(x,y,z)$时</p><script type="math/tex; mode=display">H(\vec{R})=\left[\begin{array}{cc}z & x-i y \\x+i y & z\end{array}\right]</script><p>解其本征值有</p><script type="math/tex; mode=display">E_+ (\vec{R})=-E_- (\vec{R})=R</script><p>由泡利矩阵的展开表示我们有$\nabla_R (H(\vec{R}))=\vec{\sigma}$，带入到磁场B的计算中有：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}B_{+ x}=Im\left[  \frac{\langle+|\sigma_{y}|-\rangle \times \langle-|\sigma_{z}|+\rangle}{2 R^{2}} \right]=0 \\B_{+ y}=Im\left[  \frac{\langle+|\sigma_{z}|-\rangle \times \langle-|\sigma_{x}|+\rangle}{2 R^{2}} \right]=0 \\B_{+ z}=Im\left[  \frac{\langle+|\sigma_{x}|-\rangle \times \langle-|\sigma_{y}|+\rangle}{2 R^{2}} \right]=\frac{1}{2 R^{2}}\end{array}\right.</script><p>即，磁极单子</p><script type="math/tex; mode=display">\vec{B}_+ (\vec{R})=\frac{\vec{R}}{2 R^3 }</script><p>由此</p><script type="math/tex; mode=display">\gamma_+ (c)=-\gamma_{-}(c)=-\iint_{S}[\vec{B}_{+}(\vec{R})] \cdot d \vec{S}=-\iint_{S}[\frac{\vec{R}}{2 R^{3}}] \cdot d \vec{S}=-\frac{1}{2} \Omega(c)</script><p>可以用立体角来表示磁通，如图所示</p><p><img src="/img_QM2/6.png" srcset="/img/loading.gif" alt="势能如图"></p><p>即磁通对应闭合曲线C在R空间中的立体角</p><h1 id="Aharanov-Anandan-Phases"><a href="#Aharanov-Anandan-Phases" class="headerlink" title="Aharanov-Anandan Phases"></a>Aharanov-Anandan Phases</h1><p>当态随着时间周期性演化时：</p><script type="math/tex; mode=display">|\psi(T)\rangle=\exp \left[i \gamma_{n}(T)\right] \exp \left[i \alpha_{n}(T)\right] | \psi(0)\rangle</script><p>其中T为周期，</p><script type="math/tex; mode=display">\alpha_n (T)=-\frac{1}{\hbar} \int_{0}^{T} E_n \left(t^{\prime}\right) d t^{\prime}</script><p>接下我们看到如果我们将$|\psi(T)\rangle$改写为$|\psi(T)\rangle=e^{i \phi} | \psi(0)\rangle$，则我们可以看到$\phi \neq \alpha$<br>在这里我们重新定义$\alpha(T)$为</p><script type="math/tex; mode=display">\alpha(T)=-\frac{1}{\hbar} \int_{0}^{t} d t<\psi(t)|H(t)| \psi(t)\rangle</script><p>在证明$\phi \neq \alpha$之前我们需要先说明一下当$H(t)=H$即不含时且在同一个态上演化时$\phi = \alpha$<br>$\Longrightarrow$ 由薛定谔方程：$i \hbar \frac{\partial}{\partial E} |\psi(t) \rangle=H(t)|\psi(t)\rangle$，其中H可以含时也可以不随时间变化<br>我们令$|\tilde{\psi}(t)\rangle=e^{-i f(t)}|\psi(t)\rangle \quad f(T)-f(0)=\phi$则经过应该周期后$|\tilde{\psi}(T)\rangle=|\tilde{\psi}(0)\rangle$。带入到薛定谔方程中</p><script type="math/tex; mode=display">H(t)|\psi(t)\rangle=i \hbar \frac{\partial}{\partial t}\left[e^{-i f(t)} | \tilde{\psi}(t)\right]=-\hbar \dot{f}(t)|\psi(t)\rangle+i \hbar e^{i f(t)} \frac{\partial}{\partial t}|\tilde{\psi}(t)\rangle</script><p>两边同时作用$\langle\psi(t)|$</p><script type="math/tex; mode=display">-\hbar \dot{f}(t)+i \hbar \langle \psi(t)|e^{i f(t)} \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle=\langle\psi(t)|H(t)| \psi(t)\rangle</script><script type="math/tex; mode=display">\hbar \dot{f}(t)=\langle\tilde{\psi}(t)|i \hbar \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle-\langle\psi(t)|H(t)| \psi(t)\rangle</script><p>两边作用积分$\int_{0}^{T} d t$</p><script type="math/tex; mode=display">\hbar[f(T)-f(0)]=\int_{0}^{T} d t\langle\tilde{\psi}(t)|i \hbar \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle+\hbar \alpha</script><p>其中$f(T)-f(0)=\phi$而</p><script type="math/tex; mode=display">\int_{0}^{T} d t\langle\tilde{\psi}(t)|i \hbar \frac{\partial}{\partial t}| \tilde{\psi}(t)\rangle=\hbar \gamma</script><p>由此$\phi \neq \alpha$</p><p>Example:</p><script type="math/tex; mode=display">H(t)=H \quad H|\psi_{\pm}\rangle=E_{\pm}| \psi_{\pm}\rangle\quad|\psi(0)\rangle=\cos \frac{\theta}{2}|\psi_{-} \rangle+\sin \frac{\theta}{2}| \psi_{+}\rangle</script><p>$\Longrightarrow$ </p><script type="math/tex; mode=display">\begin{aligned}|\psi(t)\rangle &=e^{-i E_{-}t / \hbar} \cos \frac{\theta}{2} \beta|\psi_{-} \rangle + e^{-i E_{+} t / \hbar} \sin \frac{\theta}{2}| \psi_{+} \rangle \\&=e^{-i E_{-}t / \hbar}[\cos \frac{\theta}{2} |\psi_{-} \rangle + e^{-i(E_{+} - E_{-}) t / \hbar} \sin \frac{\theta}{2} | \psi_{+}\rangle]\end{aligned}</script><p>当我们令</p><script type="math/tex; mode=display">T {\longrightarrow}(E_{ + }-E_{ - }) T/ \hbar=2 \pi</script><p>我们有</p><script type="math/tex; mode=display">|\psi(T)\rangle=e^{-i E_- T / t}|\psi(0)\rangle</script><p>由此有$\phi=E_{ - } T / t$</p><script type="math/tex; mode=display">\begin{aligned}\alpha(T) &=-\frac{1}{\hbar} \int_{0}^{t} d t\langle\psi(t)|H(t)| \psi(t)\rangle \\ &=-\frac{1}{\hbar} \int_{0}^{T} d t\left[\cos \frac{\theta}{2}\langle\psi_{-}|+e^{-i(E_{+}-E_{-}) t / \hbar} \sin \frac{\theta}{2}\langle\psi_{+}|\right]\left[\cos \frac{\theta}{2} \theta|\psi \rangle + e^{-i(E_{+} -E_{-}) t / \hbar} \sin \frac{\theta}{2}| \psi_{+}\rangle\right]\\ &=-\frac{1}{\hbar}[E_{-}T\cos ^{2} \frac{\theta}{2}+E_{+}T \sin \frac{\theta}{2}]\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">\begin{aligned}\gamma(T)&=\phi-\alpha(T)=\frac{-E_{-} \hbar}{\hbar}+\frac{1}{\hbar}[E_{-}T\cos ^{2} \frac{\theta}{2}+E_{+}T \sin \frac{\theta}{2}]\\&=\frac{1}{\hbar}\left[E_{+} -E_{-}\right] T \frac{1-\cos \theta}{2}=\left\{\begin{array}{ll} 0 & \theta=0 \\ 2 \pi & \theta=\pi \end{array}\right.\end{aligned}</script><h1 id="Gauge-invariance-of-QM"><a href="#Gauge-invariance-of-QM" class="headerlink" title="Gauge invariance of QM"></a>Gauge invariance of QM</h1><p>在电磁学中有</p><script type="math/tex; mode=display">\vec{E}=-\nabla V-\frac{1}{c} \frac{\partial \vec{A}}{\partial t} \quad \vec{B}=\nabla \times \vec{A}</script><p>我们引入了规范</p><script type="math/tex; mode=display">V \rightarrow V+\frac{1}{c} \frac{\partial}{\partial t} X \quad \vec{A} \rightarrow \vec{A}+\nabla X</script><p>其中X为Gauge，当X变化时E，B并不随规范变化。</p><p>在QM中我们也会运用到规范，尤其时薛定谔方程$\left[\frac{p^2}{2 m}+V(\vec{r}, t)\right] \psi(r, t)=i \hbar \frac{\partial}{\partial t} \psi$中的哈密顿量含时时我们需要引入磁场B，即改写<br>动量P为</p><script type="math/tex; mode=display">{\vec{p}}^{\prime}\rightarrow \vec{p}-\frac{q \vec{A}}{c}</script><p>其中我们称$ \vec{p}$为Canonical momentum，$\vec{p}^{\prime}$为Kinematic momentum<br>由此我们可以得到薛定谔电磁学绘景</p><script type="math/tex; mode=display">\left[\frac{1}{2 m}\left(\vec{p}-\frac{q \vec{A}}{c}\right)^{2}+V(r, t)\right] \psi(r, t)=i \hbar \frac{\partial}{\partial t} \psi</script><p>此时我们若令</p><script type="math/tex; mode=display">V^{\prime} =V+\frac{1}{c} \frac{\partial}{\partial t} X \quad \vec{A}^{\prime} = \vec{A}+\nabla X</script><p>则有</p><script type="math/tex; mode=display">\left[\frac{1}{2 m}\left(\vec{p}-\frac{q \vec{A}^{\prime}}{c}\right)^{2}+V^{\prime}(r, t)\right] \psi^{\prime}(r, t)=i \hbar \frac{\partial}{\partial t} \psi^{\prime}</script><p>之后我们就可以得到$\psi^{\prime}=e^{i q X / \hbar c} \psi$。我们将规范带入即可证明。</p><h1 id="Phase-due-to-scalar-potential-V-t-and-vector-potential-vec-A-R"><a href="#Phase-due-to-scalar-potential-V-t-and-vector-potential-vec-A-R" class="headerlink" title="Phase due to scalar potential $V(t)$ and vector potential $\vec{A}(R)$"></a>Phase due to scalar potential $V(t)$ and vector potential $\vec{A}(R)$</h1><p>在上一节我们已经意识到当我们改变哈密顿量H的方法不同时会得到不一样的随时间演化的态\<br>这一节我们来讨论方程</p><script type="math/tex; mode=display">i \hbar \frac{\partial}{\partial t} \psi_{0}(\vec{r}, t)=H_{0}(t) \psi_{0}(\vec{r}, t)</script><ul><li>$H(t)=H_0 (t)+V(t)$：当我们给哈密顿量加上随时间变换是标量势时则<script type="math/tex; mode=display">i \hbar \frac{\partial}{\partial t} \psi(\vec{r}, t)=H(t) \psi(\vec{r}, t)</script>此时态演化为<script type="math/tex; mode=display">\psi(\vec{r}, t)=\psi_{0}(\vec{r}, t) e^{-i \int_{t_{0}}^{t} V(t^{\prime}) d t^{\prime}}=\psi_{0}(\vec{r}, t) e^{-i S(t) / \hbar}</script>其中$S(t)=\int_{t_0}^t V\left(t^{\prime}\right) d t^{\prime}$</li></ul><ul><li>$H_{0}(t)\stackrel{+\vec{A}}{\longrightarrow}H(t)$：当我们给哈密顿量加上随时间变换是矢势时有<script type="math/tex; mode=display">\psi(\vec{r}, t)=\psi_{0}(\vec{r}, t) e^{-i \frac{q}{c}\int_{\vec{r}_{0}}^{\vec{r}} \vec{A}(\vec{r}^{\prime}) d \vec{r}^{\prime}}</script> 接下来我们来证明一下这个式子<br> $\Longrightarrow$ <script type="math/tex; mode=display">\begin{aligned}\vec{p} e^{-i \frac{s}{\hbar}} &=e^{-i \frac{s}{\hbar}}(-i \hbar) \nabla\left(-i \frac{s}{\hbar}\right) \\&=\exp \left(-i \frac{s}{\hbar}\right)(-)\left(-\frac{\hbar}{c}\right) \nabla \int^{\vec{r}}_{\vec{r}_{0}} \vec{A}(\vec{r}^{\prime}) d \vec{r} ^{\prime}\\ &=\exp \left(-i \frac{s}{\hbar}\right) \frac{q}{c} \vec{A}(\vec{r})\end{aligned}</script> 由此<script type="math/tex; mode=display">\left[\vec{p}-\frac{q}{c} \vec{A}(r)\right] f(\vec{r}, t) e^{-i  S / \hbar}=</script><script type="math/tex; mode=display">[\vec{p} f(\vec{r}, t)] e^{-i {S}/{\hbar}}+f(\vec{r}, t)\left(\vec{p} e^{-i S / \hbar}\right)-\frac{q}{c} \vec{A} (\vec{r})  f(\vec{r}, t) e^{-i S / \hbar}=(\vec{p} f(\vec{r}, t)) e^{-i S / \hbar}</script> 因此有<script type="math/tex; mode=display">\frac{1}{2 m}\left[\vec{p}-\frac{q}{c} \vec{A}(\vec{r})\right]^{2} \psi_{0}(\vec{r}, t) e^{-i S/ \hbar}=\frac{1}{2 m}\left[p^{2} \psi_{0}(\vec{r}, t)\right] e^{-i S / \hbar}</script> 带入到方程中可以验证得到<br>综上所述，在H随时间变化的一般情况下我们有<script type="math/tex; mode=display">H(t) \sim \psi(\vec{r}, t)=\psi_{0}(\vec{v}, t) e^{-i S / \hbar}</script>其中<script type="math/tex; mode=display">S(\vec{r}, t)={- \frac{q}{c}\int_{\vec{r}_{0}}^{\vec{r}} \vec{A}(\vec{r}^{\prime}) d \vec{r}^{\prime}}+\int_{t_{0}}^{t} V\left(t^{\prime}\right) d t^{\prime}</script></li></ul><h1 id="AB-effect-1959"><a href="#AB-effect-1959" class="headerlink" title="AB effect(1959)"></a>AB effect(1959)</h1><p>如图<br><img src="/img_QM2/7.png" srcset="/img/loading.gif" alt="势能如图"></p><script type="math/tex; mode=display">\int_{\vec{r}_{0}}^{\vec{r}} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)+\int_{\vec{r}}^{\vec{r}_0} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)=\oint d r^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)=\iint_S d s^{\prime} \vec{B}\left(\vec{r}^{\prime}\right)={\Phi}</script><p>其中$\Phi$为磁通，当$\Phi\ne 0$时</p><script type="math/tex; mode=display">\int_{\vec{r}_{0}}^{\vec{r}} d \vec{r}^{\prime} \vec{A}(\vec{r}^{\prime}) \ne  \int_{\vec{r}}^{\vec{r}_0} d \vec{r}^{\prime} \vec{A}(\vec{r}^{\prime}</script><p>这一条式子是可以实验测量得到的。其意义在于$\vec{A}(\vec{r})$在量子力学中是可以观测的！</p><p>实验——<br><img src="/img_QM2/8.png" srcset="/img/loading.gif" alt="实验示意图"><br>实验使用中子束，这样中间的磁场不会对其波函数产生作用。</p><ul><li><p>$B=0$<br> 初始波函数分为$\psi_0 (\vec{r}, t) \sim \psi_1 (\vec{r}, t)+\psi_2 (\vec{r}, t)$为相干的，此时他们只会分别沿着$p_1$与$p_2$走</p><ul><li>在A-B-D路线中<script type="math/tex; mode=display">\left|\psi_{2}(\vec{r}, t)\right|\ll \left|\psi_{1}(\vec{r}, t)\right|</script></li><li>在A-C-D路线中<script type="math/tex; mode=display">\left|\psi_{1}(\vec{r}, t)\right|\ll \left|\psi_{2}(\vec{r}, t)\right|</script></li></ul></li><li><p>$B \ne 0$</p><script type="math/tex; mode=display">\psi(\vec{r}, t) =exp[\frac{iq}{\hbar c}\int_{p_1} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)]\psi_{1}(\vec{r}, t)+exp[\frac{iq}{\hbar c}\int_{p_2} d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)]\psi_{2}(\vec{r}, t)</script><p> 所以</p><script type="math/tex; mode=display">\begin{aligned}\psi(\vec{r}, t) &=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)exp[\frac{iq}{\hbar c}(\int_{p_1}-\int_{p_2}) d \vec{r}^{\prime} \vec{A}\left(\vec{r}^{\prime}\right)]\\&=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)e^{\frac{i q}{\hbar c}\Phi}\end{aligned}</script><p> 因此</p><script type="math/tex; mode=display">|\psi(\vec{r}, t)|^{2}=\left|\psi_{1}\right|^{2}+\left|\psi_{2}\right|^{2}+2\left|\psi_{1}\psi_{2}\right| \cos \left[\varphi_{1}(\vec{r}, t)-\varphi_{2}(\vec{r},t)+\frac{q \Psi}{\hbar c}\right]</script><p> 其中$\varphi_1$与$\varphi_2$为初始相位<br> 此时我们测量粒子到达D点概率，可以发现一个相移，且这个相移的大小与中间的磁通量有关。</p></li></ul><h1 id="Electric-potential-AB-effect"><a href="#Electric-potential-AB-effect" class="headerlink" title="Electric potential AB effect"></a>Electric potential AB effect</h1><p>上一节的实验验证了磁势A对态的影响，接下来验证V对态的影响就显得十分顺其自然了<br><img src="/img_QM2/9.png" srcset="/img/loading.gif" alt="实验示意图"><br>在改实验设想中</p><script type="math/tex; mode=display">\begin{aligned}\psi(\vec{r}, t) &=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)exp\left[i[(\int_{p_1}-\int_{p_2}) d t^{\prime} V(t^{\prime})]/\hbar\right]\\&=\psi_{1}(\vec{r}, t)+   \psi_{2}(\vec{r}, t)e^{-i \Delta V \tau /\hbar}\end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\int_{p_1}V\left(t^{\prime}\right) d t^{\prime}=V_2 \tau \qquad \int_{p_2}V\left(t^{\prime}\right) d t^{\prime}=V_2 \tau</script><p>$V_1$为$p_1$路径上的电压，$V_2$为$p_2$路径上的电压而$\tau$为粒子通过电压区域的时间。<br>同上节的讨论，我们测量粒子到达终点的概率时可以发现一个大小与$\Delta V$有关的相移。</p><h1 id="Scalar-AB-experiment-1992"><a href="#Scalar-AB-experiment-1992" class="headerlink" title="Scalar AB experiment(1992)"></a>Scalar AB experiment(1992)</h1><p>上一节的实验在1992年实现了<br><img src="/img_QM2/10.png" srcset="/img/loading.gif" alt="实验示意图"><br>这个实验利用$V=-\vec{\mu} \vec{B}=-\mu_B \vec{\sigma}\vec{B}$来给粒子加上标势</p><p>最终粒子概率的相位变化为</p><script type="math/tex; mode=display">\Delta \phi=\Delta V \tau / \hbar=\frac{\sigma}{\hbar} \mu_B B \tau</script><p>其中$\sigma$为常数可以取$\pm 1$</p><h1 id="Gravitationally-induced-phase-1975"><a href="#Gravitationally-induced-phase-1975" class="headerlink" title="Gravitationally induced phase(1975)"></a>Gravitationally induced phase(1975)</h1><p>不光是电势，引力势能也是标势，也有人用引力势来做了相关实验<br><img src="/img_QM2/11.png" srcset="/img/loading.gif" alt="实验示意图"><br>这个实验中势能的变化为</p><script type="math/tex; mode=display">\Delta V=m g l_{2} \sin \alpha</script><p>其中$\alpha$为实验平面ABCD的仰角<br><img src="/img_QM2/12.png" srcset="/img/loading.gif" alt="实验示意图"><br>由此可知</p><script type="math/tex; mode=display">\Delta \phi=\frac{\Delta V \cdot T}{\hbar}=\frac{m g l_{2} \sin \alpha T}{\hbar}</script><p><img src="/img_QM2/13.png" srcset="/img/loading.gif" alt="实验示意图"><br>最后可以发现随着$\alpha$的变化相移会震荡</p>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quantum Optics -- Quantization of electromagnetic fields</title>
    <link href="/2020/05/30/Quantumoptics/"/>
    <url>/2020/05/30/Quantumoptics/</url>
    
    <content type="html"><![CDATA[<h1 id="遇事不决，量子力学！"><a href="#遇事不决，量子力学！" class="headerlink" title="遇事不决，量子力学！"></a>遇事不决，量子力学！</h1><p>通过电动力学中我们可以列出自由电磁场中的Maxwell方程</p><script type="math/tex; mode=display">\begin{aligned} \nabla \cdot {B} &=0 \\ \nabla \times {E} &=-\frac{\partial {B}}{\partial t} \\\nabla \cdot {D} &=0 \\ \nabla \times {H} &=\frac{\partial{D}}{\partial t} \end{aligned}</script><p>其中E和B都可以使用矢势 $A(\boldsymbol{r}, t)$ 表示：$\begin{aligned} &amp;\boldsymbol{B}=\nabla \times \boldsymbol{A}\ &amp;\boldsymbol{E}=-\frac{\partial \boldsymbol{A}}{\partial t} \end{aligned}$<br>   我们在这里取库伦规范 $\nabla \cdot \boldsymbol{A}=0$</p><p>正如我们在电动力学中做过无数遍的化简：上述Maxwell方程组可以化简为关于 $A(\boldsymbol{r}, t)$的波动方程：</p><script type="math/tex; mode=display">\nabla^{2} \boldsymbol{A}(\boldsymbol{r}, t)=\frac{1}{c^{2}} \frac{\partial^{2} \boldsymbol{A}(\boldsymbol{r}, t)}{\partial t^{2}}</script><p>而这个方程具有行波解的形式 </p><script type="math/tex; mode=display">\boldsymbol{A}(\boldsymbol{r}, t)=\boldsymbol{A}^{(+)}(\boldsymbol{r}, t)+\boldsymbol{A}^{(-)}(\boldsymbol{r}, t)</script><p>其中 ${A}^{(-)}=\left({A}^{(+)}\right)^* $互为复共轭</p><p>接下来我们可使用一组正交基对 $A^{(+)}(r, t)$ 经行展开 </p><script type="math/tex; mode=display">{A}^{(+)}({r}, t)=\sum_{k} c_{k} {u}_{k}({r}) {e}^{-i \omega_{k} t}</script><p>其中正交基为 $u_k (r)$ 满足：</p><ul><li>方程： <script type="math/tex; mode=display">\left(\nabla^{2}+\frac{\omega_{k}^{2}}{c^{2}}\right) {u}_{k}({r})=0</script></li><li>规范：<script type="math/tex; mode=display">\nabla \cdot {u}_{k}({r})=0</script></li><li>正交归一性：<script type="math/tex; mode=display">\int_{V} {u}_{k}^{*}({r}) {u}_{k^{\prime}}({r}) {d} {r}=\delta_{k k^{\prime}}</script></li></ul><p>由上述几个条件可以解出基的值（这同我们在解波导问题很相近）</p><script type="math/tex; mode=display">{u}_{k}(\boldsymbol{r})=L^{-3 / 2} \hat{\boldsymbol{e}}^{(\lambda)} \exp (\boldsymbol{i} \boldsymbol{k} \cdot \boldsymbol{r})</script><p>其中 $\hat{e}^{(\lambda)}$表偏振方向的选择。之后讨论同波导中解法，有：</p><script type="math/tex; mode=display">k_{x}=\frac{2 \pi n_{x}}{L}, \quad k_{y}=\frac{2 \pi n_{y}}{L}, \quad k_{z}=\frac{2 \pi n_{z}}{L}, \quad n_{x}, n_{y}, n_{z}=0, \pm 1, \pm 2, \ldots</script><p>可以观察到$u_k (r)$满足的方程与量子力学中谐振子满足的方程是相似的，这也亦为之我们可以使用谐振子的代数解法来解决$u_k (r)$的问题。经过计算可得：</p><script type="math/tex; mode=display">\boldsymbol{A}(\boldsymbol{r}, t)=\sum_{k}\left(\frac{\hbar}{2 \omega_{k} \epsilon_{0}} \cdot\right)^{1 / 2}\left[a_{k} \boldsymbol{u}_{k}(\boldsymbol{r}) {e}^{-i \omega_{k} t}+a_{k}^{\dagger} \boldsymbol{u}_{k}^{*}(\boldsymbol{r}) {e}^{i \omega_{k} t}\right]</script><p>则，与之对应的电场为：</p><script type="math/tex; mode=display">\boldsymbol{E}(\boldsymbol{r}, t)=i \sum_{k}\left(\frac{\hbar \omega_{k}}{2 \epsilon_{0}}\right)^{1 / 2}\left[a_{k} \boldsymbol{u}_{k}(\boldsymbol{r}){e}^{-i \omega_{k} t}-a_{k}^{\dagger} \boldsymbol{u}_{k}^{*}(\boldsymbol{r}) {e}^{i \omega_{k} t}\right]</script><p>这里的 $a_{k}^{\dagger}$ 与$a_k$ 即为光场中的升降阶算符，其中$k$为标记不同光场的脚标。满足对易关系：</p><script type="math/tex; mode=display">\left[a_{k}, a_{k^{\prime}}\right]=\left[a_{k}^{\dagger}, a_{k^{\prime}}^{\dagger}\right]=0, \quad\left[a_{k}, a_{k^{\prime}}^{\dagger}\right]=\delta_{k k^{\prime}}</script><p>在电磁学中电磁场的Hamiltonian为 $H=\frac{1}{2} \int\left(\epsilon_0 {E}^2+\mu_0 {H}^2 \right) {d} {r}$<br>带入计算得到的E有（这里两算符相乘要注意满足的对易关系）</p><script type="math/tex; mode=display">H=\sum_{k} \hbar \omega_{k}\left(a_{k}^{\dagger} a_{k}+\frac{1}{2}\right)</script><p>这里就可以得到量子化的电磁场。<br>remark：因为 $N=a_{k}^{\dagger}a_k$ 代表的是光子数所以可以发现在$n=0$（即真空态）时也会有 $\frac{1}{2} \hbar \omega_k$ 的能量。<br>这就可以有很多新奇的现象，比如<a href="https://zhuanlan.zhihu.com/p/32439577" target="_blank" rel="noopener">蔡老师的一篇文章</a>。挖坑：有时间我也试着去调研，并使用matlab复现一下论文中的一些结论。</p><h1 id="Fock态或粒子数态（fock老是拼错为fork，英语渣渣）"><a href="#Fock态或粒子数态（fock老是拼错为fork，英语渣渣）" class="headerlink" title="Fock态或粒子数态（fock老是拼错为fork，英语渣渣）"></a>Fock态或粒子数态（fock老是拼错为fork，英语渣渣）</h1><p>这就是一般最常见的表示的态，由于Hamiltonian具有 $h \omega_k (n_k +\frac{1}{2})$ 的本征值，其中$n_k$自然数。则一种自然的想法就是用 $|n_k \rangle$ 来表示H的本征态。</p><p>我们就称这个态为Fock态或者是粒子数态。其中$N=a_{k}^{\dagger} a_k$为粒子数算符</p><script type="math/tex; mode=display">a_{k}^{\dagger} a_{k}\left|n_{k}\right\rangle= n_{k}\left|n_{k}\right\rangle</script><p>将$a_{k}^{\dagger} $与$a_k$作用到$\left|n_k\right\rangle$上有</p><script type="math/tex; mode=display">a_{k}\left|n_{k}\right\rangle= n_{k}^{1 / 2}\left|n_{k}-1\right\rangle, \quad a_{k}^{\dagger}\left|n_{k}\right\rangle=\left(n_{k}+1\right)^{1 / 2}\left|n_{k}+1\right\rangle</script><p>特别的对于基态 $a_k |0\rangle= 0$ ，这也很好的反应出为什么叫升降阶算符。对任意一个态$|n_k \rangle$有</p><script type="math/tex; mode=display">\left|n_{k}\right\rangle=\frac{\left(a_{k}^{\dagger}\right)^{n_{k}}}{\left(n_{k} !\right)^{1 / 2}}|0\rangle, \quad n_{k}=0,1,2\ldots</script><p>这很明显可以得到：</p><ul><li>正交归一性： <script type="math/tex; mode=display">\left\langle n_{k} | m_{k}\right\rangle=\delta_{m n}</script></li><li>完备性：   <script type="math/tex; mode=display">\sum_{n_{k}=0}^{\infty}\left|n_{k}\right\rangle\left\langle n_{k}\right|=1</script>remark：fock态是最常见的一种表示方法，同时也是最直观的。往后的一些描述最好可以有直观的描述，这有助于理解。</li></ul><h1 id="相干态"><a href="#相干态" class="headerlink" title="相干态"></a>相干态</h1><p>对于相干光其光子数是不确定的，但是其满足不确定性原理的下限。为了描述这种相干光，我们需要引入相干态，而只需要简单的对 $\left|n_{k}\right\rangle$ 作幺正变化即可。</p><p>$D(\alpha)=\exp \left(\alpha a^{\dagger}-\alpha^{*} a\right)$ 其中 $\alpha$为任意的一个复数。<br>引理1：<br>   当 $[A,[A, B]]=[B,[A, B]]=0$ 时有 $\mathrm{e}^{A+B}=\mathrm{e}^{A} \mathrm{e}^{B} \mathrm{e}^{-[A, B] / 2}$ </p><p>化简得到 $D(\alpha)=\mathrm{e}^{-|\alpha|^{2} / 2} \mathrm{e}^{\alpha a^{\dagger}} \mathrm{e}^{-\alpha^{*} a}$ ，进而研究 $D(\alpha)$ 的性质：</p><ul><li><script type="math/tex; mode=display">D^{\dagger}(\alpha)=D^{-1}(\alpha)=D(-\alpha)</script></li><li><script type="math/tex; mode=display">D^{\dagger}(\alpha) a D(\alpha)=a+\alpha</script></li><li><script type="math/tex; mode=display">D^{\dagger}(\alpha) a^{\dagger} D(\alpha)=a^{\dagger}+\alpha^{*}</script></li><li><script type="math/tex; mode=display">D(\alpha+\beta)=D(\alpha) D(\beta) \exp \left(-\mathrm{i} \operatorname{Im}\left\{\alpha \beta^{*}\right\}\right)</script></li></ul><p>故，相干态 $|\alpha\rangle |\alpha\rangle$ 可由$D(\alpha)$作用在基态上产生： $|\alpha\rangle= D(\alpha)|0\rangle $，z<br>同时可得$|\alpha\rangle$为算符$a$的本征态， $a|\alpha\rangle=\alpha|\alpha\rangle$。</p><p>证明过程： $D^{\dagger}(\alpha) a|\alpha\rangle= D^{\dagger}(\alpha) a D(\alpha)|0\rangle=(a+\alpha)|0\rangle=\alpha|0\rangle$ ，之后俩边在同时乘 $D(\alpha)$。这里因为$a$为非厄米算符，所以$\alpha$ 为复数。<br>在 $a|\alpha\rangle=\alpha|\alpha\rangle$ 两边同时乘上 $\langle n|$ 有 $(n+1)^{1 / 2}\langle n+1 | \alpha\rangle=\alpha\langle n | \alpha\rangle $<br>即 </p><script type="math/tex; mode=display">\langle n | \alpha\rangle=\frac{\alpha^{n}}{(n !)^{1 / 2}}\langle 0 | \alpha\rangle</script><p>所以$|\alpha\rangle$可以表示为 $|\alpha\rangle=\sum|n\rangle\langle n | \alpha\rangle=\langle 0 | \alpha\rangle \sum_{n} \frac{\alpha^{n}}{(n !)^{1 / 2}}|n\rangle$<br>又因为通过计算有： </p><script type="math/tex; mode=display">\langle 0 | \alpha\rangle= e^{-|\alpha|^{2} / 2}</script><p>则</p><script type="math/tex; mode=display">|\alpha\rangle=\mathrm{e}^{-|\alpha|^{2} / 2} \sum \frac{\alpha^{n}}{(n !)^{1 / 2}}|n\rangle</script><p>光子数分布为： </p><script type="math/tex; mode=display">P(n)=|\langle n | \alpha\rangle|^{2}=\frac{|\alpha|^{2 n} \mathrm{e}^{-|\alpha|^{2}}}{n !}</script><p>其中平均光子数为 </p><script type="math/tex; mode=display">\bar{n}=\left\langle\alpha\left|a^{\dagger} a\right| \alpha\right\rangle=|\alpha|^{2}</script><ul><li>对于两个相干态来说有： <script type="math/tex; mode=display">\langle\beta | \alpha\rangle=\left\langle 0\left|D^{\dagger}(\beta) D(\alpha)\right| 0\right\rangle =\exp \left[-\frac{1}{2}\left(|\alpha|^{2}+|\beta|^{2}\right)+\alpha \beta^{*}\right]</script> 则 $|\langle\beta | \alpha\rangle|^{2}=\mathrm{e}^{-|\alpha-\beta|^{2}}$ 当 $|\alpha-\beta| \gg 1$ 时两个相干态 $|\alpha\rangle$ 与 $|\beta\rangle$ 相互正交</li><li>同时态$|\alpha\rangle$也存在完备性： $\frac{1}{\pi} \int|\alpha\rangle\langle\alpha| \mathrm{d}^{2} \alpha=1$</li></ul><h1 id="Squeezed-States（压缩态？）"><a href="#Squeezed-States（压缩态？）" class="headerlink" title="Squeezed States（压缩态？）"></a>Squeezed States（压缩态？）</h1><p>Squeezed States是更满足最小不确定性原理的更广义的态，相干态为其中是一种特殊的形式。</p><p>若我们令 </p><script type="math/tex; mode=display">a=\frac{X_{1}+\mathrm{i} X_{2}}{2}</script><p>由$a_{k}^{\dagger}$与$a_k$的对易关系我们可以得到： </p><script type="math/tex; mode=display">\left[X_{1}, X_{2}\right]=2 \mathrm{i}</script><p>且X1、X2满足不确定关系 $\Delta X_1 \Delta X_2 \geq 1$ ，特别的当 $\Delta X_1=\Delta X_2=1$ 时即为相干态。<br><img src="/img_QO/1.png" srcset="/img/loading.gif" alt="势能如图"><br>(a)相干态(b)Squeezed State<br>如图，当$\Delta X_1=\Delta X_2=1$为相干态；相干态$|\alpha\rangle$振幅的平均值为为$\alpha$对应图中的圆心，圆代表误差范围；当X1、X2任意时就是Squeezed state$|\alpha, \epsilon\rangle$ </p><p>同在相干态中的操作，Squeezed state也可以由幺正变化作用在相干态上来生成。 $|\alpha, \epsilon\rangle= D(\alpha) S(\epsilon)|0\rangle$</p><p>其中， $S(\epsilon)=\exp \left(1 / 2 \epsilon^{*} a^{2}-1 / 2 \epsilon a^{\dagger 2}\right)$ 。 $\epsilon$ 为Squeezed state对应的下标$\epsilon=r \mathrm{e}^{2 \mathrm{i} \phi}$</p><p>$S(\varepsilon)$满足的一些性质：</p><ul><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon)=S^{-1}(\varepsilon)=S(-\varepsilon)</script></li><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon) a S(\varepsilon)=a \cosh r-a^{\dagger} \mathrm{e}^{-2 \mathrm{i} \phi} \sinh r</script></li><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon) a^{\dagger} S(\varepsilon)=a^{\dagger} \cosh r-a \mathrm{e}^{-2 \mathrm{i} \phi} \sinh r</script></li><li><script type="math/tex; mode=display">S^{\dagger}(\varepsilon)\left(Y_{1}+\mathrm{i} Y_{2}\right) S(\varepsilon)=Y_{1} \mathrm{e}^{-r}+\mathrm{i} Y_{2} \mathrm{e}^{r}</script>其中 <script type="math/tex; mode=display">Y_{1}+\mathrm{i} Y_{2}=\left(X_{1}+\mathrm{i} X_{2}\right) \mathrm{e}^{-\mathrm{i} \phi}</script></li></ul><p>则Squeezed States对应不同的满足 $\Delta X<em>{1} \Delta X</em>{2} \ge 1$ 的 $\Delta X<em>{1}$、$\Delta X</em>{2}$ ，且某一个小于相干态。<br><img src="/img_QO/2.png" srcset="/img/loading.gif" alt="势能如图"><br>黑色点处代表相干态，阴影部分代表Squeezed state<br>一般压缩态$|\alpha, \varepsilon\rangle$中$r=|\boldsymbol{\varepsilon}|$称为压缩因子。</p><p>在Squeezed state表象下：</p><ul><li><script type="math/tex; mode=display">\left\langle X_{1}+\mathrm{i} X_{2}\right\rangle=\left\langle Y_{1}+\mathrm{i} Y_{2}\right\rangle \mathrm{e}^{\mathrm{i} \phi}=2 \alpha</script></li><li><script type="math/tex; mode=display">\Delta Y_{1}=\mathrm{e}^{-r},  \Delta Y_{2}=\mathrm{e}^{r}</script></li><li><script type="math/tex; mode=display">\langle N\rangle=\left|\alpha^{2}\right|+\sinh ^{2} r</script></li><li><script type="math/tex; mode=display">(\Delta N)^{2}=\left|\alpha \cosh r-\alpha^{*} \mathrm{e}^{2 i \phi} \sinh r\right|^{2}+2 \cosh ^{2} r \sinh ^{2} r</script>对应的物理图像可以理解为图1的坐标旋转。<h2 id="p-s-压缩态的光子数分布："><a href="#p-s-压缩态的光子数分布：" class="headerlink" title="p.s.压缩态的光子数分布："></a>p.s.压缩态的光子数分布：</h2>对于态 $|\alpha, r\rangle$ 其光子数分布为 <script type="math/tex; mode=display">p(n)=(n ! \cosh r)^{-1}\left[\frac{1}{2} \tanh r\right]^{n} \exp \left[-|\alpha|^{2}-\frac{1}{2} \tanh r\left(\left(\alpha^{*}\right)^{2} \mathrm{e}^{\mathrm{i} \phi}+\alpha^{2} \mathrm{e}^{-\mathrm{i} \phi}\right)\right]\left|H_{n}(z)\right|^{2}</script>其中 $z=\frac{\alpha+\alpha^{*} \mathrm{e}^{\mathrm{i} \phi} \tanh r}{\sqrt{2 \mathrm{e}^{\mathrm{i} \phi} \tanh r}}$ 可以将其视为一种广义的泊松分布。<br><img src="/img_QO/3.png" srcset="/img/loading.gif" alt="势能如图"><br>当压缩率r过大时，其光子数分布会随n震荡。</li></ul><h1 id="双光子的相干态"><a href="#双光子的相干态" class="headerlink" title="双光子的相干态"></a>双光子的相干态</h1><p>当然，也可以使用另一种方法来定义压缩态。<br>此时我们定义：若 $b=\mu a+v a^{\dagger}$且$|\mu|^{2}-|v|^{2}=1$，则$\left[b, b^{\dagger}\right]=1$</p><p>可以通过变换由a得到b，即 $b=U a U^{\dagger} $</p><p>对于b的本征值问题有 </p><script type="math/tex; mode=display">b|\beta\rangle_{\mathrm{g}}=\beta|\beta\rangle_{\mathrm{g}}</script><p>其中$|\beta\rangle_g=U|\beta\rangle$。$|\beta\rangle$为$a$的本征态。</p><p>可以证明$|\beta\rangle_g$的方向是与相干态的方向平行的。所以我们可以使用基态来得到$|\beta\rangle_g$，即</p><script type="math/tex; mode=display">|\beta\rangle_{\mathrm{g}}=D_{\mathrm{g}}(\beta)|0\rangle_{\mathrm{g}}</script><p>其中<script type="math/tex">D_{\mathrm{g}}(\beta)=\mathrm{e}^{\beta \mathrm{b}^{\dagger}-\beta^{*} b}</script></p><script type="math/tex; mode=display">|0\rangle_{\mathrm{g}}=U|0\rangle</script><p>这里$|\beta\rangle_g$就是双光子的相干态。</p><p>可以发现双光子态是完备的，</p><script type="math/tex; mode=display">\int|\beta\rangle_{\mathrm{g}} g\langle\beta| \frac{\mathrm{d}^{2} \beta}{\pi}=1</script><p>而其模为</p><script type="math/tex; mode=display">\mathrm{g}\left\langle\beta | \beta^{\prime}\right\rangle_{\mathrm{g}}=\exp \left(\beta^{*} \beta^{\prime}-\frac{1}{2}|\beta|^{2}-\frac{1}{2}\left|\beta^{\prime}\right|^{2}\right)</script><p>这时我们发现若令 $U=S(\varepsilon)$，当$\mu=coshr$且则双光子的相干态与压缩态是一样的。即：</p><script type="math/tex; mode=display">|\beta\rangle_{\mathrm{g}}=S(\varepsilon) D(\beta)|0\rangle</script><h1 id="电场中的方差"><a href="#电场中的方差" class="headerlink" title="电场中的方差"></a>电场中的方差</h1><p>当我们通过X1与X2来表述电场时：</p><script type="math/tex; mode=display">E(\boldsymbol{r}, t)=\frac{1}{\sqrt{L^{3}}}\left(\frac{\hbar \omega}{2 \varepsilon_{0}}\right)^{1 / 2}\left[X_{1} \sin (\omega t-\boldsymbol{k} \cdot \boldsymbol{r})-X_{2} \cos (\omega t-\boldsymbol{k} \cdot \boldsymbol{r})\right]</script><p>可以很容易得到其方差为 </p><script type="math/tex; mode=display">\begin{aligned} V(E(\boldsymbol{r}, t))=& K\left\{V\left(X_{1}\right) \sin ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})+V\left(X_{2}\right) \cos ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})\right.\\ &\left.-\sin [2(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})] V\left(X_{1}, X_{2}\right)\right\} \end{aligned}</script><p>其中： </p><script type="math/tex; mode=display">\begin{aligned} K &=\frac{1}{L^{3}}\left(\frac{2 \hbar \omega}{\varepsilon_{0}}\right) \\ V\left(X_{1}, X_{2}\right) &=\frac{\left\langle\left(X_{1} X_{2}\right)+\left(X_{2} X_{1}\right)\right\rangle}{2}-\left\langle X_{1}\right\rangle\left\langle X_{2}\right\rangle \end{aligned}</script><p>由于最小不确定性原理 $V\left(X_1, X_2\right)=0$，有 </p><script type="math/tex; mode=display">V(E(\boldsymbol{r}, t))=K\left[V\left(X_{1}\right) \sin ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})+V\left(X_{2}\right) \cos ^{2}(\omega t-\boldsymbol{k} \cdot \boldsymbol{r})\right]</script><p><img src="/img_QO/4.png" srcset="/img/loading.gif" alt="势能如图"><br>图为电场的平均值与不确定度的关系，使用线条的粗细代表不确定度的大小。<br>由图中可以看出来：相干态（a）的方差均匀分布，这可以用上述的误差图看出，相干态的误差为圆形；而对于压缩态(b)(c），由于其误差为椭圆会呈现出不同的图案来。</p><h1 id="Multimode-Squeezed-States"><a href="#Multimode-Squeezed-States" class="headerlink" title="Multimode Squeezed States"></a>Multimode Squeezed States</h1><p>正如上面我们讨论到的，对于单一模的态不会存在压缩态，即压缩态存在于多模中。</p><p>双模的压缩态可以定义为 </p><script type="math/tex; mode=display">\left|\alpha_{+}, \alpha_{-}\right\rangle= D_{+}\left(\alpha_{+}\right) D_{-}\left(\alpha_{-}\right) S(G)|0\rangle</script><p>其中，位移算符</p><script type="math/tex; mode=display">D_{\pm}(\alpha)=\exp \left(\alpha a_{\pm}^{\dagger}-\alpha^{*} a_{\pm}\right)</script><p>幺正算符</p><script type="math/tex; mode=display">S(G)=\exp \left(G^* a_+ a_--G a_{+}^{\dagger} a_{-}^{\dagger}\right)</script><p>对幺正算符有</p><script type="math/tex; mode=display">S^{\dagger}(G) a_{\pm} S(G)=a_{\pm} \cosh r-a_{\mp}^{\dagger} \mathrm{e}^{\mathrm{i} \theta} \sinh r 其中 G=r \mathrm{e}^{\mathrm{i} \theta}</script><p>由上述有：</p><script type="math/tex; mode=display">\begin{aligned} \left\langle a_{\pm}\right\rangle &=\alpha_{\pm} \\ \left\langle a_{\pm} a_{\pm}\right\rangle &=\alpha_{\pm}^{2} \\ \left\langle a_{+} a_{-}\right\rangle &=\alpha_{+} \alpha_{-}-\mathrm{e}^{\mathrm{i} \theta} \sinh r \cosh r \\ \left\langle a_{\pm}^{\dagger} a_{\pm}\right\rangle &=\left|\alpha_{\pm}\right|^{2}+\sinh ^{2} r \end{aligned}</script><p>我们可以定义一个正交算符</p><script type="math/tex; mode=display">X=\frac{1}{\sqrt{2}}\left(a_{+}+a_{+}^{\dagger}+a_{-}+a_{-}^{\dagger}\right)</script><p>则这个算符的平均值与方差分别为：</p><script type="math/tex; mode=display">\begin{aligned} \langle X\rangle &= 2\left(\operatorname{Re}\left\{\alpha_{+}\right\}+\operatorname{Re}\left\{\alpha_{-}\right\}\right) \\ V(X) &=\left(\mathrm{e}^{-2 r} \cos ^{2} \frac{\theta}{2}+\mathrm{e}^{2 r} \sin ^{2} \frac{\theta}{2}\right) \end{aligned}</script>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Quantum Optics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to Su-Schrieffer-Heeger</title>
    <link href="/2020/05/30/SSH/"/>
    <url>/2020/05/30/SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="previously-of-SSH-model"><a href="#previously-of-SSH-model" class="headerlink" title="previously of SSH model"></a>previously of SSH model</h1><h1 id="SSH-model的体部分"><a href="#SSH-model的体部分" class="headerlink" title="SSH model的体部分"></a>SSH model的体部分</h1><p>由Peierls定理，可知一条由费米子排列成的链具有如下结构：<br><img src="/img_ssh/1.png" srcset="/img/loading.gif" alt="势能如图"><br>图中，规定A粒子为灰色的粒子，B粒子为白色的粒子；A与其后的B粒子构成晶胞其作用力为v，晶胞间作用力（B与其后的A）为w。</p><h1 id="SSH-model的Hamiltonian"><a href="#SSH-model的Hamiltonian" class="headerlink" title="SSH model的Hamiltonian"></a>SSH model的Hamiltonian</h1><p>考虑单电子在如上图的原子排列中的运动</p><script type="math/tex; mode=display">H=v \sum_{m=1}^{N} (|m, B \rangle\langle m, A|+h . c .) +w \sum_{m=1}^{N-1}(|m+1, A\rangle\langle m, B|+{h.c.})</script><p>这里使用了紧束缚模型，即电子在某一原子上所受的作用只取决与与之相邻的两个原子的作用。<br>这里可以把$v,w$看成在电子在不同建上跃迁的概率。<br>同时注意SSH模型中没有电子与原子的自旋。</p><h2 id="体Hamiltonian"><a href="#体Hamiltonian" class="headerlink" title="体Hamiltonian"></a>体Hamiltonian</h2><p>先来考虑均匀的链,在其体内（非边缘）的哈密顿量可以表述为：</p><script type="math/tex; mode=display">\hat{H}_=\sum_{m=1}^{N}(v|m, B\rangle\langle m, A|+w|(m \bmod N)+1, A\rangle\langle m, B|)+h . c .</script><p>在实空间（$N=4$）中Hamiltonian的矩阵形式为：</p><script type="math/tex; mode=display">\left(\begin{array}{llllllll}{0} & {v} & {0} & {0} & {0} & {0} & {0} & {w} \\ {v} & {0} & {w} & {0} & {0} & {0} & {0} & {0} \\ {0} & {w} & {0} & {v} & {0} & {0} & {0} & {0} \\ {0} & {0} & {v} & {0} & {w} & {0} & {0} & {0} \\ {0} & {0} & {0} & {w} & {0} & {v} & {0} & {0} \\ {0} & {0} & {0} & {0} & {v} & {0} & {w} & {0} \\ {0} & {0} & {0} & {0} & {0} & {w} & {0} & {v} \\ {w} & {0} & {0} & {0} & {0} & {0} & {v} & {0}\end{array}\right)</script><p>解特征方程，其中$\Psi_n$为特征解</p><script type="math/tex; mode=display">H_{ {bulk }}\left|\Psi_{n}(k)\right\rangle= E_{n}(k)\left|\Psi_{n}(k)\right\rangle</script><h2 id="体动量空间Hamiltonian"><a href="#体动量空间Hamiltonian" class="headerlink" title="体动量空间Hamiltonian"></a>体动量空间Hamiltonian</h2><p>由Bloch定理，带入平面波形式的特征解有</p><script type="math/tex; mode=display">|k\rangle=\frac{1}{\sqrt{N}} \sum_{m=1}^{N} e^{i m k}|m\rangle</script><p>其中$k$在第一布里渊区取值。</p><script type="math/tex; mode=display">k \in\left\{\delta_k, 2 \delta_k, \ldots, N \delta_k \right\}</script><p>而$\delta_k=\frac{2 \pi}{N}$同时也可以把这个看成由实空间到动量空间的转换的傅里叶变换。</p><p>$|\Psi_n \rangle$可以看成由$| k \rangle$与$|u_n (k)\rangle$张成的，即</p><script type="math/tex; mode=display">\left|\Psi_{n}(k) \right\rangle=|k\rangle \otimes\left|u_{n}(k)\right\rangle ; \quad \quad\left|u_{n}(k)\right\rangle= a_{n}(k)|A\rangle+ b_{n}(k)|B\rangle</script><p>则$|u_n(k)\rangle$为体动量空间Hamiltonian${H}(k)$的本征态：</p><script type="math/tex; mode=display">{H}(k)\left|u_{n}(k)\right\rangle= E_{n}(k)\left|u_{n}(k)\right\rangle</script><p>其中定义${H}(k)$为</p><script type="math/tex; mode=display">{H}(k)=\langle k|\hat{H}_{bulk}| k\rangle</script><h2 id="Hamiltonian本征值——能量"><a href="#Hamiltonian本征值——能量" class="headerlink" title="Hamiltonian本征值——能量"></a>Hamiltonian本征值——能量</h2><p>在第一布里渊区中有周期性条件：</p><script type="math/tex; mode=display">{H}(k+2 \pi)=\hat{H}(k) ; \quad \quad\left|u_{n}(k+2 \pi)\right\rangle=\left|u_{n}(k)\right\rangle</script><p>将上述对$|\Psi_n \rangle$的分解带入薛定鄂方程有<br><img src="/img_ssh/2.png" srcset="/img/loading.gif" alt=""><br>可以化简$H(k)$，发现其为分块对角矩阵，且每个分块对角的矩阵维数相同。形如</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}{H_{1}} & {O} & {\cdots} & {O} \\ {O} & {H_{2}} & {\cdots} & {O} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {O} & {O} & {\cdots} & {H_{n}}\end{array}\right]</script><p>对于每一个分块有（取第一分块）：</p><script type="math/tex; mode=display">H(k)=\left(\begin{array}{cc}{0} & {v+w e^{-i k}} \\ {v+w e^{i k}} & {0}\end{array}\right) ; \quad H(k)\left(\begin{array}{c}{a(k)} \\ {b(k)}\end{array}\right)=E(k)\left(\begin{array}{c}{a(k)} \\ {b(k)}\end{array}\right)</script><p>可以求得能量为</p><script type="math/tex; mode=display">E(k)=\left|v+e^{-i k} w\right|=\sqrt{v^{2}+w^{2}+2 v w \cos k}</script><h2 id="SSH-model的能量"><a href="#SSH-model的能量" class="headerlink" title="SSH model的能量"></a>SSH model的能量</h2><p>由上面求出的能量关系使可以给出清楚的图像：<br><img src="/img_ssh/3.png" srcset="/img/loading.gif" alt=""><br>若令$\Delta$为最小的能量差，可以看到</p><script type="math/tex; mode=display">\Delta=\min _{k} E(k)=|v-w|</script><p>如图中显示，当$v=w$时两能级之间没有间隔，即为导体。当$v\ne w$时，为绝缘体。<br>需要说明的是当$v\ne w$时不一定为绝缘体，因为当v与w相隔较近时（一般为2eV）可为半导体</p><h2 id="Hamiltonian的另一种表示方法"><a href="#Hamiltonian的另一种表示方法" class="headerlink" title="Hamiltonian的另一种表示方法"></a>Hamiltonian的另一种表示方法</h2><p>当使用二次量子化求Hamiltonian时可以得到Hamiltonian的另一种表示方法。当然也可以对上面求得的<br>H在palli矩阵基下进行分解，有：</p><script type="math/tex; mode=display">H(k)=h(k) \cdot \sigma</script><p>其中</p><script type="math/tex; mode=display">\sigma_{x}=\left(\begin{array}{cc}{0} & {1} \\ {1} & {0}\end{array}\right), \sigma_{y}=\left(\begin{array}{cc}{0} & {-i} \\ {i} & {0}\end{array}\right), \sigma_{z}=\left(\begin{array}{cc}{1} & {0} \\ {0} & {-1}\end{array}\right)</script><p>令$w=|w| e^{i a r g(w)}$则</p><script type="math/tex; mode=display">\begin{array}{l}{h_{x}(k)={Re}(v)+|w| \cos (k b+\arg (w))} \\ {h_{y}(k)=-{Im}(v)+|w| \sin (k b+\arg (w))} \\ {h_{z}(k)=0}\end{array}</script><p>可知</p><script type="math/tex; mode=display">H(k)=\left(\begin{array}{cc}{0} & {h^{*}(k)} \\ {h(k)} & {0}\end{array}\right)</script><h2 id="Winding-number"><a href="#Winding-number" class="headerlink" title="Winding number"></a>Winding number</h2><p>通过对能级与导体和绝缘体的讨论可以发现当v与w构成的几何有不同的特性时是可以影响物体导电性的</p><p>故，设置Winding number为：</p><script type="math/tex; mode=display">\nu=\frac{1}{2 \pi i} \int_{-\pi}^{\pi} d k \frac{d}{d k} \ln (h(k))</script><p>可以作为SSH模型的一个‘拓扑’数</p><p>注意到当$v=w$时是无法在$R^2$空间上定义Winding number的，这时需要运用黎曼面等数学工具。</p><h1 id="Edge-states"><a href="#Edge-states" class="headerlink" title="Edge states"></a>Edge states</h1><p>SSH模型在完全二聚体模型下十分简单。完全二聚体：$v=0, w=1$或者$v=1, w=2$的情形下即为完全二聚体。</p><p>这时存在两种状态：</p><h2 id="trivial-v-1-w-0-时"><a href="#trivial-v-1-w-0-时" class="headerlink" title="trivial:$v=1, w=0$时"></a>trivial:$v=1, w=0$时</h2><p><img src="/img_ssh/4.png" srcset="/img/loading.gif" alt=""><br>此时排列为平庸的，即只有包内有作用力，且没有咕儿原子。这时方程为</p><script type="math/tex; mode=display">\hat{H}(|m, A\rangle \pm|m, B\rangle)=\pm(|m, A\rangle \pm|m, B\rangle)</script><p>此时哈密顿量为$\hat{H}(k)=\hat{\sigma}_x$，则此时解同体空间中的差不多（因此称为平凡情况）</p><h2 id="topological-v-0-w-1-时"><a href="#topological-v-0-w-1-时" class="headerlink" title="topological:$v=0, w=1$时"></a>topological:$v=0, w=1$时</h2><p><img src="/img_ssh/5.png" srcset="/img/loading.gif" alt=""><br>此时为拓扑排列，在这种状态中只有不同晶胞中的才有作用力，而且开头和和结尾存在两个咕儿。方程为</p><script type="math/tex; mode=display">\hat{H}(|m, B\rangle \pm|m+1, A\rangle)=\pm(|m, B\rangle \pm|m+1, A\rangle)</script><p>其中$m=1, \ldots, N-1$而$\hat{H}(k)=\hat{\sigma}_x \cos k+\hat{\sigma}_y \sin k$<br>可以发现链的每一端的都有一个零能级的单一特征态</p><script type="math/tex; mode=display">\hat{H}|1, A\rangle=\hat{H}|N, B\rangle= 0</script><p>这时这两个咕儿原子就为边缘态</p><h2 id="trivial态与topological态的混合"><a href="#trivial态与topological态的混合" class="headerlink" title="trivial态与topological态的混合"></a>trivial态与topological态的混合</h2><p>由实验测得有：<br><img src="/img_ssh/6.png" srcset="/img/loading.gif" alt=""><br>说明：</p><ul><li>(a)细胞间跳变幅度系统能谱w=1作为函数细胞内跳变幅度对应拓扑(平凡)相。</li><li>(b)、(c)为杂化边缘态的波函数</li><li>(d)为一般体波函数。</li></ul><p>可以发现</p><ul><li>当$w=1$且v比较小时两个咕儿原子处的能量时以$E=e^{-N / \xi}$变化的，其中局域长度为$\xi=/ \log (v / w)$</li><li>当存在边缘态时，电子在两个咕儿原子处出现的概率最大（波函数大）。而其他地方出现的概率则较小</li><li>当只有体状态时，电子在不同原子处的概率一般分布。</li></ul><h1 id="Chiral-symmetry"><a href="#Chiral-symmetry" class="headerlink" title="Chiral symmetry"></a>Chiral symmetry</h1><p>当厄密算符$U$作用在哈密顿量时，可以说哈密顿量有U对称性</p><script type="math/tex; mode=display">\hat{U} \hat{H} \hat{U}^{\dagger}=\hat{H}</script><p>若令晶格平移算符</p><script type="math/tex; mode=display">\hat{U}=|m+1, A\rangle\langle m, A|+| m+1, B\rangle\langle m, B|</script><p>注意到这个算符是非厄密的</p><h1 id="Edge-states数是拓扑不变的"><a href="#Edge-states数是拓扑不变的" class="headerlink" title="Edge states数是拓扑不变的"></a>Edge states数是拓扑不变的</h1>]]></content>
    
    
    <categories>
      
      <category>physics note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>topological</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QMNG</title>
    <link href="/2020/05/29/qrng/"/>
    <url>/2020/05/29/qrng/</url>
    
    <content type="html"><![CDATA[<h1 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h1><p><strong>问题</strong></p><ul><li>随机性的来源？<br>随机性检验？or量子力学假设？认为QRNG为真随机数的依据（逻辑链）？</li></ul><h1 id="量子力学"><a href="#量子力学" class="headerlink" title="量子力学"></a>量子力学</h1><h2 id="EPR佯谬"><a href="#EPR佯谬" class="headerlink" title="EPR佯谬"></a>EPR佯谬</h2><p>考虑一个$\pi^0$介子到电子——正电子的衰变：</p><script type="math/tex; mode=display">\pi^0 \rightarrow e^- +e^+</script><p>由于$\pi^0$的自旋为0，由角动量守恒，要求电子与正电子对处在单态组态。</p><p>EPR实验的BOHM方案：一个静止$\pi^0$介子衰变为电子-正电子对。<br><strong><script type="math/tex">\frac{1}{\sqrt{2}}(\uparrow_-\downarrow+\uparrow_+\downarrow_-）</script></strong></p><p>如果电子的自旋向上，正电子的自旋必须向下，反之亦然。在任何一个特定的π 0 介子衰变中，量子力学无法预测会得到哪一种自旋组合，但是它明确指出电子、正电子自旋的测量是 相关的，平均说来得到每一种组合的几率是 1/2。</p><p>定域性：任何<strong>影响</strong>的传播速度都不能超过光速</p><p>结论：波函数的坍塌是瞬时的！</p><h2 id="Bell定理"><a href="#Bell定理" class="headerlink" title="Bell定理"></a>Bell定理</h2><p>推广实验：<br>Bell 让两个探测器都能独立的转动。第一个测量电子自旋沿一个单位矢量<strong>a</strong>的分量， 第二个测量正电子自旋沿另一个单位矢量<strong>b</strong>的分量。<br>简单起见，以$h/2$为单位记录自旋;则每个探测器沿指定方向记录+1(自旋向上)或-1(自旋向下)<br>测量结果<br><img src="/img/1.png" srcset="/img/loading.gif" alt=""></p><p><strong>计算自旋乘积的平均值</strong>$P(a,b)$（量子力学结论）<br>对任意的指向，由量子力学有</p><script type="math/tex; mode=display">P(a,b)=-a\cdot b</script><p>特别的：</p><ul><li>如果两个探测器方向是平行$(b=a)$<script type="math/tex; mode=display">P(a,a)=-1</script></li><li>如果安排探测器方向反平行$(b=-a)$<script type="math/tex; mode=display">P(a,-a)=1</script></li></ul><p><strong>Bell不等式</strong>（隐变量结论）</p><ul><li>假设电子，正电子体系的“完整”态是由隐变量 λ 表征的( λ<br>从一个衰变到下一个的变化是我们不知也不可控制的)。</li><li>假设电子测量的结果是独立于正电子探测器指向( b )的——这个指向可以在对电子马上要进行测量之前由试验者选择， 使得指向选择的信息无法在电子测量之前传到电子。(这就是<strong>定域性假设</strong>。)</li><li>设函数$A(a,\lambda)$给出电子测量结果，函数$B(b,\lambda)$给出正电子测量结果<br>$A(a,\lambda)=\pm1 $         $B(b,\lambda)=\pm1$<br>当探测器指向一致时，有完全（反）相关<script type="math/tex">A(a,\lambda)=-B(b,\lambda)</script>测量乘积的平均值为<script type="math/tex">P(a,b)=-\int\rho(\lambda) A(a,\lambda) B(b,\lambda) d \lambda</script>其中为隐变量的几率密度，有$\int \rho d\lambda=1$，不同的理论有不同的<br>消去B有<script type="math/tex">P(a,b)=-\int\rho(\lambda) A(a,\lambda) A(b,\lambda) d \lambda</script><br>对任意的单位矢量c，有<script type="math/tex">P(a,b)-P(a,c)=-\int \rho(\lambda)[A(a,\lambda)A(b,\lambda)-A(a,\lambda)A(c,\lambda)]d\lambda</script><script type="math/tex; mode=display">=-\int \rho(\lambda)[1-A(b,\lambda)A(c,\lambda)]A(a,\lambda)A(b,\lambda)d\lambda</script>(<em>$[A(b,\lambda)]^2 =1$</em>)<br>又因为$-1\leq [A(a,\lambda)B(b,\lambda)]\leq +1$，所以$\rho(\lambda)[1-A(b,\lambda)A(c,\lambda)]\ge 0 $</li></ul><script type="math/tex; mode=display">|P(a,b)-P(a,c)|\leq \int \rho (\lambda)[1-A(b,\lambda)A(c,\lambda)]d\lambda</script><p>即<strong><script type="math/tex">|P(a,b)-P(a,c)|\leq 1+P(b,c)</script></strong></p><p>可以计算出，Bell不等式与量子力学的结论矛盾。</p><hr><h1 id="量子随机数"><a href="#量子随机数" class="headerlink" title="量子随机数"></a>量子随机数</h1><h2 id="真随机数基础知识"><a href="#真随机数基础知识" class="headerlink" title="真随机数基础知识"></a>真随机数基础知识</h2><p>定义：<br>随机数是不存在<strong>周期性</strong>或明显的规律的非确定<strong>时序</strong>（时序特性），满足一定的统计规律（统计特性）<br>理想二进制随机序列的特性：</p><ul><li><strong>统计均匀性</strong>出现0和1的概率为均匀分布即<script type="math/tex">p(x_i)=\frac{1}{2}</script>其中$x_i =0,1$<br>扩展到N进制，则出现0，1，2，…，N-1的概率为均匀分布，即<script type="math/tex">p(x_i)=\frac{1}{N}</script></li><li><strong>相互无关性</strong>每一位信息与序列中其余的信息之间没有关联，使用<em>自相关系数</em>表示<script type="math/tex">a_k= \delta[k]</script>    $k\in(-\infty,+\infty)$     ,$k\in Z$（没有周期性）</li><li><strong>不可预测性</strong>无法以超过$p(x<em>i)=0.5$的精确度向前（后）预测产生的随机信息$P(x_i)=P(x_i|x</em>{i-m}x<em>{i-m+1}…x</em>{i-1})$,$P(x<em>i)=P(x_i|x</em>{i+m}x<em>{i+m-1}…x</em>{i+1})$</li><li><strong>不可重复性</strong>无法在有限的时间内产生完全相同的随机序列</li></ul><h2 id="真随机数发生器的设计"><a href="#真随机数发生器的设计" class="headerlink" title="真随机数发生器的设计"></a>真随机数发生器的设计</h2><h3 id="量子随机源"><a href="#量子随机源" class="headerlink" title="量子随机源"></a>量子随机源</h3><p> <strong>离散型随机源</strong>例子——单光子源。优点：简单，好实现<br>实际方案为：将激光进行衰减，使脉冲的平均光子数$\mu$降到单光子数量级（准单光子源）。</p><ul><li>空间分辨特性：单光子对路径选择的随机性</li><li>时间分辨特性：在相干时间内对单光子进行测量，响应时间具有随机性<br>将脉冲的相干态以Fock态$|n&gt;$展开<script type="math/tex; mode=display">|a>=e^{-|a|^2/2}\sum_{n=0}^{\infty}\frac{a^n}{n!}|n></script>相干态的光子数分布符合柏松分布：<script type="math/tex">p(n)=<n|a><a|n>=\frac{<n>^n e^{-<n>}}{n!}</script>其中$<n>=|a|^2$为平均光子数<br>当通过衰减器后平均光子数为$\lambda$探测器效率为$\eta$<script type="math/tex; mode=display">p(n)=\frac{<\eta \lambda>^n e^{-<\eta \lambda>}}{n!}</script>此时平均光子数为$\eta \lambda$，且通过衰减器之后仍未泊松分布。<br>故二阶相关系数为$g^{(2)}(0)=1$?各个脉冲之间无聚束（Bunchin）也无（Anti—Bunchi）？</li></ul><p><strong>连续性随机源</strong>例子——激光相位噪声，放大自发辐射噪声，真空散粒噪声。优点：数据多，快。<br>  统计指标——平均值，方差，平均强度<br>对随机信号$x(t)$</p><p>统计性质——</p><ul><li><strong>概率密度分布函数</strong><script type="math/tex; mode=display">p(x)=\lim_{\Delta x\to0}\frac{P(x(t)\in (x,x+\Delta x))}{\Delta x}</script>与时序无关，描述的是信号取值的分布</li><li><strong>功率谱密度函数</strong><script type="math/tex; mode=display">G(f)=\lim_{\Delta f\to 0}\frac{\Psi_x^2(f,f+\Delta f)}{\Delta f }</script>信号的功率谱密度函数与自相关系数互为Fourier变换关系（Wiener—Khintchine定理），用来描述噪声信号的相干性。<br> （补充）</li></ul><h3 id="探测与采样"><a href="#探测与采样" class="headerlink" title="探测与采样"></a>探测与采样</h3><h4 id="器件"><a href="#器件" class="headerlink" title="器件"></a>器件</h4><p>对离散型真随机数产生方案中，探测方式为单光子探测器。可以直接作为数字化的随机序列输出</p><p>对连续型真随机数，探测结果为连续的，如光电传感器。需要将连续型结果转化为离散型的二进制信息。<br>采集器分别有：</p><ul><li><strong>比较器</strong></li></ul><p><img src="/img/2.png" srcset="/img/loading.gif" alt=""><br>预先设置调谐的阈值电平$U_{th}(t)$，比较探测信号与阈值电平的大小输出二进制信息<br>优点：结构简单，可以达到GHz的带宽与GSa/s的采样频率（不快）<br>缺点：1.速度慢，每次只能输出1bit的信息。2.阈值电平设置问题，会产生非均匀分布，要使用von Neumann方法消除偏差，更慢！</p><ul><li><strong>模-数转化器</strong></li></ul><p><img src="/img/3.png" srcset="/img/loading.gif" alt=""><br>改良的比较器，有多个阈值和一个前置滤波器。输出的信号通过具有较大带宽$B_{pre}$的前置滤波器（为使探测模块的信号采样不失真），之后逐级与阈值比较，输出二进制信号。<br>模-数转化器最大允许的采样速率一般可以大于器件自身的采样速率——“过采样”，合理使用过采样可以提速。<br>优点：速度快，好应用</p><ul><li><strong>数字示波器</strong><br>多级模-数转化器<br>优点：一体化。缺点：功率体积太大</li></ul><h4 id="采样速率与采样精度的影响"><a href="#采样速率与采样精度的影响" class="headerlink" title="采样速率与采样精度的影响"></a>采样速率与采样精度的影响</h4><p>采样速率与采样精度会对随机数发生器的输出产生影响。<br>        原始序列产生速率=采样速率*采样精度<br>单位：采样速率为个数/秒（Sa/s），采样精度为比特（bit）</p><ul><li><strong>采样速率</strong><br>实际过程中，不是采样速率越大越好。<br>由于噪声功率谱密度函数与自相关函数互为傅立叶变化关系，其参数——噪声功率谱的线宽与信号的相干时间，二者互为倒数。<br><em>这意味着</em>：采样速率越大数据中的相关性也越大。同时采样速率过快也会使后处理中最小熵下降，使用m-LSB时要舍弃更多的数据。<br>选择采样速率的操作：通过采样后信号的熵估算，平衡采样速率与相关性。使后处理出来的数据在可靠的基础上最多</li><li><strong>采样精度</strong>采样精度由采集器决定<br>采样精度越高，就可以更精准的描述信号中的随机性，有效信息（每一个采样信号的信息量）也越大。模-数转化器有8、10、12bit的精度，一般为8bit。</li></ul><p><img src="/img/4.png" srcset="/img/loading.gif" alt=""></p><p>对一个高斯分布<script type="math/tex">p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-x^2/2\sigma^2}</script>，其信息熵只与方差有关<script type="math/tex">H(x)=-\int_{-\infty}^{\infty} p(x) log_2 p(x) dx=\frac{1}{2} log_2 2\pi e\sigma^2</script><br>采样精度提高后信号的分布函数方差更接近随机数方差。<br>当然，采样精度也不是越大越好。<br>在采样速率对于经典噪声与量子噪声都不是“过采样”时继续提高采样精度，量子与经典噪声都会等幅度的增加划分。因此，提高采样精度并不可以提高最终序列的产生速率，反而增加了后处理的难度。</p><h3 id="算法后处理"><a href="#算法后处理" class="headerlink" title="算法后处理"></a>算法后处理</h3><p>目的：提高采样速率</p><ol><li><strong>von Neumann方法</strong><br>重新定义联合事件：</li></ol><ul><li>连续两个bit位出现10的组合，称为新bit<strong>1</strong></li><li>连续两个bit位出现01的组合，称为新bit<strong>0</strong></li><li>其他全部舍弃（00，11）<br>作用：无论原始数据有何偏差，都可以使处理后的序列统计分布均匀$P(01)=P(10)$<br>缺点：产生速率损失大，速率也不稳定。输出序列和输入序列的长度比为$(1/4-e(n)^2)$，$e(n)^2$为原始数据的bias。</li></ul><ol><li><strong>逻辑异或（Exclusive OR）操作</strong><br>任意两个bit位$A_J$，$A_i$可以视为独立同分布，通过异或操作$B=A_i \oplus A_j$得到概率分布为<script type="math/tex; mode=display">P(B)=P(A_i\oplus A_j)=P(|A_i - A_j|)=P(A_i)P(A_j)</script>由于$A_J$，$A_i$分布相同，则可以将任意分布转化为对阵分布<br><img src="/img/5.png" srcset="/img/loading.gif" alt=""><br>异或操作：1.每个比特与后续数据进行异或操作，且每个bit只用一次<br> 2.每个比特与后续数据进行异或操作</li></ol><p><img src="/img/6.png" srcset="/img/loading.gif" alt=""></p><p>作用：1.改善统计分布，减小数据采集时引入的经典bias。<br>    2.具有较高的输入/输出比（1or1/2）<br><img src="/img/7.png" srcset="/img/loading.gif" alt=""><br>缺点：引入了一定的相关性与经典信息</p><ol><li><strong>最低有效位（m—LSB）操作</strong><br>保留每一次采样信号的m比特最低有效位。<br><img src="/img/8.png" srcset="/img/loading.gif" alt=""></li></ol><h3 id="随机性检验"><a href="#随机性检验" class="headerlink" title="随机性检验"></a>随机性检验</h3><ul><li><strong>算数平均值</strong>由均匀性，算数平均值为1/2。<script type="math/tex; mode=display">e(n)=\bar{X}-\frac{1}{2}</script>$e(n)$为偏置</li><li><strong>k阶自相关系数</strong>，是带检验序列$X_0$与自身位移后得到的序列$X_k$之间相关性的度量<script type="math/tex; mode=display">a_k=\frac{E[(x_i -\mu)(x_{i+k}-\mu)]}{\sigma^2}=\frac{\sum_i (x_i -\mu)(x_{(i+k)  modn}-\mu)}{\sum_i (x_i -\mu)^2}</script>式中n为序列长度，$\mu$ $\sigma$分别为序列的平均值与标准差。<br>对于理想随机数，$a_0=1$，$a_k=0$当$k\ne 0$时</li><li><strong>信息熵</strong>（Shannon熵）考察n比特长度作为基本单元子序列的概率密度分布<script type="math/tex; mode=display">H_n(X)=-\sum_{i=1}^{k^n} p_i log_k p_i</script>其中：k为进制，n为基本单位长度，$p_i$为子序列在总长度为N比特中出现的概率。规定$p_i=0$时$p_i log_k p_i=0$<br>信息熵是对序列概率的加权平均描述可以在一定程度上表示比特之间的统计分布和相关性的大小<br>对于理想二进制均匀分布，$p_i =1/N$其中$(i=0,1,2,…,2^n-1)$则此时信息熵最大值$H_n(X)=n$。<em>物理意义：</em>所有信息都有价值，有最大的非确定性4</li><li><strong>最小熵</strong><script type="math/tex">H_{n-min}=-log_k (max[p_i])</script><br>最小熵刻画了随机序列不确定的最小下限。m-LSB后处理使用最小熵确定m的值</li></ul><h4 id="输出序列的实际检验"><a href="#输出序列的实际检验" class="headerlink" title="输出序列的实际检验"></a>输出序列的实际检验</h4><ul><li><strong>标准检验包</strong><br>一套公认的的检验体系，基本思路：将一个带检测的输出序列划分为多个固定长度的子序列，根据置信水平（$\alpha=0.01$）给出待检序列通过检测的概率<br>1.DIEHARD统计检验包。<br>有18种子检测<br><img src="/img/9.png" srcset="/img/loading.gif" alt=""><br>所有检测共需要80M的待检测数据，每一个检测会给出一个p值，当$p&gt;\alpha$则通过检测。<br>对于6—11子检测，只能给出划分后子序列的p值，通过K-S Test转化为一个p值。<br>2.NIST-STS统计检验包。<br>有15个子检测<br><img src="/img/10.png" srcset="/img/loading.gif" alt=""><br>通过所有子检测需要有1G的比特长度，若不足检测会继续进行。<br>NIST-STS会给出两个值<br>p-值：同上，一般的判决阈值为$\alpha=0.0001$。<br>序列通过子检验的成功比例：假定划分的子序列数量为n，置信水平为$\alpha$<br>子序列通过单项检验的成功率取值在一个高斯分布中，其区间为<script type="math/tex">[1-\alpha-3\sqrt{\frac{\alpha (1-\alpha )}{n}},1-\alpha+3\sqrt{\frac{\alpha (1-\alpha )}{n}}]</script>当比例落入区间时，视为通过检测包。一般预设值为（n=1000，$\alpha=0.01$）区间为[0.9805，0.9995]</li><li><strong>三倍标准差（$3\sigma$）检测</strong></li></ul><p>指标：偏置$e(n)$，$k$阶自相关系数 $\alpha_k(n)$。</p><p>基本思想：由理想抛硬币模型所模拟的二进制随机序列的统计参数在一定置信水平下与数据长度相关。<br>1.偏置$e(n)$的$3\sigma$检验标准<br>理想抛硬币模型为均匀分布$P(1)=P(0)=1/2$<br>n次抛硬币出现m次正面的组合数为<script type="math/tex">N_n(m)=C_n^m</script><br>为伯努力分布，对其归一化<br>可以求出该分布的期望$E(x)=\frac{1}{2}$方差$D(x)=\frac{1}{4n}$<br>由中心极限定理，当$n\rightarrow \infty$时，p（x）趋于高斯分布<script type="math/tex">E(X),\sigma (x))=N(\frac{1}{2},\frac{1}{2\sqrt{n}})</script><br>同时偏置$p[e(x)]$也符合高斯分布</p><script type="math/tex; mode=display">p[e(n)]=N(e(X),\sigma (x))=N(0,\frac{1}{2\sqrt{n}})=\frac{1}{\sqrt{2\pi}\sigma_e}exp(-x^2/2\sigma_e^2)</script><p>在高斯分布中位于$[-3\sigma,+3\sigma]$区间的概率为99.7%，也就是偏置有99.7%落入$[-\frac{3}{2\sqrt{n}},+\frac{3}{2\sqrt{n}}]$。<br>对于落入区域以外的待检测序列，极大可能不满足随机序列的统计特征。<br>描述：<br>长度为n的随机序列，偏置$e(n)$满足：$|e(n)|&gt; \frac{3}{2\sqrt{n}}$，且序列仍为真随机序列的概率只有0.3%<br>2.自相关系数$\alpha_k(n)$的$3\sigma$检验标准<br>改写自相关的定义：</p><script type="math/tex; mode=display">a_1(n)\approx \frac{\sum_{i=1}^n y_i |_{y_i = [(1/2+e)^2,(1/2-e)^2,(-1/4+e^2)]}}{n(1/4+e^2)}\approx \frac{\sum_{i=1}^n y_i |_{y_i=[+1,-1]}}{n}</script><p><em>简化规则：</em><br> $x<em>i$ 为而进制，则 $x_i=0,1$<br>令 $y_1 =[x_i -E(x)][x</em>{(i+1)mod n}-E(x)]$ ，由 x_i$ 的取值 $y_i$ 只有三种取法 $y_i=(1/2+e)^2,(1/2-e)^2,(-1/4+e^2)$<br>当 $n-&gt;\infty$ 时，此时$e(n)$很小，故$y_i$中$e^2$项可以忽略<br>由数据之间的独立性，$y_i$中$-2e,+2e$项个数可以相互抵消<br>则一阶自相关系数满足高斯分布</p><script type="math/tex; mode=display">p[a_1 (n)]=N(0,\sigma_a)=\frac{1}{\sqrt{2 \pi}\sigma_a} exp(-x^2/2\sigma_a^2)</script><p>由于偏置$e(n)$中$y_i$取值为$\pm 1/2$，而一阶自相关系数中 $y_i$ 取值为 $\pm 1$ ，则</p><script type="math/tex; mode=display">\sigma_a=2\sigma_e=\frac{1}{\sqrt{n}}</script><p><em>描述</em>：<br>长度为n的随机序列，一阶自相关系数满足$|a_1(n)|&gt;\frac{3}{\sqrt{n}}$，且仍为真随机序列的概率只有0.3%<br>此方法可以推广到k阶</p>]]></content>
    
    
    <categories>
      
      <category>program note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>application of QM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>introduction to python</title>
    <link href="/2020/05/29/note/"/>
    <url>/2020/05/29/note/</url>
    
    <content type="html"><![CDATA[<h1 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h1><h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><ul><li>整型：(int)</li><li>字符串型：字符串是以单引号或双引号括起来的任意文本</li><li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写）</li><li>复数型：虚部的<code>i</code>换成了<code>j</code>。<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><strong>输入：</strong>\<br>使用input()函数获取键盘输入，使用int()进行类型转换<pre><code class="hljs Python">a = int(input(<span class="hljs-string">'a = '</span>))</code></pre>若为<code>a = input(&#39;a = &#39;)</code>则此时a为字符串</li></ul><p><strong>输出：</strong><br><pre><code class="hljs Python">a=<span class="hljs-number">1</span>print(<span class="hljs-string">"a = "</span>, a)</code></pre><br>输出为a=1<br><pre><code class="hljs Python">a = int(input(<span class="hljs-string">'a = '</span>))b = int(input(<span class="hljs-string">'b = '</span>))print(<span class="hljs-string">'%d + %d = %d'</span> % (a, b, a + b))</code></pre><br>对<code>print</code>的理解——使用占位符格式化输出的字符串<code>%d</code>中<code>d</code>可以是任意的字符，代表占位。\<br>但占位字符需保持一致.下述代码不能通过编译<br><pre><code class="hljs Python"><span class="hljs-string">'''</span><span class="hljs-string">错误示范</span><span class="hljs-string">'''</span>print(<span class="hljs-string">'%a + %b = %b'</span> % (a, b, a + b))</code></pre><br><strong>检查变量的类型：</strong><br><pre><code class="hljs Python"><span class="hljs-string">'''</span><span class="hljs-string">显示变量的数据类型</span><span class="hljs-string">'''</span>print(type(a))</code></pre><br><strong>变量转换的内置函数</strong></p><ul><li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code>：将一个字符串转换成浮点数。</li><li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>按照优先级从高到低的顺序列出了所有的运算符</li></ul><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> ,<code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> ,<code>+</code> ,<code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code>, <code>/</code>, <code>%</code> ,<code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> ,<code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code>, <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> ,`\</td><td>`</td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code>, <code>&lt;</code> ,<code>&gt;</code>, <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> ,<code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code> , <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> ,<code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code>, <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> ,<code>+=</code> ,<code>-=</code> ,<code>*=</code> ,<code>/=</code>, <code>%=</code>, <code>//=</code> ,<code>**=</code> ,<code>&amp;=</code>, `</td><td>=<code>,</code>^=<code>,</code>&gt;&gt;=<code>,</code>&lt;&lt;=`</td><td>（复合）赋值运算符</td></tr></tbody></table></div><h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><h2 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h2><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span><span class="hljs-string">分段函数求值</span><span class="hljs-string"></span><span class="hljs-string">        3x - 5  (x &gt; 1)</span><span class="hljs-string">f(x) =  x + 2   (-1 &lt;= x &lt;= 1)</span><span class="hljs-string">        5x + 3  (x &lt; -1)</span><span class="hljs-string"></span><span class="hljs-string">"""</span>x = float(input(<span class="hljs-string">'x = '</span>))<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:    y = <span class="hljs-number">3</span> * x - <span class="hljs-number">5</span><span class="hljs-keyword">elif</span> x &gt;= <span class="hljs-number">-1</span>:    y = x + <span class="hljs-number">2</span><span class="hljs-keyword">else</span>:    y = <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span>print(<span class="hljs-string">'f(%.2f) = %.2f'</span> % (x, y))</code></pre><br>Python中使用了缩进的方式来设置代码的层次结构，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。<br><pre><code class="hljs Python">x = float(input(<span class="hljs-string">'x = '</span>))<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">1</span>:    y = <span class="hljs-number">3</span> * x - <span class="hljs-number">5</span><span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">-1</span>:        y = x + <span class="hljs-number">2</span>    <span class="hljs-keyword">else</span>:        y = <span class="hljs-number">5</span> * x + <span class="hljs-number">3</span>print(<span class="hljs-string">'f(%.2f) = %.2f'</span> % (x, y))</code></pre><br><strong>补充</strong>\<br>1.使用random模块的randint函数生成指定范围的随机数来模拟<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint</code></pre><br>2.使用了<code>math</code>模块的<code>sqrt</code>函数来计算平方根。<br><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matha = float(input(<span class="hljs-string">'a = '</span>))b = float(input(<span class="hljs-string">'b = '</span>))c = float(input(<span class="hljs-string">'c = '</span>))<span class="hljs-keyword">if</span> a + b &gt; c <span class="hljs-keyword">and</span> a + c &gt; b <span class="hljs-keyword">and</span> b + c &gt; a:    print(<span class="hljs-string">'周长: %f'</span> % (a + b + c))    p = (a + b + c) / <span class="hljs-number">2</span>    area = math.sqrt(p * (p - a) * (p - b) * (p - c))    print(<span class="hljs-string">'面积: %f'</span> % (area))<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'不能构成三角形'</span>)</code></pre><br>3.Python内置的<code>abs()</code>函数取绝对值</p><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h2><p>明确的知道循环执行的次数或者要对一个容器进行迭代，推荐使用<code>for-in</code>循环。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span><span class="hljs-string">用for循环实现1~100求和</span><span class="hljs-string"></span><span class="hljs-string">"""</span>sum = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>):    sum += xprint(sum)</code></pre><br><strong>说明：</strong><code>range</code>类型\<br><code>range</code>可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的</p><ul><li><code>range(101)</code>可以产生一个0到100的整数序列。</li><li><code>range(1, 100)</code>可以产生一个1到99的整数序列。</li><li><code>range(1, 100, 2)</code>可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。</li></ul><p>注意：最后一位数不取。</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>要构造不知道具体循环次数的循环结构，推荐使用<code>while</code>循环。\<br><code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>循环继续，表达式的值为<code>False</code>循环结束。<br><pre><code class="hljs Python"><span class="hljs-string">"""</span><span class="hljs-string">猜数字游戏</span><span class="hljs-string">计算机出一个1~100之间的随机数由人来猜</span><span class="hljs-string">计算机根据人猜的数字分别给出提示大一点/小一点/猜对了</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> randomanswer = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)counter = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    counter += <span class="hljs-number">1</span>    number = int(input(<span class="hljs-string">'请输入: '</span>))    <span class="hljs-keyword">if</span> number &lt; answer:        print(<span class="hljs-string">'大一点'</span>)    <span class="hljs-keyword">elif</span> number &gt; answer:        print(<span class="hljs-string">'小一点'</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">'恭喜你猜对了!'</span>)        <span class="hljs-keyword">break</span>print(<span class="hljs-string">'你总共猜了%d次'</span> % counter)<span class="hljs-keyword">if</span> counter &gt; <span class="hljs-number">7</span>:    print(<span class="hljs-string">'你的智商余额明显不足'</span>)</code></pre><br><strong>说明</strong>\<br>1.<code>answer = random.randint(1, 100)</code>的理解：调用<code>random</code>包的<code>randint</code>函数。不可以只写<code>answer =randint(1, 100)</code>。要想直接使用<code>randint</code>，开头需改为<code>from randint import random</code>\<br>2.<code>while True:</code>的理解：循环条件一直为true，循环一致进行。\<br>3.使用<code>break</code>关键字来提前终止循环，当条件成立时（esle）运行<code>break</code>循环中断。注意<code>break</code>只能终止它所在的那个循环（跳出循环）。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮（不终止循环）</p><p>补充 ：<code>#%%</code>开启交互模式</p><h2 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h2><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在Python中使用<code>def</code>关键字来定义函数，在函数名后面的圆括号中可以放置传递给函数的参数，函数执行完成后我们可以通过<code>return</code>关键字来返回一个值。</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span><span class="hljs-params">(num)</span>:</span>    <span class="hljs-string">"""</span><span class="hljs-string">    求阶乘</span><span class="hljs-string">    </span><span class="hljs-string">    :param num: 非负整数</span><span class="hljs-string">    :return: num的阶乘</span><span class="hljs-string">    """</span>    result = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>):        result *= n    <span class="hljs-keyword">return</span> resultm = int(input(<span class="hljs-string">'m = '</span>))n = int(input(<span class="hljs-string">'n = '</span>))<span class="hljs-comment"># 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span>print(factorial(m) // factorial(n) // factorial(m - n))</code></pre><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>在Python中，函数的参数可以有默认值，也支持使用可变参数。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>, c=<span class="hljs-number">0</span>)</span>:</span>    <span class="hljs-keyword">return</span> a + b + c<span class="hljs-comment"># 传递参数时可以不按照设定的顺序进行传递，变量的设定与位置无关</span>print(add(c=<span class="hljs-number">50</span>, a=<span class="hljs-number">100</span>, b=<span class="hljs-number">200</span>))</code></pre><br>对0个或多个参数进行加法运算<br><pre><code class="hljs Python"><span class="hljs-comment"># 在参数名前面的*表示args是一个可变参数</span><span class="hljs-comment"># 即在调用add函数时可以传入0个或多个参数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(*args)</span>:</span>    total = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> args:        total += val    <span class="hljs-keyword">return</span> totalprint(add())print(add(<span class="hljs-number">1</span>))print(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))print(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))print(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>))</code></pre><br>可以把<code>args</code>理解为一个数组，<code>val</code>从数组中按顺序取值</p><h2 id="用模块管理函数、"><a href="#用模块管理函数、" class="headerlink" title="用模块管理函数、"></a>用模块管理函数、</h2><p>在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义。\<br>解决方法：\<br>Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块就可以区分到底要使用的是哪个模块中的函数，代码如下所示。</p><p>module1.py</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'hello, world!'</span>)</code></pre><p>module2.py</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'goodbye, world!'</span>)</code></pre><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> module1 <span class="hljs-keyword">import</span> foo<span class="hljs-comment"># 输出hello, world!</span>foo()<span class="hljs-keyword">from</span> module2 <span class="hljs-keyword">import</span> foo<span class="hljs-comment"># 输出goodbye, world!</span>foo()</code></pre><p>也可以按照如下所示的方式来区分到底要使用哪一个<code>foo</code>函数。</p><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> module1 <span class="hljs-keyword">as</span> m1<span class="hljs-keyword">import</span> module2 <span class="hljs-keyword">as</span> m2m1.foo()m2.foo()</code></pre><p>但如果同时调用两个两次函数，后导入的函数还是会覆盖之前的函数，如：</p><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">from</span> module1 <span class="hljs-keyword">import</span> foo<span class="hljs-keyword">from</span> module2 <span class="hljs-keyword">import</span> foo<span class="hljs-comment"># 输出goodbye, world!</span>foo()</code></pre><p>需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，（即<code>import XXX</code>后就会执行函数中的命令，而印象后续操作）因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中：</p><p>module3.py</p><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span><span class="hljs-comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    print(<span class="hljs-string">'call foo()'</span>)    foo()    print(<span class="hljs-string">'call bar()'</span>)    bar()</code></pre><p>test.py</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> module3<span class="hljs-comment"># 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</span></code></pre><p><strong>说明：</strong><code>pass</code>是空语句，是为了保持程序结构的完整性。不做任何事情，一般用做占位语句。</p><h1 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h1><h2 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h2><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    str1 = <span class="hljs-string">'hello, world!'</span>    <span class="hljs-comment"># 通过len函数计算字符串的长度</span>    print(len(str1))  <span class="hljs-comment"># 13</span>    <span class="hljs-comment"># 获得字符串首字母大写的拷贝</span>    print(str1.capitalize())  <span class="hljs-comment"># Hello, world!</span>    <span class="hljs-comment"># 获得字符串变大写后的拷贝</span>    print(str1.upper())  <span class="hljs-comment"># HELLO, WORLD!</span>    <span class="hljs-comment"># 从字符串中查找子串所在位置</span>    print(str1.find(<span class="hljs-string">'or'</span>))  <span class="hljs-comment"># 8</span>    print(str1.find(<span class="hljs-string">'shit'</span>))  <span class="hljs-comment"># -1</span>    <span class="hljs-comment"># 与find类似但找不到子串时会引发异常</span>    <span class="hljs-comment"># print(str1.index('or'))</span>    <span class="hljs-comment"># print(str1.index('shit'))</span>    <span class="hljs-comment"># 检查字符串是否以指定的字符串开头</span>    print(str1.startswith(<span class="hljs-string">'He'</span>))  <span class="hljs-comment"># False</span>    print(str1.startswith(<span class="hljs-string">'hel'</span>))  <span class="hljs-comment"># True</span>    <span class="hljs-comment"># 检查字符串是否以指定的字符串结尾</span>    print(str1.endswith(<span class="hljs-string">'!'</span>))  <span class="hljs-comment"># True</span>    <span class="hljs-comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span>    print(str1.center(<span class="hljs-number">50</span>, <span class="hljs-string">'*'</span>))<span class="hljs-comment">#******************hello, world!*******************</span>    <span class="hljs-comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span>    print(str1.rjust(<span class="hljs-number">50</span>, <span class="hljs-string">' '</span>))<span class="hljs-comment">#                                     hello, world!</span>    str2 = <span class="hljs-string">'abc123456'</span>    <span class="hljs-comment"># 从字符串中取出指定位置的字符(下标运算)</span>    print(str2[<span class="hljs-number">2</span>])  <span class="hljs-comment"># c</span>    <span class="hljs-comment"># 字符串切片(从指定的开始索引到指定的结束索引)</span>    print(str2[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])  <span class="hljs-comment"># c12</span>    print(str2[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># c123456</span>    print(str2[<span class="hljs-number">2</span>::<span class="hljs-number">2</span>])  <span class="hljs-comment"># c246</span>    print(str2[::<span class="hljs-number">2</span>])  <span class="hljs-comment"># ac246</span>    print(str2[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 654321cba</span>    print(str2[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 45</span>    <span class="hljs-comment"># 检查字符串是否由数字构成</span>    print(str2.isdigit())  <span class="hljs-comment"># False</span>    <span class="hljs-comment"># 检查字符串是否以字母构成</span>    print(str2.isalpha())  <span class="hljs-comment"># False</span>    <span class="hljs-comment"># 检查字符串是否以数字和字母构成</span>    print(str2.isalnum())  <span class="hljs-comment"># True</span>    str3 = <span class="hljs-string">'  jackfrued@126.com '</span>    print(str3)    <span class="hljs-comment"># 获得字符串修剪左右两侧空格的拷贝</span>    print(str3.strip())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h2><ul><li>定义列表、使用下标访问列表元素以及添加和删除元素的操作。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">100</span>]    print(list1)<span class="hljs-comment">#[1, 3, 5, 7, 100]</span>    list2 = [<span class="hljs-string">'hello'</span>] * <span class="hljs-number">5</span>    print(list2)<span class="hljs-comment">#['hello', 'hello', 'hello', 'hello', 'hello']</span>    <span class="hljs-comment"># 计算列表长度(元素个数)</span>    print(len(list1))<span class="hljs-comment">#5</span>    <span class="hljs-comment"># 下标(索引)运算</span>    print(list1[<span class="hljs-number">0</span>])<span class="hljs-comment">#1</span>    print(list1[<span class="hljs-number">4</span>])<span class="hljs-comment">#100</span>    <span class="hljs-comment"># print(list1[5])  # IndexError: list index out of range</span>    print(list1[<span class="hljs-number">-1</span>])<span class="hljs-comment">#100</span>    print(list1[<span class="hljs-number">-3</span>])<span class="hljs-comment">#5</span>    list1[<span class="hljs-number">2</span>] = <span class="hljs-number">300</span>    print(list1)<span class="hljs-comment">#[1, 3, 300, 7, 100]</span>    <span class="hljs-comment"># 添加元素</span>    list1.append(<span class="hljs-number">200</span>)<span class="hljs-comment">#在列表后添加</span>    list1.insert(<span class="hljs-number">1</span>, <span class="hljs-number">400</span>)<span class="hljs-comment">#在列表前添加</span>    list1 += [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>]<span class="hljs-comment">#在后添加</span>    print(list1)<span class="hljs-comment">#[1, 400, 3, 300, 7, 100, 200, 1000, 2000]</span>    print(len(list1))<span class="hljs-comment">#9</span>    <span class="hljs-comment"># 删除元素</span>    list1.remove(<span class="hljs-number">3</span>)    <span class="hljs-keyword">if</span> <span class="hljs-number">1234</span> <span class="hljs-keyword">in</span> list1:        list1.remove(<span class="hljs-number">1234</span>)    <span class="hljs-keyword">del</span> list1[<span class="hljs-number">0</span>]    print(list1)<span class="hljs-comment">#[400, 300, 7, 100, 200, 1000, 2000]</span>    <span class="hljs-comment"># 清空列表元素</span>    list1.clear()    print(list1)<span class="hljs-comment">#[]</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li><li>列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    fruits = [<span class="hljs-string">'grape'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'strawberry'</span>, <span class="hljs-string">'waxberry'</span>]    fruits += [<span class="hljs-string">'pitaya'</span>, <span class="hljs-string">'pear'</span>, <span class="hljs-string">'mango'</span>]    <span class="hljs-comment"># 循环遍历列表元素</span>    <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits:        print(fruit.title(), end=<span class="hljs-string">' '</span>)<span class="hljs-comment">#title函数使所有字母开头大写</span>    print()<span class="hljs-comment">#Grape Apple Strawberry Waxberry Pitaya Pear Mango </span>    <span class="hljs-comment"># 列表切片</span>    fruits2 = fruits[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]    print(fruits2)    <span class="hljs-comment"># fruit3 = fruits  # 没有复制列表只创建了新的引用</span>    <span class="hljs-comment"># 可以通过完整切片操作来复制列表</span>    fruits3 = fruits[:]    print(fruits3)    fruits4 = fruits[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>]    print(fruits4)    <span class="hljs-comment"># 可以通过反向切片操作来获得倒转后的列表的拷贝</span>    fruits5 = fruits[::<span class="hljs-number">-1</span>]    print(fruits5)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li></ul><ol><li>title函数使所有字母开头大写</li></ol><ul><li>列表的排序操作。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    list1 = [<span class="hljs-string">'orange'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'zoo'</span>, <span class="hljs-string">'internationalization'</span>, <span class="hljs-string">'blueberry'</span>]    list2 = sorted(list1)    <span class="hljs-comment"># sorted函数返回列表排序后的拷贝不会修改传入的列表</span>    <span class="hljs-comment"># 函数的设计就应该像sorted函数一样尽可能不产生副作用</span>    list3 = sorted(list1, reverse=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span>    list4 = sorted(list1, key=len)    print(list1)<span class="hljs-comment">#['orange', 'apple', 'zoo'，'internationalization', 'blueberry']</span>    print(list2)<span class="hljs-comment">#['apple', 'blueberry', 'internationalization', 'orange', 'zoo']</span>    print(list3)<span class="hljs-comment">#['zoo', 'orange', 'internationalization', 'blueberry', 'apple']</span>    print(list4)<span class="hljs-comment">#['zoo', 'apple', 'orange', 'blueberry', 'internationalization']</span>    <span class="hljs-comment"># 给列表对象发出排序消息直接在列表对象上进行排序</span>    list1.sort(reverse=<span class="hljs-literal">True</span>)    print(list1)<span class="hljs-comment">#['zoo', 'orange', 'internationalization', 'blueberry', 'apple']</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li><li>使用列表的生成式语法来创建列表<pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    f = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]    print(f)    f = [x + y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-string">'ABCDE'</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-string">'1234567'</span>]    print(f)    <span class="hljs-comment"># 用列表的生成表达式语法创建列表容器</span>    <span class="hljs-comment"># 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span>    f = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)]    print(sys.getsizeof(f))  <span class="hljs-comment"># 查看对象占用内存的字节数</span>    print(f)    <span class="hljs-comment"># 请注意下面的代码创建的不是一个列表而是一个生成器对象</span>    <span class="hljs-comment"># 通过生成器可以获取到数据但它不占用额外的空间存储数据</span>    <span class="hljs-comment"># 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span>    f = (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>))    print(sys.getsizeof(f))  <span class="hljs-comment"># 相比生成式生成器不占用存储数据的空间</span>    print(f)    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> f:        print(val)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li><li>通过<code>yield</code>关键字将一个普通函数改造成生成器函数。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span>:</span>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n):        a, b = b, a + b        <span class="hljs-keyword">yield</span> a<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> fib(<span class="hljs-number">20</span>):        print(val)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h2>Python 的元组与列表类似，不同之处在于元组的元素不能修改</li></ul><p>定义和使用元组。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 定义元组</span>    t = (<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">'四川成都'</span>)    print(t)    <span class="hljs-comment"># 获取元组中的元素</span>    print(t[<span class="hljs-number">0</span>])    print(t[<span class="hljs-number">3</span>])    <span class="hljs-comment"># 遍历元组中的值</span>    <span class="hljs-keyword">for</span> member <span class="hljs-keyword">in</span> t:        print(member)    <span class="hljs-comment"># 重新给元组赋值</span>    <span class="hljs-comment"># t[0] = '王大锤'  # TypeError</span>    <span class="hljs-comment"># 变量t重新引用了新的元组原来的元组将被垃圾回收</span>    t = (<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">'云南昆明'</span>)    print(t)    <span class="hljs-comment"># 将元组转换成列表</span>    person = list(t)    print(person)    <span class="hljs-comment"># 列表是可以修改它的元素的</span>    person[<span class="hljs-number">0</span>] = <span class="hljs-string">'李小龙'</span>    person[<span class="hljs-number">1</span>] = <span class="hljs-number">25</span>    print(person)    <span class="hljs-comment"># 将列表转换成元组</span>    fruits_list = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'orange'</span>]    fruits_tuple = tuple(fruits_list)    print(fruits_tuple)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><br>元组的优势：</p><ol><li>元组中的元素是无法修改的。</li><li>元组在创建时间和占用的空间上面都优于列表。<h2 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h2>Python中的集合不允许有重复元素，而且可以进行交集、并集、差集等运算。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    set1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;    print(set1)<span class="hljs-comment">#&#123;1, 2, 3&#125;</span>    print(<span class="hljs-string">'Length ='</span>, len(set1))<span class="hljs-comment">#Length = 3</span>    set2 = set(range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))    print(set2)<span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span>    set1.add(<span class="hljs-number">4</span>)    set1.add(<span class="hljs-number">5</span>)    set2.update([<span class="hljs-number">11</span>, <span class="hljs-number">12</span>])    print(set1)<span class="hljs-comment">#&#123;1, 2, 3, 4, 5&#125;</span>    print(set2)<span class="hljs-comment">#&#123;1, 2, 3, 6, 7, 8, 9, 11, 12&#125;</span>    set2.discard(<span class="hljs-number">5</span>)    <span class="hljs-comment"># remove的元素如果不存在会引发KeyError</span>    <span class="hljs-keyword">if</span> <span class="hljs-number">4</span> <span class="hljs-keyword">in</span> set2:        set2.remove(<span class="hljs-number">4</span>)    print(set2)    <span class="hljs-comment"># 遍历集合容器</span>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> set2:        print(elem ** <span class="hljs-number">2</span>, end=<span class="hljs-string">' '</span>)    print()    <span class="hljs-comment"># 将元组转换成集合</span>    set3 = set((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>))    print(set3.pop())    print(set3)    <span class="hljs-comment"># 集合的交集、并集、差集、对称差运算</span>    print(set1 &amp; set2)    <span class="hljs-comment"># print(set1.intersection(set2))</span>    print(set1 | set2)    <span class="hljs-comment"># print(set1.union(set2))</span>    print(set1 - set2)    <span class="hljs-comment"># print(set1.difference(set2))</span>    print(set1 ^ set2)    <span class="hljs-comment"># print(set1.symmetric_difference(set2))</span>    <span class="hljs-comment"># 判断子集和超集</span>    print(set2 &lt;= set1)    <span class="hljs-comment"># print(set2.issubset(set1))</span>    print(set3 &lt;= set1)    <span class="hljs-comment"># print(set3.issubset(set1))</span>    print(set1 &gt;= set2)    <span class="hljs-comment"># print(set1.issuperset(set2))</span>    print(set1 &gt;= set3)    <span class="hljs-comment"># print(set1.issuperset(set3))</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h2>字典是另一种可变容器模型，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。<pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    scores = &#123;<span class="hljs-string">'骆昊'</span>: <span class="hljs-number">95</span>, <span class="hljs-string">'白元芳'</span>: <span class="hljs-number">78</span>, <span class="hljs-string">'狄仁杰'</span>: <span class="hljs-number">82</span>&#125;    <span class="hljs-comment"># 通过键可以获取字典中对应的值</span>    print(scores[<span class="hljs-string">'骆昊'</span>])    print(scores[<span class="hljs-string">'狄仁杰'</span>])    <span class="hljs-comment"># 对字典进行遍历(遍历的其实是键再通过键取对应的值)</span>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> scores:        print(<span class="hljs-string">'%s\t---&gt;\t%d'</span> % (elem, scores[elem]))    <span class="hljs-comment"># 更新字典中的元素</span>    scores[<span class="hljs-string">'白元芳'</span>] = <span class="hljs-number">65</span>    scores[<span class="hljs-string">'诸葛王朗'</span>] = <span class="hljs-number">71</span>    scores.update(冷面=<span class="hljs-number">67</span>, 方启鹤=<span class="hljs-number">85</span>)    print(scores)    <span class="hljs-keyword">if</span> <span class="hljs-string">'武则天'</span> <span class="hljs-keyword">in</span> scores:        print(scores[<span class="hljs-string">'武则天'</span>])    print(scores.get(<span class="hljs-string">'武则天'</span>))    <span class="hljs-comment"># get方法也是通过键获取对应的值但是可以设置默认值</span>    print(scores.get(<span class="hljs-string">'武则天'</span>, <span class="hljs-number">60</span>))    <span class="hljs-comment"># 删除字典中的元素</span>    print(scores.popitem())    print(scores.popitem())    print(scores.pop(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">100</span>))    <span class="hljs-comment"># 清空字典</span>    scores.clear()    print(scores)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></li></ol><h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>在Python中可以使用<code>class</code>关键字定义类。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span>    <span class="hljs-comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self.name = name        self.age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, course_name)</span>:</span>        print(<span class="hljs-string">'%s正在学习%s.'</span> % (self.name, course_name))    <span class="hljs-comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span>    <span class="hljs-comment"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">watch_movie</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self.age &lt; <span class="hljs-number">18</span>:            print(<span class="hljs-string">'%s只能观看《熊出没》.'</span> % self.name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s正在观看岛国爱情大电影.'</span> % self.name)</code></pre></p><blockquote><p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。\<br><code>self</code>不可少，且必须放在其他形参前面。</p><h2 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h2><p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。<br><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 创建学生对象并指定姓名和年龄</span>    stu1 = Student(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>)    <span class="hljs-comment"># 给对象发study消息</span>    stu1.study(<span class="hljs-string">'Python程序设计'</span>)    <span class="hljs-comment"># 给对象发watch_av消息</span>    stu1.watch_movie()    stu2 = Student(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">15</span>)    stu2.study(<span class="hljs-string">'思想品德'</span>)    stu2.watch_movie()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()    <span class="hljs-comment">#output:</span>    <span class="hljs-comment">#骆昊正在学习Python程序设计.</span>    <span class="hljs-comment">#骆昊正在观看岛国爱情大电影.</span>    <span class="hljs-comment">#王大锤正在学习思想品德.</span>    <span class="hljs-comment">#王大锤只能观看《熊出没》.</span></code></pre><br>方法前面的后缀为<code>self</code>的值</p><h2 id="访问可见性问题"><a href="#访问可见性问题" class="headerlink" title="访问可见性问题"></a>访问可见性问题</h2><p>在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, foo)</span>:</span>        self.__foo = foo    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bar</span><span class="hljs-params">(self)</span>:</span>        print(self.__foo)        print(<span class="hljs-string">'__bar'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    test = Test(<span class="hljs-string">'hello'</span>)    <span class="hljs-comment"># AttributeError（报错）: 'Test' object has no attribute '__bar'</span>    test.__bar()    <span class="hljs-comment"># AttributeError: 'Test' object has no attribute '__foo'</span>    print(test.__foo)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><br>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, foo)</span>:</span>        self.__foo = foo    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bar</span><span class="hljs-params">(self)</span>:</span>        print(self.__foo)        print(<span class="hljs-string">'__bar'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    test = Test(<span class="hljs-string">'hello'</span>)    test._Test__bar()    print(test._Test__foo)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre></p></blockquote><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”</p><h2 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h2><p>如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self._name = name        self._age = age    <span class="hljs-comment"># 访问器 - getter方法</span><span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._name    <span class="hljs-comment"># 访问器 - getter方法</span><span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._age    <span class="hljs-comment"># 修改器 - setter方法</span><span class="hljs-meta">    @age.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>        self._age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self._age &lt;= <span class="hljs-number">16</span>:            print(<span class="hljs-string">'%s正在玩飞行棋.'</span> % self._name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s正在玩斗地主.'</span> % self._name)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    person = Person(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">12</span>)    person.play()    person.age = <span class="hljs-number">22</span>    person.play()    <span class="hljs-comment"># person.name = '白元芳'  # AttributeError: can't set attribute</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></p><h2 id="slots魔法"><a href="#slots魔法" class="headerlink" title="slots魔法"></a><strong>slots</strong>魔法</h2><p>Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。\<br>但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><p>?<br><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-comment"># 限定Person对象只能绑定_name, _age和_gender属性</span>    __slots__ = (<span class="hljs-string">'_name'</span>, <span class="hljs-string">'_age'</span>, <span class="hljs-string">'_gender'</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self._name = name        self._age = age<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._name<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._age<span class="hljs-meta">    @age.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>        self._age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self._age &lt;= <span class="hljs-number">16</span>:            print(<span class="hljs-string">'%s正在玩飞行棋.'</span> % self._name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s正在玩斗地主.'</span> % self._name)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    person = Person(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">22</span>)    person.play()    person._gender = <span class="hljs-string">'男'</span>    <span class="hljs-comment"># AttributeError: 'Person' object has no attribute '_is_gay'</span>    <span class="hljs-comment"># person._is_gay = True</span></code></pre></p><h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在<strong>类中的方法并不需要都是对象方法</strong>。<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, a, b, c)</span>:</span>        self._a = a        self._b = b        self._c = c<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(a, b, c)</span>:</span>        <span class="hljs-keyword">return</span> a + b &gt; c <span class="hljs-keyword">and</span> b + c &gt; a <span class="hljs-keyword">and</span> a + c &gt; b    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._a + self._b + self._c    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span><span class="hljs-params">(self)</span>:</span>        half = self.perimeter() / <span class="hljs-number">2</span>        <span class="hljs-keyword">return</span> sqrt(half * (half - self._a) *                    (half - self._b) * (half - self._c))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    a, b, c = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>    <span class="hljs-comment"># 静态方法和类方法都是通过给类发消息来调用的</span>    <span class="hljs-keyword">if</span> Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)        print(t.perimeter())        <span class="hljs-comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span>        <span class="hljs-comment"># print(Triangle.perimeter(t))</span>        print(t.area())        <span class="hljs-comment"># print(Triangle.area(t))</span>    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">'无法构成三角形.'</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><br>Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象\<br>（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象。<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time, localtime, sleep<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-string">"""数字时钟"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hour=<span class="hljs-number">0</span>, minute=<span class="hljs-number">0</span>, second=<span class="hljs-number">0</span>)</span>:</span>        self._hour = hour        self._minute = minute        self._second = second<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span><span class="hljs-params">(cls)</span>:</span>        ctime = localtime(time())        <span class="hljs-keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""走字"""</span>        self._second += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> self._second == <span class="hljs-number">60</span>:            self._second = <span class="hljs-number">0</span>            self._minute += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> self._minute == <span class="hljs-number">60</span>:                self._minute = <span class="hljs-number">0</span>                self._hour += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> self._hour == <span class="hljs-number">24</span>:                    self._hour = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""显示时间"""</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'%02d:%02d:%02d'</span> % \               (self._hour, self._minute, self._second)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># 通过类方法创建对象并获取系统时间</span>    clock = Clock.now()    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        print(clock.show())        sleep(<span class="hljs-number">1</span>)        clock.run()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre></p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>类和类之间的关系有三种：is-a、has-a和use-a关系。</p><ul><li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接<strong>继承</strong>下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。</p><pre><code class="hljs Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-string">"""人"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>        self._name = name        self._age = age<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._name<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._age<span class="hljs-meta">    @age.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span><span class="hljs-params">(self, age)</span>:</span>        self._age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'%s正在愉快的玩耍.'</span> % self._name)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">watch_av</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self._age &gt;= <span class="hljs-number">18</span>:            print(<span class="hljs-string">'%s正在观看爱情动作片.'</span> % self._name)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">'%s只能观看《熊出没》.'</span> % self._name)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(Person)</span>:</span>    <span class="hljs-string">"""学生"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, grade)</span>:</span>        super().__init__(name, age)        self._grade = grade    <span class="hljs-comment">#继承Person类</span><span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._grade<span class="hljs-meta">    @grade.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grade</span><span class="hljs-params">(self, grade)</span>:</span>        self._grade = grade    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, course)</span>:</span>        print(<span class="hljs-string">'%s的%s正在学习%s.'</span> % (self._grade, self._name, course))<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(Person)</span>:</span>    <span class="hljs-string">"""老师"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, title)</span>:</span>        super().__init__(name, age)        self._title = title<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self._title<span class="hljs-meta">    @title.setter</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span><span class="hljs-params">(self, title)</span>:</span>        self._title = title    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teach</span><span class="hljs-params">(self, course)</span>:</span>        print(<span class="hljs-string">'%s%s正在讲%s.'</span> % (self._name, self._title, course))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    stu = Student(<span class="hljs-string">'王大锤'</span>, <span class="hljs-number">15</span>, <span class="hljs-string">'初三'</span>)    stu.study(<span class="hljs-string">'数学'</span>)    stu.watch_av()    t = Teacher(<span class="hljs-string">'骆昊'</span>, <span class="hljs-number">38</span>, <span class="hljs-string">'老叫兽'</span>)    t.teach(<span class="hljs-string">'Python程序设计'</span>)    t.watch_av()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法<strong>重写</strong>（override）。</p><p>通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是<strong>多态</strong>（poly-morphism）<br><pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span><span class="hljs-params">(object, metaclass=ABCMeta)</span>:</span>    <span class="hljs-string">"""宠物"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, nickname)</span>:</span>        self._nickname = nickname<span class="hljs-meta">    @abstractmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""发出声音"""</span>        <span class="hljs-keyword">pass</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><span class="hljs-params">(Pet)</span>:</span>    <span class="hljs-string">"""狗"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'%s: 汪汪汪...'</span> % self._nickname)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span><span class="hljs-params">(Pet)</span>:</span>    <span class="hljs-string">"""猫"""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_voice</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'%s: 喵...喵...'</span> % self._nickname)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    pets = [Dog(<span class="hljs-string">'旺财'</span>), Cat(<span class="hljs-string">'凯蒂'</span>), Dog(<span class="hljs-string">'大黄'</span>)]    <span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> pets:        pet.make_voice()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><br>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p>]]></content>
    
    
    <categories>
      
      <category>computer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
